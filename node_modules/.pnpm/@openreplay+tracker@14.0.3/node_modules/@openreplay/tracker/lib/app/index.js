import { gzip } from 'fflate';
import AttributeSender from '../modules/attributeSender.js';
import ConditionsManager from '../modules/conditionsManager.js';
import FeatureFlags from '../modules/featureFlags.js';
import { deviceMemory, jsHeapSizeLimit } from '../modules/performance.js';
import TagWatcher from '../modules/tagWatcher.js';
import UserTestManager from '../modules/userTesting/index.js';
import { adjustTimeOrigin, createEventListener, deleteEventListener, now, requestIdleCb, simpleMerge, } from '../utils.js';
import CanvasRecorder from './canvas.js';
import Logger, { LogLevel } from './logger.js';
import { Metadata, TabChange, TabData, TagTrigger, Timestamp, UserID, WSChannel, } from './messages.gen.js';
import Nodes from './nodes.js';
import Observer from './observer/top_observer.js';
import Sanitizer from './sanitizer.js';
import Session from './session.js';
import Ticker from './ticker.js';
const CANCELED = 'canceled';
const uxtStorageKey = 'or_uxt_active';
const bufferStorageKey = 'or_buffer_1';
const UnsuccessfulStart = (reason) => ({ reason, success: false });
const SuccessfulStart = (body) => ({ ...body, success: true });
var ActivityState;
(function (ActivityState) {
    ActivityState[ActivityState["NotActive"] = 0] = "NotActive";
    ActivityState[ActivityState["Starting"] = 1] = "Starting";
    ActivityState[ActivityState["Active"] = 2] = "Active";
    ActivityState[ActivityState["ColdStart"] = 3] = "ColdStart";
})(ActivityState || (ActivityState = {}));
// TODO: use backendHost only
export const DEFAULT_INGEST_POINT = 'https://api.openreplay.com/ingest';
function getTimezone() {
    const offset = new Date().getTimezoneOffset() * -1;
    const sign = offset >= 0 ? '+' : '-';
    const hours = Math.floor(Math.abs(offset) / 60);
    const minutes = Math.abs(offset) % 60;
    return `UTC${sign}${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
}
const delay = (ms) => new Promise((res) => setTimeout(res, ms));
const proto = {
    // ask if there are any tabs alive
    ask: 'never-gonna-give-you-up',
    // response from another tab
    resp: 'never-gonna-let-you-down',
    // regenerating id (copied other tab)
    reg: 'never-gonna-run-around-and-desert-you',
    // tracker inside a child iframe
    iframeSignal: 'never-gonna-make-you-cry',
    // getting node id for child iframe
    iframeId: 'never-gonna-say-goodbye',
    // batch of messages from an iframe window
    iframeBatch: 'never-gonna-tell-a-lie-and-hurt-you',
};
export default class App {
    constructor(projectKey, sessionToken, options, signalError, insideIframe) {
        this.signalError = signalError;
        this.insideIframe = insideIframe;
        this.messages = [];
        /**
         * we need 2 buffers, so we don't lose anything
         * @read coldStart implementation
         * */
        this.bufferedMessages1 = [];
        this.bufferedMessages2 = [];
        this.startCallbacks = [];
        this.stopCallbacks = [];
        this.commitCallbacks = [];
        this.activityState = ActivityState.NotActive;
        this.version = '14.0.3'; // TODO: version compatability check inside each plugin.
        this.socketMode = false;
        this.compressionThreshold = 24 * 1000;
        this.bc = null;
        this.canvasRecorder = null;
        this.conditionsManager = null;
        this.canStart = false;
        this.rootId = null;
        this.pageFrames = [];
        this.frameOderNumber = 0;
        this.initialHostName = location.hostname;
        this.startTimeout = null;
        this.coldStartCommitN = 0;
        this.delay = 0;
        this.coldInterval = null;
        this.orderNumber = 0;
        this.coldStartTs = 0;
        this.singleBuffer = false;
        this.onSessionSent = () => {
            return;
        };
        this.restartCanvasTracking = () => {
            this.canvasRecorder?.restartTracking();
        };
        this.flushBuffer = async (buffer) => {
            return new Promise((res) => {
                let ended = false;
                const messagesBatch = [buffer.shift()];
                while (!ended) {
                    const nextMsg = buffer[0];
                    if (!nextMsg || nextMsg[0] === 0 /* MType.Timestamp */) {
                        ended = true;
                    }
                    else {
                        messagesBatch.push(buffer.shift());
                    }
                }
                this.postToWorker(messagesBatch);
                res(null);
            });
        };
        this.onUxtCb = [];
        this.contextId = Math.random().toString(36).slice(2);
        this.projectKey = projectKey;
        if (Object.keys(options).findIndex((k) => ['fixedCanvasScaling', 'disableCanvas'].includes(k)) !==
            -1) {
            console.warn('Openreplay: canvas options are moving to separate key "canvas" in next update. Please update your configuration.');
            options = {
                ...options,
                canvas: {
                    __save_canvas_locally: options.__save_canvas_locally,
                    fixedCanvasScaling: options.fixedCanvasScaling,
                    disableCanvas: options.disableCanvas,
                },
            };
        }
        this.networkOptions = options.network;
        const defaultOptions = {
            revID: '',
            node_id: '__openreplay_id',
            session_token_key: '__openreplay_token',
            session_pageno_key: '__openreplay_pageno',
            session_reset_key: '__openreplay_reset',
            session_tabid_key: '__openreplay_tabid',
            local_uuid_key: '__openreplay_uuid',
            ingestPoint: DEFAULT_INGEST_POINT,
            resourceBaseHref: null,
            __is_snippet: false,
            __debug_report_edp: null,
            __debug__: LogLevel.Silent,
            __save_canvas_locally: false,
            localStorage: null,
            sessionStorage: null,
            disableStringDict: false,
            forceSingleTab: false,
            assistSocketHost: '',
            fixedCanvasScaling: false,
            disableCanvas: false,
            captureIFrames: true,
            obscureTextEmails: true,
            obscureTextNumbers: false,
            crossdomain: {
                parentDomain: '*',
            },
            canvas: {
                disableCanvas: false,
                fixedCanvasScaling: false,
                __save_canvas_locally: false,
                useAnimationFrame: false,
            },
        };
        this.options = simpleMerge(defaultOptions, options);
        if (!this.insideIframe &&
            !this.options.forceSingleTab &&
            globalThis &&
            'BroadcastChannel' in globalThis) {
            const host = location.hostname.split('.').slice(-2).join('_');
            this.bc = new BroadcastChannel(`rick_${host}`);
        }
        this.revID = this.options.revID;
        this.localStorage = this.options.localStorage ?? window.localStorage;
        this.sessionStorage = this.options.sessionStorage ?? window.sessionStorage;
        this.sanitizer = new Sanitizer(this, options);
        this.nodes = new Nodes(this.options.node_id);
        this.observer = new Observer(this, options);
        this.ticker = new Ticker(this);
        this.ticker.attach(() => this.commit());
        this.debug = new Logger(this.options.__debug__);
        this.session = new Session(this, this.options);
        this.attributeSender = new AttributeSender(this, Boolean(this.options.disableStringDict));
        this.featureFlags = new FeatureFlags(this);
        this.tagWatcher = new TagWatcher(this.sessionStorage, this.debug.error, (tag) => {
            this.send(TagTrigger(tag));
        });
        this.session.attachUpdateCallback(({ userID, metadata }) => {
            if (userID != null) {
                // TODO: nullable userID
                this.send(UserID(userID));
            }
            if (metadata != null) {
                Object.entries(metadata).forEach(([key, value]) => this.send(Metadata(key, value)));
            }
        });
        // @deprecated (use sessionHash on start instead)
        if (sessionToken != null) {
            this.session.applySessionHash(sessionToken);
        }
        this.initWorker();
        const thisTab = this.session.getTabId();
        if (!this.insideIframe) {
            /**
             * if we get a signal from child iframes, we check for their node_id and send it back,
             * so they can act as if it was just a same-domain iframe
             * */
            let crossdomainFrameCount = 0;
            const catchIframeMessage = (event) => {
                const { data } = event;
                if (data.line === proto.iframeSignal) {
                    const childIframeDomain = data.domain;
                    const pageIframes = Array.from(document.querySelectorAll('iframe'));
                    this.pageFrames = pageIframes;
                    const signalId = async () => {
                        let tries = 0;
                        while (tries < 10) {
                            const id = this.checkNodeId(pageIframes, childIframeDomain);
                            if (id) {
                                this.waitStarted()
                                    .then(() => {
                                    crossdomainFrameCount++;
                                    const token = this.session.getSessionToken();
                                    const iframeData = {
                                        line: proto.iframeId,
                                        context: this.contextId,
                                        domain: childIframeDomain,
                                        id,
                                        token,
                                        frameOrderNumber: crossdomainFrameCount,
                                    };
                                    this.debug.log('iframe_data', iframeData);
                                    // @ts-ignore
                                    event.source?.postMessage(iframeData, '*');
                                })
                                    .catch(console.error);
                                tries = 10;
                                break;
                            }
                            tries++;
                            await delay(100);
                        }
                    };
                    void signalId();
                }
                /**
                 * proxying messages from iframe to main body, so they can be in one batch (same indexes, etc)
                 * plus we rewrite some of the messages to be relative to the main context/window
                 * */
                if (data.line === proto.iframeBatch) {
                    const msgBatch = data.messages;
                    const mappedMessages = msgBatch.map((msg) => {
                        if (msg[0] === 20 /* MType.MouseMove */) {
                            let fixedMessage = msg;
                            this.pageFrames.forEach((frame) => {
                                if (frame.dataset.domain === event.data.domain) {
                                    const [type, x, y] = msg;
                                    const { left, top } = frame.getBoundingClientRect();
                                    fixedMessage = [type, x + left, y + top];
                                }
                            });
                            return fixedMessage;
                        }
                        if (msg[0] === 68 /* MType.MouseClick */) {
                            let fixedMessage = msg;
                            this.pageFrames.forEach((frame) => {
                                if (frame.dataset.domain === event.data.domain) {
                                    const [type, id, hesitationTime, label, selector, normX, normY] = msg;
                                    const { left, top, width, height } = frame.getBoundingClientRect();
                                    const contentWidth = document.documentElement.scrollWidth;
                                    const contentHeight = document.documentElement.scrollHeight;
                                    // (normalizedX * frameWidth + frameLeftOffset)/docSize
                                    const fullX = (normX / 100) * width + left;
                                    const fullY = (normY / 100) * height + top;
                                    const fixedX = fullX / contentWidth;
                                    const fixedY = fullY / contentHeight;
                                    fixedMessage = [
                                        type,
                                        id,
                                        hesitationTime,
                                        label,
                                        selector,
                                        Math.round(fixedX * 1e3) / 1e1,
                                        Math.round(fixedY * 1e3) / 1e1,
                                    ];
                                }
                            });
                            return fixedMessage;
                        }
                        return msg;
                    });
                    this.messages.push(...mappedMessages);
                }
            };
            window.addEventListener('message', catchIframeMessage);
            this.attachStopCallback(() => {
                window.removeEventListener('message', catchIframeMessage);
            });
        }
        else {
            const catchParentMessage = (event) => {
                const { data } = event;
                if (data.line !== proto.iframeId) {
                    return;
                }
                this.rootId = data.id;
                this.session.setSessionToken(data.token);
                this.frameOderNumber = data.frameOrderNumber;
                this.debug.log('starting iframe tracking', data);
                this.allowAppStart();
            };
            window.addEventListener('message', catchParentMessage);
            this.attachStopCallback(() => {
                window.removeEventListener('message', catchParentMessage);
            });
            // communicating with parent window,
            // even if its crossdomain is possible via postMessage api
            const domain = this.initialHostName;
            window.parent.postMessage({
                line: proto.iframeSignal,
                source: thisTab,
                context: this.contextId,
                domain,
            }, '*');
        }
        if (this.bc !== null) {
            this.bc.postMessage({
                line: proto.ask,
                source: thisTab,
                context: this.contextId,
            });
            this.startTimeout = setTimeout(() => {
                this.allowAppStart();
            }, 500);
            this.bc.onmessage = (ev) => {
                if (ev.data.context === this.contextId) {
                    return;
                }
                if (ev.data.line === proto.resp) {
                    const sessionToken = ev.data.token;
                    this.session.setSessionToken(sessionToken);
                    this.allowAppStart();
                }
                if (ev.data.line === proto.reg) {
                    const sessionToken = ev.data.token;
                    this.session.regenerateTabId();
                    this.session.setSessionToken(sessionToken);
                    this.allowAppStart();
                }
                if (ev.data.line === proto.ask) {
                    const token = this.session.getSessionToken();
                    if (token && this.bc) {
                        this.bc.postMessage({
                            line: ev.data.source === thisTab ? proto.reg : proto.resp,
                            token,
                            source: thisTab,
                            context: this.contextId,
                        });
                    }
                }
            };
        }
    }
    allowAppStart() {
        this.canStart = true;
        if (this.startTimeout) {
            clearTimeout(this.startTimeout);
            this.startTimeout = null;
        }
    }
    checkNodeId(iframes, domain) {
        for (const iframe of iframes) {
            if (iframe.dataset.domain === domain) {
                // @ts-ignore
                return iframe[this.options.node_id];
            }
        }
        return null;
    }
    initWorker() {
        try {
            this.worker = new Worker(URL.createObjectURL(new Blob(['"use strict";class t{constructor(t,s,i,e=10,n=250,h,r){this.onUnauthorised=s,this.onFailure=i,this.MAX_ATTEMPTS_COUNT=e,this.ATTEMPT_TIMEOUT=n,this.onCompress=h,this.pageNo=r,this.attemptsCount=0,this.busy=!1,this.queue=[],this.token=null,this.lastBatchNum=0,this.ingestURL=t+"/v1/web/i",this.isCompressing=void 0!==h}getQueueStatus(){return 0===this.queue.length&&!this.busy}authorise(t){this.token=t,this.busy||this.sendNext()}push(t){if(this.busy||!this.token)this.queue.push(t);else if(this.busy=!0,this.isCompressing&&this.onCompress)this.onCompress(t);else{const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}}sendNext(){const t=this.queue.shift();if(t)if(this.busy=!0,this.isCompressing&&this.onCompress)this.onCompress(t);else{const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}else this.busy=!1}retry(t,s,i){this.attemptsCount>=this.MAX_ATTEMPTS_COUNT?this.onFailure(`Failed to send batch after ${this.attemptsCount} attempts.`):(this.attemptsCount++,setTimeout((()=>this.sendBatch(t,s,i)),this.ATTEMPT_TIMEOUT*this.attemptsCount))}sendBatch(t,s,i){const e=i?.toString().replace(/^([^_]+)_([^_]+).*/,"$1_$2_$3");this.busy=!0;const n={Authorization:`Bearer ${this.token}`};s&&(n["Content-Encoding"]="gzip"),null!==this.token?fetch(`${this.ingestURL}?batch=${this.pageNo??"noPageNum"}_${e??"noBatchNum"}`,{body:t,method:"POST",headers:n,keepalive:t.length<65536}).then((e=>{if(401===e.status)return this.busy=!1,void this.onUnauthorised();e.status>=400?this.retry(t,s,`${i??"noBatchNum"}_network:${e.status}`):(this.attemptsCount=0,this.sendNext())})).catch((e=>{console.warn("OpenReplay:",e),this.retry(t,s,`${i??"noBatchNum"}_reject:${e.message}`)})):setTimeout((()=>{this.sendBatch(t,s,`${i??"noBatchNum"}_newToken`)}),500)}sendCompressed(t){const s=++this.lastBatchNum;this.sendBatch(t,!0,s)}sendUncompressed(t){const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}clean(){this.sendNext(),setTimeout((()=>{this.token=null,this.queue.length=0}),10)}}const s="function"==typeof TextEncoder?new TextEncoder:{encode(t){const s=t.length,i=new Uint8Array(3*s);let e=-1;for(let n=0,h=0,r=0;r!==s;){if(n=t.charCodeAt(r),r+=1,n>=55296&&n<=56319){if(r===s){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;break}if(h=t.charCodeAt(r),!(h>=56320&&h<=57343)){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;continue}if(n=1024*(n-55296)+h-56320+65536,r+=1,n>65535){i[e+=1]=240|n>>>18,i[e+=1]=128|n>>>12&63,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n;continue}}n<=127?i[e+=1]=0|n:n<=2047?(i[e+=1]=192|n>>>6,i[e+=1]=128|63&n):(i[e+=1]=224|n>>>12,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n)}return i.subarray(0,e+1)}};class i{constructor(t){this.size=t,this.offset=0,this.checkpointOffset=0,this.data=new Uint8Array(t)}getCurrentOffset(){return this.offset}checkpoint(){this.checkpointOffset=this.offset}get isEmpty(){return 0===this.offset}skip(t){return this.offset+=t,this.offset<=this.size}set(t,s){this.data.set(t,s)}boolean(t){return this.data[this.offset++]=+t,this.offset<=this.size}uint(t){for((t<0||t>Number.MAX_SAFE_INTEGER)&&(t=0);t>=128;)this.data[this.offset++]=t%256|128,t=Math.floor(t/128);return this.data[this.offset++]=t,this.offset<=this.size}int(t){return t=Math.round(t),this.uint(t>=0?2*t:-2*t-1)}string(t){const i=s.encode(t),e=i.byteLength;return!(!this.uint(e)||this.offset+e>this.size)&&(this.data.set(i,this.offset),this.offset+=e,!0)}reset(){this.offset=0,this.checkpointOffset=0}flush(){const t=this.data.slice(0,this.checkpointOffset);return this.reset(),t}}class e extends i{encode(t){switch(t[0]){case 0:case 11:case 114:case 115:return this.uint(t[1]);case 4:case 44:case 47:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3]);case 5:case 20:case 38:case 70:case 75:case 76:case 77:case 82:return this.uint(t[1])&&this.uint(t[2]);case 6:return this.int(t[1])&&this.int(t[2]);case 7:return!0;case 8:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.string(t[4])&&this.boolean(t[5]);case 9:case 10:case 24:case 51:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3]);case 12:case 61:case 71:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3]);case 13:case 14:case 17:case 50:case 54:return this.uint(t[1])&&this.string(t[2]);case 16:return this.uint(t[1])&&this.int(t[2])&&this.int(t[3]);case 18:return this.uint(t[1])&&this.string(t[2])&&this.int(t[3]);case 19:return this.uint(t[1])&&this.boolean(t[2]);case 21:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8]);case 22:case 27:case 30:case 41:case 45:case 46:case 63:case 64:case 79:return this.string(t[1])&&this.string(t[2]);case 23:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 28:case 29:case 42:case 117:case 118:return this.string(t[1]);case 37:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3]);case 39:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7]);case 40:return this.string(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 48:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.int(t[5]);case 49:return this.int(t[1])&&this.int(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 53:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8]);case 55:return this.boolean(t[1]);case 57:case 60:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 58:case 120:return this.int(t[1]);case 59:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6])&&this.string(t[7]);case 67:case 73:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 68:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6]);case 69:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 78:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 81:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.int(t[4])&&this.string(t[5]);case 83:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 84:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6]);case 112:return this.uint(t[1])&&this.string(t[2])&&this.boolean(t[3])&&this.string(t[4])&&this.int(t[5])&&this.int(t[6]);case 113:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3]);case 116:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8])&&this.uint(t[9])&&this.boolean(t[10]);case 119:return this.string(t[1])&&this.uint(t[2]);case 121:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 122:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 123:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])}}}class n{constructor(t,s,i,n,h,r){this.pageNo=t,this.timestamp=s,this.url=i,this.onBatch=n,this.tabId=h,this.onOfflineEnd=r,this.nextIndex=0,this.beaconSize=2e5,this.encoder=new e(this.beaconSize),this.sizeBuffer=new Uint8Array(3),this.isEmpty=!0,this.beaconSizeLimit=1e6,this.prepare()}writeType(t){return this.encoder.uint(t[0])}writeFields(t){return this.encoder.encode(t)}writeSizeAt(t,s){for(let s=0;s<3;s++)this.sizeBuffer[s]=t>>8*s;this.encoder.set(this.sizeBuffer,s)}prepare(){if(!this.encoder.isEmpty)return;const t=[81,1,this.pageNo,this.nextIndex,this.timestamp,this.url],s=[118,this.tabId];this.writeType(t),this.writeFields(t),this.writeWithSize(s),this.isEmpty=!0}writeWithSize(t){const s=this.encoder;if(!this.writeType(t)||!s.skip(3))return!1;const i=s.getCurrentOffset(),e=this.writeFields(t);if(e){const e=s.getCurrentOffset()-i;if(e>16777215)return console.warn("OpenReplay: max message size overflow."),!1;this.writeSizeAt(e,i-3),s.checkpoint(),this.isEmpty=this.isEmpty&&0===t[0],this.nextIndex++}return e}setBeaconSizeLimit(t){this.beaconSizeLimit=t}writeMessage(t){if("q_end"===t[0])return this.finaliseBatch(),this.onOfflineEnd();0===t[0]&&(this.timestamp=t[1]),122===t[0]&&(this.url=t[1]),this.writeWithSize(t)||(this.finaliseBatch(),this.writeWithSize(t)||(this.encoder=new e(this.beaconSizeLimit),this.prepare(),this.writeWithSize(t)?this.finaliseBatch():console.warn("OpenReplay: beacon size overflow. Skipping large message.",t,this),this.encoder=new e(this.beaconSize),this.prepare()))}finaliseBatch(){if(this.isEmpty)return;const t=this.encoder.flush();this.onBatch(t),this.prepare()}clean(){this.encoder.reset()}}var h;!function(t){t[t.NotActive=0]="NotActive",t[t.Starting=1]="Starting",t[t.Stopping=2]="Stopping",t[t.Active=3]="Active",t[t.Stopped=4]="Stopped"}(h||(h={}));let r=null,a=null,u=h.NotActive;function o(){a&&a.finaliseBatch()}function c(){return new Promise((t=>{u=h.Stopping,null!==l&&(clearInterval(l),l=null),a&&(a.clean(),a=null),r&&(r.clean(),setTimeout((()=>{r=null}),20)),setTimeout((()=>{u=h.NotActive,t(null)}),100)}))}function g(){u!==h.Stopped&&(postMessage("a_stop"),c().then((()=>{postMessage("a_start")})))}let p,l=null;self.onmessage=({data:s})=>{if(null!=s){if("stop"===s)return o(),void c().then((()=>{u=h.Stopped}));if("forceFlushBatch"!==s){if(!Array.isArray(s)){if("compressed"===s.type){if(!r)return console.debug("OR WebWorker: sender not initialised. Compressed batch."),void g();s.batch&&r.sendCompressed(s.batch)}if("uncompressed"===s.type){if(!r)return console.debug("OR WebWorker: sender not initialised. Uncompressed batch."),void g();s.batch&&r.sendUncompressed(s.batch)}return"start"===s.type?(u=h.Starting,r=new t(s.ingestPoint,(()=>{g()}),(t=>{!function(t){postMessage({type:"failure",reason:t}),c()}(t)}),s.connAttemptCount,s.connAttemptGap,(t=>{postMessage({type:"compress",batch:t},[t.buffer])}),s.pageNo),a=new n(s.pageNo,s.timestamp,s.url,(t=>{r&&r.push(t)}),s.tabId,(()=>postMessage({type:"queue_empty"}))),null===l&&(l=setInterval(o,1e4)),u=h.Active):"auth"===s.type?r?a?(r.authorise(s.token),void(s.beaconSizeLimit&&a.setBeaconSizeLimit(s.beaconSizeLimit))):(console.debug("OR WebWorker: writer not initialised. Received auth."),void g()):(console.debug("OR WebWorker: sender not initialised. Received auth."),void g()):void 0}if(a){const t=a;s.forEach((s=>{55===s[0]&&(s[1]?p=setTimeout((()=>g()),18e5):clearTimeout(p)),t.writeMessage(s)}))}else postMessage("not_init"),g()}else o()}else o()};'], { type: 'text/javascript' })));
            this.worker.onerror = (e) => {
                this._debug('webworker_error', e);
            };
            this.worker.onmessage = ({ data }) => {
                this.handleWorkerMsg(data);
            };
            const alertWorker = () => {
                if (this.worker) {
                    this.worker.postMessage(null);
                }
            };
            // keep better tactics, discard others?
            this.attachEventListener(window, 'beforeunload', alertWorker, false);
            this.attachEventListener(document.body, 'mouseleave', alertWorker, false, false);
            // TODO: stop session after inactivity timeout (make configurable)
            this.attachEventListener(document, 'visibilitychange', alertWorker, false);
        }
        catch (e) {
            this._debug('worker_start', e);
        }
    }
    handleWorkerMsg(data) {
        // handling 401 auth restart (new token assignment)
        if (data === 'a_stop') {
            this.stop(false);
        }
        else if (data === 'a_start') {
            void this.start({}, true);
        }
        else if (data === 'not_init') {
            this.debug.warn('OR WebWorker: writer not initialised. Restarting tracker');
        }
        else if (data.type === 'failure') {
            this.stop(false);
            this.debug.error('worker_failed', data.reason);
            this._debug('worker_failed', data.reason);
        }
        else if (data.type === 'compress') {
            const batch = data.batch;
            const batchSize = batch.byteLength;
            if (batchSize > this.compressionThreshold) {
                gzip(data.batch, { mtime: 0 }, (err, result) => {
                    if (err) {
                        this.debug.error('Openreplay compression error:', err);
                        this.worker?.postMessage({ type: 'uncompressed', batch: batch });
                    }
                    else {
                        this.worker?.postMessage({ type: 'compressed', batch: result });
                    }
                });
            }
            else {
                this.worker?.postMessage({ type: 'uncompressed', batch: batch });
            }
        }
        else if (data.type === 'queue_empty') {
            this.onSessionSent();
        }
    }
    _debug(context, e) {
        if (this.options.__debug_report_edp !== null) {
            void fetch(this.options.__debug_report_edp, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    context,
                    // @ts-ignore
                    error: `${e}`,
                }),
            });
        }
        this.debug.error('OpenReplay error: ', context, e);
    }
    send(message, urgent = false) {
        if (this.activityState === ActivityState.NotActive) {
            return;
        }
        // ====================================================
        if (this.activityState === ActivityState.ColdStart) {
            this.bufferedMessages1.push(message);
            if (!this.singleBuffer) {
                this.bufferedMessages2.push(message);
            }
            this.conditionsManager?.processMessage(message);
        }
        else {
            this.messages.push(message);
        }
        // TODO: commit on start if there were `urgent` sends;
        // Clarify where urgent can be used for;
        // Clarify workflow for each type of message in case it was sent before start
        //      (like Fetch before start; maybe add an option "preCapture: boolean" or sth alike)
        // Careful: `this.delay` is equal to zero before start so all Timestamp-s will have to be updated on start
        if (this.activityState === ActivityState.Active && urgent) {
            this.commit();
        }
    }
    /**
     * Normal workflow: add timestamp and tab data to batch, then commit it
     * every ~30ms
     * */
    _nCommit() {
        if (this.socketMode) {
            this.messages.unshift(TabData(this.session.getTabId()));
            this.messages.unshift(Timestamp(this.timestamp()));
            this.commitCallbacks.forEach((cb) => cb(this.messages));
            this.messages.length = 0;
            return;
        }
        if (this.worker === undefined || !this.messages.length) {
            return;
        }
        if (this.insideIframe) {
            window.parent.postMessage({
                line: proto.iframeBatch,
                messages: this.messages,
                domain: this.initialHostName,
            }, '*');
            this.commitCallbacks.forEach((cb) => cb(this.messages));
            this.messages.length = 0;
            return;
        }
        try {
            requestIdleCb(() => {
                this.messages.unshift(TabData(this.session.getTabId()));
                this.messages.unshift(Timestamp(this.timestamp()));
                // why I need to add opt chaining?
                this.worker?.postMessage(this.messages);
                this.commitCallbacks.forEach((cb) => cb(this.messages));
                this.messages.length = 0;
            });
        }
        catch (e) {
            this._debug('worker_commit', e);
            this.stop(true);
            setTimeout(() => {
                void this.start();
            }, 500);
        }
    }
    /**
     * Cold start: add timestamp and tab data to both batches
     * every 2nd tick, ~60ms
     * this will make batches a bit larger and replay will work with bigger jumps every frame
     * but in turn we don't overload batch writer on session start with 1000 batches
     * */
    _cStartCommit() {
        this.coldStartCommitN += 1;
        if (this.coldStartCommitN === 2) {
            this.bufferedMessages1.push(Timestamp(this.timestamp()));
            this.bufferedMessages1.push(TabData(this.session.getTabId()));
            this.bufferedMessages2.push(Timestamp(this.timestamp()));
            this.bufferedMessages2.push(TabData(this.session.getTabId()));
            this.coldStartCommitN = 0;
        }
    }
    commit() {
        if (this.activityState === ActivityState.ColdStart) {
            this._cStartCommit();
        }
        else {
            this._nCommit();
        }
    }
    postToWorker(messages) {
        this.worker?.postMessage(messages);
        this.commitCallbacks.forEach((cb) => cb(messages));
        messages.length = 0;
    }
    timestamp() {
        return now() + this.delay;
    }
    safe(fn) {
        const app = this;
        return function (...args) {
            try {
                fn.apply(this, args);
            }
            catch (e) {
                app._debug('safe_fn_call', e);
                // time: this.timestamp(),
                // name: e.name,
                // message: e.message,
                // stack: e.stack
            }
        }; // TODO: correct typing
    }
    attachCommitCallback(cb) {
        this.commitCallbacks.push(cb);
    }
    attachStartCallback(cb, useSafe = false) {
        if (useSafe) {
            cb = this.safe(cb);
        }
        this.startCallbacks.push(cb);
    }
    attachStopCallback(cb, useSafe = false) {
        if (useSafe) {
            cb = this.safe(cb);
        }
        this.stopCallbacks.push(cb);
    }
    // Use  app.nodes.attachNodeListener for registered nodes instead
    attachEventListener(target, type, listener, useSafe = true, useCapture = true) {
        if (useSafe) {
            listener = this.safe(listener);
        }
        const createListener = () => target ? createEventListener(target, type, listener, useCapture) : null;
        const deleteListener = () => target ? deleteEventListener(target, type, listener, useCapture) : null;
        this.attachStartCallback(createListener, useSafe);
        this.attachStopCallback(deleteListener, useSafe);
    }
    // TODO: full correct semantic
    checkRequiredVersion(version) {
        const reqVer = version.split(/[.-]/);
        const ver = this.version.split(/[.-]/);
        for (let i = 0; i < 3; i++) {
            if (isNaN(Number(ver[i])) || isNaN(Number(reqVer[i]))) {
                return false;
            }
            if (Number(ver[i]) > Number(reqVer[i])) {
                return true;
            }
            if (Number(ver[i]) < Number(reqVer[i])) {
                return false;
            }
        }
        return true;
    }
    getTrackerInfo() {
        return {
            userUUID: this.localStorage.getItem(this.options.local_uuid_key),
            projectKey: this.projectKey,
            revID: this.revID,
            trackerVersion: this.version,
            isSnippet: this.options.__is_snippet,
        };
    }
    getSessionInfo() {
        return {
            ...this.session.getInfo(),
            ...this.getTrackerInfo(),
        };
    }
    getSessionToken() {
        return this.session.getSessionToken();
    }
    getSessionID() {
        return this.session.getInfo().sessionID || undefined;
    }
    getSessionURL(options) {
        const { projectID, sessionID, timestamp } = this.session.getInfo();
        if (!projectID || !sessionID) {
            this.debug.error('OpenReplay error: Unable to build session URL');
            return undefined;
        }
        const ingest = this.options.ingestPoint;
        const isSaas = /api\.openreplay\.com/.test(ingest);
        const projectPath = isSaas ? 'https://app.openreplay.com/ingest' : ingest;
        const url = projectPath.replace(/ingest$/, `${projectID}/session/${sessionID}`);
        if (options?.withCurrentTime) {
            const jumpTo = now() - timestamp;
            return `${url}?jumpto=${jumpTo}`;
        }
        return url;
    }
    getHost() {
        return new URL(this.options.ingestPoint).host;
    }
    getProjectKey() {
        return this.projectKey;
    }
    getBaseHref() {
        if (typeof this.options.resourceBaseHref === 'string') {
            return this.options.resourceBaseHref;
        }
        else if (typeof this.options.resourceBaseHref === 'object') {
            //TODO: switch between types
        }
        if (document.baseURI) {
            return document.baseURI;
        }
        // IE only
        return (document.head?.getElementsByTagName('base')[0]?.getAttribute('href') ||
            location.origin + location.pathname);
    }
    resolveResourceURL(resourceURL) {
        const base = new URL(this.getBaseHref());
        base.pathname += '/' + new URL(resourceURL).pathname;
        base.pathname.replace(/\/+/g, '/');
        return base.toString();
    }
    isServiceURL(url) {
        return url.startsWith(this.options.ingestPoint);
    }
    active() {
        return this.activityState === ActivityState.Active;
    }
    resetNextPageSession(flag) {
        if (flag) {
            this.sessionStorage.setItem(this.options.session_reset_key, 't');
        }
        else {
            this.sessionStorage.removeItem(this.options.session_reset_key);
        }
    }
    checkSessionToken(forceNew) {
        const lsReset = this.sessionStorage.getItem(this.options.session_reset_key) !== null;
        const needNewSessionID = forceNew || lsReset;
        const sessionToken = this.session.getSessionToken();
        return needNewSessionID || !sessionToken;
    }
    /**
     * start buffering messages without starting the actual session, which gives
     * user 30 seconds to "activate" and record session by calling `start()` on conditional trigger,
     * and we will then send buffered batch, so it won't get lost
     * */
    async coldStart(startOpts = {}, conditional) {
        this.singleBuffer = false;
        const second = 1000;
        const isNewSession = this.checkSessionToken(startOpts.forceNew);
        if (conditional) {
            await this.setupConditionalStart(startOpts);
        }
        const cycle = () => {
            this.orderNumber += 1;
            adjustTimeOrigin();
            this.coldStartTs = now();
            if (this.orderNumber % 2 === 0) {
                this.bufferedMessages1.length = 0;
                this.bufferedMessages1.push(Timestamp(this.timestamp()));
                this.bufferedMessages1.push(TabData(this.session.getTabId()));
            }
            else {
                this.bufferedMessages2.length = 0;
                this.bufferedMessages2.push(Timestamp(this.timestamp()));
                this.bufferedMessages2.push(TabData(this.session.getTabId()));
            }
            this.stop(false);
            this.activityState = ActivityState.ColdStart;
            if (startOpts.sessionHash) {
                this.session.applySessionHash(startOpts.sessionHash);
            }
            if (startOpts.forceNew) {
                this.session.reset();
            }
            this.session.assign({
                userID: startOpts.userID,
                metadata: startOpts.metadata,
            });
            if (!isNewSession) {
                this.debug.log('continuing session on new tab', this.session.getTabId());
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                this.send(TabChange(this.session.getTabId()));
            }
            this.observer.observe();
            this.ticker.start();
        };
        this.coldInterval = setInterval(() => {
            cycle();
        }, 30 * second);
        cycle();
    }
    async setupConditionalStart(startOpts) {
        this.conditionsManager = new ConditionsManager(this, startOpts);
        const r = await fetch(this.options.ingestPoint + '/v1/web/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                ...this.getTrackerInfo(),
                timestamp: now(),
                doNotRecord: true,
                bufferDiff: 0,
                userID: this.session.getInfo().userID,
                token: undefined,
                deviceMemory,
                jsHeapSizeLimit,
                timezone: getTimezone(),
                width: window.innerWidth,
                height: window.innerHeight,
            }),
        });
        const { 
        // this token is needed to fetch conditions and flags,
        // but it can't be used to record a session
        token, userBrowser, userCity, userCountry, userDevice, userOS, userState, projectID, } = await r.json();
        this.session.assign({ projectID });
        this.session.setUserInfo({
            userBrowser,
            userCity,
            userCountry,
            userDevice,
            userOS,
            userState,
        });
        const onStartInfo = { sessionToken: token, userUUID: '', sessionID: '' };
        this.startCallbacks.forEach((cb) => cb(onStartInfo));
        await this.conditionsManager?.fetchConditions(projectID, token);
        await this.featureFlags.reloadFlags(token);
        await this.tagWatcher.fetchTags(this.options.ingestPoint, token);
        this.conditionsManager?.processFlags(this.featureFlags.flags);
    }
    /**
     * Starts offline session recording
     * @param {Object} startOpts - options for session start, same as .start()
     * @param {Function} onSessionSent - callback that will be called once session is fully sent
     * */
    offlineRecording(startOpts = {}, onSessionSent) {
        this.onSessionSent = onSessionSent;
        this.singleBuffer = true;
        const isNewSession = this.checkSessionToken(startOpts.forceNew);
        adjustTimeOrigin();
        this.coldStartTs = now();
        const saverBuffer = this.localStorage.getItem(bufferStorageKey);
        if (saverBuffer) {
            const data = JSON.parse(saverBuffer);
            this.bufferedMessages1 = Array.isArray(data) ? data : this.bufferedMessages1;
            this.localStorage.removeItem(bufferStorageKey);
        }
        this.bufferedMessages1.push(Timestamp(this.timestamp()));
        this.bufferedMessages1.push(TabData(this.session.getTabId()));
        this.activityState = ActivityState.ColdStart;
        if (startOpts.sessionHash) {
            this.session.applySessionHash(startOpts.sessionHash);
        }
        if (startOpts.forceNew) {
            this.session.reset();
        }
        this.session.assign({
            userID: startOpts.userID,
            metadata: startOpts.metadata,
        });
        const onStartInfo = { sessionToken: '', userUUID: '', sessionID: '' };
        this.startCallbacks.forEach((cb) => cb(onStartInfo));
        if (!isNewSession) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            this.send(TabChange(this.session.getTabId()));
        }
        this.observer.observe();
        this.ticker.start();
        return {
            saveBuffer: this.saveBuffer,
            getBuffer: this.getBuffer,
            setBuffer: this.setBuffer,
        };
    }
    /**
     * Saves the captured messages in localStorage (or whatever is used in its place)
     *
     * Then, when this.offlineRecording is called, it will preload this messages and clear the storage item
     *
     * Keeping the size of local storage reasonable is up to the end users of this library
     * */
    saveBuffer() {
        this.localStorage.setItem(bufferStorageKey, JSON.stringify(this.bufferedMessages1));
    }
    /**
     * @returns buffer with stored messages for offline recording
     * */
    getBuffer() {
        return this.bufferedMessages1;
    }
    /**
     * Used to set a buffer with messages array
     * */
    setBuffer(buffer) {
        this.bufferedMessages1 = buffer;
    }
    /**
     * Uploads the stored session buffer to backend
     * @returns promise that resolves once messages are loaded, it has to be awaited
     * so the session can be uploaded properly
     * @resolve - if messages were loaded in service worker successfully
     * @reject {string} - error message
     * */
    async uploadOfflineRecording() {
        this.stop(false);
        const timestamp = now();
        this.worker?.postMessage({
            type: 'start',
            pageNo: this.session.incPageNo(),
            ingestPoint: this.options.ingestPoint,
            timestamp: this.coldStartTs,
            url: document.URL,
            connAttemptCount: this.options.connAttemptCount,
            connAttemptGap: this.options.connAttemptGap,
            tabId: this.session.getTabId(),
        });
        const r = await fetch(this.options.ingestPoint + '/v1/web/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                ...this.getTrackerInfo(),
                timestamp: timestamp,
                doNotRecord: false,
                bufferDiff: timestamp - this.coldStartTs,
                userID: this.session.getInfo().userID,
                token: undefined,
                deviceMemory,
                jsHeapSizeLimit,
                timezone: getTimezone(),
            }),
        });
        const { token, userBrowser, userCity, userCountry, userDevice, userOS, userState, beaconSizeLimit, projectID, } = await r.json();
        this.worker?.postMessage({
            type: 'auth',
            token,
            beaconSizeLimit,
        });
        this.session.assign({ projectID });
        this.session.setUserInfo({
            userBrowser,
            userCity,
            userCountry,
            userDevice,
            userOS,
            userState,
        });
        while (this.bufferedMessages1.length > 0) {
            await this.flushBuffer(this.bufferedMessages1);
        }
        this.postToWorker([['q_end']]);
        this.clearBuffers();
    }
    async _start(startOpts = {}, resetByWorker = false, conditionName) {
        const isColdStart = this.activityState === ActivityState.ColdStart;
        if (isColdStart && this.coldInterval) {
            clearInterval(this.coldInterval);
        }
        if (!this.worker) {
            const reason = 'No worker found: perhaps, CSP is not set.';
            this.signalError(reason, []);
            return Promise.resolve(UnsuccessfulStart(reason));
        }
        if (this.activityState === ActivityState.Active ||
            this.activityState === ActivityState.Starting) {
            const reason = 'OpenReplay: trying to call `start()` on the instance that has been started already.';
            return Promise.resolve(UnsuccessfulStart(reason));
        }
        this.activityState = ActivityState.Starting;
        if (!isColdStart) {
            adjustTimeOrigin();
        }
        if (startOpts.sessionHash) {
            this.session.applySessionHash(startOpts.sessionHash);
        }
        if (startOpts.forceNew) {
            // Reset session metadata only if requested directly
            this.session.reset();
        }
        this.session.assign({
            // MBTODO: maybe it would make sense to `forceNew` if the `userID` was changed
            userID: startOpts.userID,
            metadata: startOpts.metadata,
        });
        const timestamp = now();
        this.worker.postMessage({
            type: 'start',
            pageNo: this.session.incPageNo(),
            ingestPoint: this.options.ingestPoint,
            timestamp: isColdStart ? this.coldStartTs : timestamp,
            url: document.URL,
            connAttemptCount: this.options.connAttemptCount,
            connAttemptGap: this.options.connAttemptGap,
            tabId: this.session.getTabId(),
        });
        const sessionToken = this.session.getSessionToken();
        const isNewSession = this.checkSessionToken(startOpts.forceNew);
        this.sessionStorage.removeItem(this.options.session_reset_key);
        this.debug.log('OpenReplay: starting session; need new session id?', isNewSession, 'session token: ', sessionToken);
        try {
            const r = await window.fetch(this.options.ingestPoint + '/v1/web/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    ...this.getTrackerInfo(),
                    timestamp,
                    doNotRecord: false,
                    bufferDiff: timestamp - this.coldStartTs,
                    userID: this.session.getInfo().userID,
                    token: isNewSession ? undefined : sessionToken,
                    deviceMemory,
                    jsHeapSizeLimit,
                    timezone: getTimezone(),
                    condition: conditionName,
                    assistOnly: startOpts.assistOnly ?? this.socketMode,
                }),
            });
            if (r.status !== 200) {
                const error = await r.text();
                const reason = error === CANCELED ? CANCELED : `Server error: ${r.status}. ${error}`;
                return Promise.reject(reason);
            }
            if (!this.worker) {
                const reason = 'no worker found after start request (this might not happen)';
                this.signalError(reason, []);
                return Promise.reject(reason);
            }
            const { token, userUUID, projectID, beaconSizeLimit, compressionThreshold, // how big the batch should be before we decide to compress it
            delay, //  derived from token
            sessionID, //  derived from token
            startTimestamp, // real startTS (server time), derived from sessionID
            userBrowser, userCity, userCountry, userDevice, userOS, userState, canvasEnabled, canvasQuality, canvasFPS, assistOnly: socketOnly, } = await r.json();
            if (typeof token !== 'string' ||
                typeof userUUID !== 'string' ||
                (typeof startTimestamp !== 'number' && typeof startTimestamp !== 'undefined') ||
                typeof sessionID !== 'string' ||
                typeof delay !== 'number' ||
                (typeof beaconSizeLimit !== 'number' && typeof beaconSizeLimit !== 'undefined')) {
                const reason = `Incorrect server response: ${JSON.stringify(r)}`;
                this.signalError(reason, []);
                return Promise.reject(reason);
            }
            this.delay = delay;
            this.session.setSessionToken(token);
            this.session.setUserInfo({
                userBrowser,
                userCity,
                userCountry,
                userDevice,
                userOS,
                userState,
            });
            this.session.assign({
                sessionID,
                timestamp: startTimestamp || timestamp,
                projectID,
            });
            if (socketOnly) {
                this.socketMode = true;
                this.worker.postMessage('stop');
            }
            else {
                this.worker.postMessage({
                    type: 'auth',
                    token,
                    beaconSizeLimit,
                });
            }
            if (!isNewSession && token === sessionToken) {
                this.debug.log('continuing session on new tab', this.session.getTabId());
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                this.send(TabChange(this.session.getTabId()));
            }
            // (Re)send Metadata for the case of a new session
            Object.entries(this.session.getInfo().metadata).forEach(([key, value]) => this.send(Metadata(key, value)));
            this.localStorage.setItem(this.options.local_uuid_key, userUUID);
            this.compressionThreshold = compressionThreshold;
            const onStartInfo = { sessionToken: token, userUUID, sessionID };
            // TODO: start as early as possible (before receiving the token)
            /** after start */
            this.startCallbacks.forEach((cb) => cb(onStartInfo)); // MBTODO: callbacks after DOM "mounted" (observed)
            void this.featureFlags.reloadFlags();
            await this.tagWatcher.fetchTags(this.options.ingestPoint, token);
            this.activityState = ActivityState.Active;
            if (canvasEnabled && !this.options.canvas.disableCanvas) {
                this.canvasRecorder =
                    this.canvasRecorder ??
                        new CanvasRecorder(this, {
                            fps: canvasFPS,
                            quality: canvasQuality,
                            isDebug: this.options.canvas.__save_canvas_locally,
                            fixedScaling: this.options.canvas.fixedCanvasScaling,
                            useAnimationFrame: this.options.canvas.useAnimationFrame,
                        });
                this.canvasRecorder.startTracking();
            }
            /** --------------- COLD START BUFFER ------------------*/
            if (isColdStart) {
                const biggestBuffer = this.bufferedMessages1.length > this.bufferedMessages2.length
                    ? this.bufferedMessages1
                    : this.bufferedMessages2;
                while (biggestBuffer.length > 0) {
                    await this.flushBuffer(biggestBuffer);
                }
                this.clearBuffers();
                this.commit();
                /** --------------- COLD START BUFFER ------------------*/
            }
            else {
                if (this.insideIframe && this.rootId) {
                    this.observer.crossdomainObserve(this.rootId, this.frameOderNumber);
                }
                else {
                    this.observer.observe();
                }
                this.ticker.start();
            }
            this.uxtManager = this.uxtManager ? this.uxtManager : new UserTestManager(this, uxtStorageKey);
            let uxtId;
            const savedUxtTag = this.localStorage.getItem(uxtStorageKey);
            if (savedUxtTag) {
                uxtId = parseInt(savedUxtTag, 10);
            }
            if (location?.search) {
                const query = new URLSearchParams(location.search);
                if (query.has('oruxt')) {
                    const qId = query.get('oruxt');
                    uxtId = qId ? parseInt(qId, 10) : undefined;
                }
            }
            if (uxtId) {
                if (!this.uxtManager.isActive) {
                    // eslint-disable-next-line
                    this.uxtManager.getTest(uxtId, token, Boolean(savedUxtTag)).then((id) => {
                        if (id) {
                            this.onUxtCb.forEach((cb) => cb(id));
                        }
                    });
                }
                else {
                    // @ts-ignore
                    this.onUxtCb.forEach((cb) => cb(uxtId));
                }
            }
            return SuccessfulStart(onStartInfo);
        }
        catch (reason) {
            this.stop();
            this.session.reset();
            if (reason === CANCELED) {
                this.signalError(CANCELED, []);
                return UnsuccessfulStart(CANCELED);
            }
            this._debug('session_start', reason);
            const errorMessage = reason instanceof Error ? reason.message : reason.toString();
            this.signalError(errorMessage, []);
            return UnsuccessfulStart(errorMessage);
        }
    }
    addOnUxtCb(cb) {
        // @ts-ignore
        this.onUxtCb.push(cb);
    }
    getUxtId() {
        return this.uxtManager?.getTestId();
    }
    async waitStart() {
        return new Promise((resolve) => {
            const check = () => {
                if (this.canStart) {
                    resolve(true);
                }
                else {
                    setTimeout(check, 25);
                }
            };
            check();
        });
    }
    async waitStarted() {
        return new Promise((resolve) => {
            const check = () => {
                if (this.activityState === ActivityState.Active) {
                    resolve(true);
                }
                else {
                    setTimeout(check, 25);
                }
            };
            check();
        });
    }
    /**
     * basically we ask other tabs during constructor
     * and here we just apply 10ms delay just in case
     * */
    async start(...args) {
        if (this.activityState === ActivityState.Active ||
            this.activityState === ActivityState.Starting) {
            const reason = 'OpenReplay: trying to call `start()` on the instance that has been started already.';
            return Promise.resolve(UnsuccessfulStart(reason));
        }
        if (!document.hidden) {
            await this.waitStart();
            return this._start(...args);
        }
        else {
            return new Promise((resolve) => {
                const onVisibilityChange = async () => {
                    if (!document.hidden) {
                        await this.waitStart();
                        // eslint-disable-next-line
                        document.removeEventListener('visibilitychange', onVisibilityChange);
                        resolve(this._start(...args));
                    }
                };
                // eslint-disable-next-line
                document.addEventListener('visibilitychange', onVisibilityChange);
            });
        }
    }
    forceFlushBatch() {
        this.worker?.postMessage('forceFlushBatch');
    }
    getTabId() {
        return this.session.getTabId();
    }
    clearBuffers() {
        this.bufferedMessages1.length = 0;
        this.bufferedMessages2.length = 0;
    }
    /**
     * Creates a named hook that expects event name, data string and msg direction (up/down),
     * it will skip any message bigger than 5 mb or event name bigger than 255 symbols
     * @returns {(msgType: string, data: string, dir: "up" | "down") => void}
     * */
    trackWs(channelName) {
        const channel = channelName;
        return (msgType, data, dir = 'down') => {
            if (typeof msgType !== 'string' ||
                typeof data !== 'string' ||
                data.length > 5 * 1024 * 1024 ||
                msgType.length > 255) {
                return;
            }
            this.send(WSChannel('websocket', channel, data, this.timestamp(), dir, msgType));
        };
    }
    stop(stopWorker = true) {
        if (this.activityState !== ActivityState.NotActive) {
            try {
                this.attributeSender.clear();
                this.sanitizer.clear();
                this.observer.disconnect();
                this.nodes.clear();
                this.ticker.stop();
                this.stopCallbacks.forEach((cb) => cb());
                this.debug.log('OpenReplay tracking stopped.');
                this.tagWatcher.clear();
                if (this.worker && stopWorker) {
                    this.worker.postMessage('stop');
                }
                this.canvasRecorder?.clear();
            }
            finally {
                this.activityState = ActivityState.NotActive;
            }
        }
    }
}
