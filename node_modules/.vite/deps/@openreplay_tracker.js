import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/.pnpm/stackframe@1.3.4/node_modules/stackframe/stackframe.js
var require_stackframe = __commonJS({
  "node_modules/.pnpm/stackframe@1.3.4/node_modules/stackframe/stackframe.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define("stackframe", [], factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.StackFrame = factory();
      }
    })(exports, function() {
      "use strict";
      function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }
      function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
      }
      function _getter(p) {
        return function() {
          return this[p];
        };
      }
      var booleanProps = ["isConstructor", "isEval", "isNative", "isToplevel"];
      var numericProps = ["columnNumber", "lineNumber"];
      var stringProps = ["fileName", "functionName", "source"];
      var arrayProps = ["args"];
      var objectProps = ["evalOrigin"];
      var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);
      function StackFrame(obj) {
        if (!obj) return;
        for (var i2 = 0; i2 < props.length; i2++) {
          if (obj[props[i2]] !== void 0) {
            this["set" + _capitalize(props[i2])](obj[props[i2]]);
          }
        }
      }
      StackFrame.prototype = {
        getArgs: function() {
          return this.args;
        },
        setArgs: function(v) {
          if (Object.prototype.toString.call(v) !== "[object Array]") {
            throw new TypeError("Args must be an Array");
          }
          this.args = v;
        },
        getEvalOrigin: function() {
          return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
          if (v instanceof StackFrame) {
            this.evalOrigin = v;
          } else if (v instanceof Object) {
            this.evalOrigin = new StackFrame(v);
          } else {
            throw new TypeError("Eval Origin must be an Object or StackFrame");
          }
        },
        toString: function() {
          var fileName = this.getFileName() || "";
          var lineNumber = this.getLineNumber() || "";
          var columnNumber = this.getColumnNumber() || "";
          var functionName = this.getFunctionName() || "";
          if (this.getIsEval()) {
            if (fileName) {
              return "[eval] (" + fileName + ":" + lineNumber + ":" + columnNumber + ")";
            }
            return "[eval]:" + lineNumber + ":" + columnNumber;
          }
          if (functionName) {
            return functionName + " (" + fileName + ":" + lineNumber + ":" + columnNumber + ")";
          }
          return fileName + ":" + lineNumber + ":" + columnNumber;
        }
      };
      StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf("(");
        var argsEndIndex = str.lastIndexOf(")");
        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(",");
        var locationString = str.substring(argsEndIndex + 1);
        if (locationString.indexOf("@") === 0) {
          var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, "");
          var fileName = parts[1];
          var lineNumber = parts[2];
          var columnNumber = parts[3];
        }
        return new StackFrame({
          functionName,
          args: args || void 0,
          fileName,
          lineNumber: lineNumber || void 0,
          columnNumber: columnNumber || void 0
        });
      };
      for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype["get" + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype["set" + _capitalize(booleanProps[i])] = /* @__PURE__ */ function(p) {
          return function(v) {
            this[p] = Boolean(v);
          };
        }(booleanProps[i]);
      }
      for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype["get" + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype["set" + _capitalize(numericProps[j])] = /* @__PURE__ */ function(p) {
          return function(v) {
            if (!_isNumber(v)) {
              throw new TypeError(p + " must be a Number");
            }
            this[p] = Number(v);
          };
        }(numericProps[j]);
      }
      for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype["get" + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype["set" + _capitalize(stringProps[k])] = /* @__PURE__ */ function(p) {
          return function(v) {
            this[p] = String(v);
          };
        }(stringProps[k]);
      }
      return StackFrame;
    });
  }
});

// node_modules/.pnpm/error-stack-parser@2.1.4/node_modules/error-stack-parser/error-stack-parser.js
var require_error_stack_parser = __commonJS({
  "node_modules/.pnpm/error-stack-parser@2.1.4/node_modules/error-stack-parser/error-stack-parser.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define("error-stack-parser", ["stackframe"], factory);
      } else if (typeof exports === "object") {
        module.exports = factory(require_stackframe());
      } else {
        root.ErrorStackParser = factory(root.StackFrame);
      }
    })(exports, function ErrorStackParser2(StackFrame) {
      "use strict";
      var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
      var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
      var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
      return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
          if (typeof error.stacktrace !== "undefined" || typeof error["opera#sourceloc"] !== "undefined") {
            return this.parseOpera(error);
          } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
            return this.parseV8OrIE(error);
          } else if (error.stack) {
            return this.parseFFOrSafari(error);
          } else {
            throw new Error("Cannot parse given Error object");
          }
        },
        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
          if (urlLike.indexOf(":") === -1) {
            return [urlLike];
          }
          var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
          var parts = regExp.exec(urlLike.replace(/[()]/g, ""));
          return [parts[1], parts[2] || void 0, parts[3] || void 0];
        },
        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
          var filtered = error.stack.split("\n").filter(function(line) {
            return !!line.match(CHROME_IE_STACK_REGEXP);
          }, this);
          return filtered.map(function(line) {
            if (line.indexOf("(eval ") > -1) {
              line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
            }
            var sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
            var location2 = sanitizedLine.match(/ (\(.+\)$)/);
            sanitizedLine = location2 ? sanitizedLine.replace(location2[0], "") : sanitizedLine;
            var locationParts = this.extractLocation(location2 ? location2[1] : sanitizedLine);
            var functionName = location2 && sanitizedLine || void 0;
            var fileName = ["eval", "<anonymous>"].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0];
            return new StackFrame({
              functionName,
              fileName,
              lineNumber: locationParts[1],
              columnNumber: locationParts[2],
              source: line
            });
          }, this);
        },
        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
          var filtered = error.stack.split("\n").filter(function(line) {
            return !line.match(SAFARI_NATIVE_CODE_REGEXP);
          }, this);
          return filtered.map(function(line) {
            if (line.indexOf(" > eval") > -1) {
              line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
            }
            if (line.indexOf("@") === -1 && line.indexOf(":") === -1) {
              return new StackFrame({
                functionName: line
              });
            } else {
              var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
              var matches = line.match(functionNameRegex);
              var functionName = matches && matches[1] ? matches[1] : void 0;
              var locationParts = this.extractLocation(line.replace(functionNameRegex, ""));
              return new StackFrame({
                functionName,
                fileName: locationParts[0],
                lineNumber: locationParts[1],
                columnNumber: locationParts[2],
                source: line
              });
            }
          }, this);
        },
        parseOpera: function ErrorStackParser$$parseOpera(e) {
          if (!e.stacktrace || e.message.indexOf("\n") > -1 && e.message.split("\n").length > e.stacktrace.split("\n").length) {
            return this.parseOpera9(e);
          } else if (!e.stack) {
            return this.parseOpera10(e);
          } else {
            return this.parseOpera11(e);
          }
        },
        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
          var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
          var lines = e.message.split("\n");
          var result = [];
          for (var i = 2, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
              result.push(new StackFrame({
                fileName: match[2],
                lineNumber: match[1],
                source: lines[i]
              }));
            }
          }
          return result;
        },
        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
          var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
          var lines = e.stacktrace.split("\n");
          var result = [];
          for (var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
              result.push(
                new StackFrame({
                  functionName: match[3] || void 0,
                  fileName: match[2],
                  lineNumber: match[1],
                  source: lines[i]
                })
              );
            }
          }
          return result;
        },
        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
          var filtered = error.stack.split("\n").filter(function(line) {
            return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
          }, this);
          return filtered.map(function(line) {
            var tokens = line.split("@");
            var locationParts = this.extractLocation(tokens.pop());
            var functionCall = tokens.shift() || "";
            var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
            var argsRaw;
            if (functionCall.match(/\(([^)]*)\)/)) {
              argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
            }
            var args = argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(",");
            return new StackFrame({
              functionName,
              args,
              fileName: locationParts[0],
              lineNumber: locationParts[1],
              columnNumber: locationParts[2],
              source: line
            });
          }, this);
        }
      };
    });
  }
});

// node_modules/.pnpm/fflate@0.8.2/node_modules/fflate/esm/browser.js
var ch2 = {};
var wk = function(c, id2, msg, transfer, cb) {
  var w = new Worker(ch2[id2] || (ch2[id2] = URL.createObjectURL(new Blob([
    c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
  ], { type: "text/javascript" }))));
  w.onmessage = function(e) {
    var d = e.data, ed = d.$e$;
    if (ed) {
      var err2 = new Error(ed[0]);
      err2["code"] = ed[1];
      err2.stack = ed[2];
      cb(err2, null);
    } else
      cb(null, d);
  };
  w.postMessage(msg, transfer);
  return w;
};
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start2) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start2 += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max = function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var wbits = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
};
var wbits16 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
  d[o + 2] |= v >> 16;
};
var hTree = function(d, mb) {
  var t = [];
  for (var i = 0; i < d.length; ++i) {
    if (d[i])
      t.push({ s: i, f: d[i] });
  }
  var s = t.length;
  var t2 = t.slice();
  if (!s)
    return { t: et, l: 0 };
  if (s == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return { t: v, l: 1 };
  }
  t.sort(function(a, b) {
    return a.f - b.f;
  });
  t.push({ s: -1, f: 25001 });
  var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
  t[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t[t[i0].f < t[i2].f ? i0++ : i2++];
    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
    t[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t2[0].s;
  for (var i = 1; i < s; ++i) {
    if (t2[i].s > maxSym)
      maxSym = t2[i].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t2.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (; i < s; ++i) {
      var i2_1 = t2[i].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>= lft;
    while (dt > 0) {
      var i2_2 = t2[i].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i;
    }
    for (; i >= 0 && dt; --i) {
      var i2_3 = t2[i].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function(c) {
  var s = c.length;
  while (s && !c[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i = 1; i <= s; ++i) {
    if (c[i] == cln && i != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c[i];
    }
  }
  return { c: cl.subarray(0, cli), n: s };
};
var clen = function(cf, cl) {
  var l = 0;
  for (var i = 0; i < cl.length; ++i)
    l += cf[i] * cl[i];
  return l;
};
var wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i = 0; i < s; ++i)
    out[o + i + 4] = dat[i];
  return (o + 4 + s) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a3 = hTree(lf, 15), dlt = _a3.t, mlb = _a3.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i = 0; i < lclt.length; ++i)
    ++lcfreq[lclt[i] & 31];
  for (var i = 0; i < lcdt.length; ++i)
    ++lcfreq[lcdt[i] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i = 0; i < nlcc; ++i)
      wbits(out, p + 3 * i, lct[clim[i]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i = 0; i < li; ++i) {
    var sym = syms[i];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, sym >> 23 & 31), p += fleb[len];
      var dst = sym & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[sym]), p += ll[sym];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st) {
  var s = st.z || dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
  var w = o.subarray(pre, o.length - post);
  var lst = st.l;
  var pos = (st.r || 0) & 7;
  if (lvl) {
    if (pos)
      w[0] = st.r >> 3;
    var opt = deo[lvl - 1];
    var n = opt >> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i2) {
      return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
    for (; i + 2 < s; ++i) {
      var hv = hsh(i);
      var imod = i & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i) {
        var rem = s - i;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;
          for (var j = 0; j < 286; ++j)
            lf[j] = 0;
          for (var j = 0; j < 30; ++j)
            df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l] == dat[i + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i - dif + j & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }
    for (i = Math.max(i, wi); i < s; ++i) {
      syms[li++] = dat[i];
      ++lf[dat[i]];
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
    if (!lst) {
      st.r = pos & 7 | w[pos / 8 | 0] << 3;
      pos -= 7;
      st.h = head, st.p = prev, st.i = i, st.w = wi;
    }
  } else {
    for (var i = st.w || 0; i < s + lst; i += 65535) {
      var e = i + 65535;
      if (e >= s) {
        w[pos / 8 | 0] = lst;
        e = s;
      }
      pos = wfblk(w, pos + 1, dat.subarray(i, e));
    }
    st.i = s;
  }
  return slc(o, 0, pre + shft(pos) + post);
};
var crct = function() {
  var t = new Int32Array(256);
  for (var i = 0; i < 256; ++i) {
    var c = i, k = 9;
    while (--k)
      c = (c & 1 && -306674912) ^ c >>> 1;
    t[i] = c;
  }
  return t;
}();
var crc = function() {
  var c = -1;
  return {
    p: function(d) {
      var cr = c;
      for (var i = 0; i < d.length; ++i)
        cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
      c = cr;
    },
    d: function() {
      return ~c;
    }
  };
};
var adler = function() {
  var a = 1, b = 0;
  return {
    p: function(d) {
      var n = a, m = b;
      var l = d.length | 0;
      for (var i = 0; i != l; ) {
        var e = Math.min(i + 2655, l);
        for (; i < e; ++i)
          m += n += d[i];
        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }
      a = n, b = m;
    },
    d: function() {
      a %= 65521, b %= 65521;
      return (a & 255) << 24 | (a & 65280) << 8 | (b & 255) << 8 | b >> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post, st) {
  if (!st) {
    st = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
};
var mrg = function(a, b) {
  var o = {};
  for (var k in a)
    o[k] = a[k];
  for (var k in b)
    o[k] = b[k];
  return o;
};
var wcln = function(fn, fnStr, td2) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
  for (var i = 0; i < dt.length; ++i) {
    var v = dt[i], k = ks[i];
    if (typeof v == "function") {
      fnStr += ";" + k + "=";
      var st_1 = v.toString();
      if (v.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t in v.prototype)
            fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k] = v;
  }
  return fnStr;
};
var ch = [];
var cbfs = function(v) {
  var tl = [];
  for (var k in v) {
    if (v[k].buffer) {
      tl.push((v[k] = new v[k].constructor(v[k])).buffer);
    }
  }
  return tl;
};
var wrkr = function(fns, init, id2, cb) {
  if (!ch[id2]) {
    var fnStr = "", td_1 = {}, m = fns.length - 1;
    for (var i = 0; i < m; ++i)
      fnStr = wcln(fns[i], fnStr, td_1);
    ch[id2] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
  }
  var td2 = mrg({}, ch[id2].e);
  return wk(ch[id2].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id2, td2, cbfs(td2), cb);
};
var bInflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
};
var bDflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
};
var gze = function() {
  return [gzh, gzhl, wbytes, crc, crct];
};
var guze = function() {
  return [gzs, gzl];
};
var zule = function() {
  return [zls];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gopt = function(o) {
  return o && {
    out: o.size && new u8(o.size),
    dictionary: o.dictionary
  };
};
var cbify = function(dat, opts, fns, init, id2, cb) {
  var w = wrkr(fns, init, id2, function(err2, dat2) {
    w.terminate();
    cb(err2, dat2);
  });
  w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
  return function() {
    w.terminate();
  };
};
var astrm = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    if (ev.data.length) {
      strm.push(ev.data[0], ev.data[1]);
      postMessage([ev.data[0].length]);
    } else
      strm.flush();
  };
};
var astrmify = function(fns, strm, opts, init, id2, flush, ext) {
  var t;
  var w = wrkr(fns, init, id2, function(err2, dat) {
    if (err2)
      w.terminate(), strm.ondata.call(strm, err2);
    else if (!Array.isArray(dat))
      ext(dat);
    else if (dat.length == 1) {
      strm.queuedSize -= dat[0];
      if (strm.ondrain)
        strm.ondrain(dat[0]);
    } else {
      if (dat[1])
        w.terminate();
      strm.ondata.call(strm, err2, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);
  strm.queuedSize = 0;
  strm.push = function(d, f) {
    if (!strm.ondata)
      err(5);
    if (t)
      strm.ondata(err(4, 0, 1), null, !!f);
    strm.queuedSize += d.length;
    w.postMessage([d, t = f], [d.buffer]);
  };
  strm.terminate = function() {
    w.terminate();
  };
  if (flush) {
    strm.flush = function() {
      w.postMessage([]);
    };
  }
};
var b2 = function(d, b) {
  return d[b] | d[b + 1] << 8;
};
var b4 = function(d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
};
var wbytes = function(d, b, v) {
  for (; v; ++b)
    d[b] = v, v >>>= 8;
};
var gzh = function(c, o) {
  var fn = o.filename;
  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
  if (o.mtime != 0)
    wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
  if (fn) {
    c[3] = 8;
    for (var i = 0; i <= fn.length; ++i)
      c[i + 10] = fn.charCodeAt(i);
  }
};
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var gzhl = function(o) {
  return 10 + (o.filename ? o.filename.length + 1 : 0);
};
var zlh = function(c, o) {
  var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c[0] = 120, c[1] = fl2 << 6 | (o.dictionary && 32);
  c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
  if (o.dictionary) {
    var h = adler();
    h.p(o.dictionary);
    wbytes(c, 2, h.d());
  }
};
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
function StrmOpt(opts, cb) {
  if (typeof opts == "function")
    cb = opts, opts = {};
  this.ondata = cb;
  return opts;
}
var Deflate = function() {
  function Deflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    this.o = opts || {};
    this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
    this.b = new u8(98304);
    if (this.o.dictionary) {
      var dict = this.o.dictionary.subarray(-32768);
      this.b.set(dict, 32768 - dict.length);
      this.s.i = 32768 - dict.length;
    }
  }
  Deflate2.prototype.p = function(c, f) {
    this.ondata(dopt(c, this.o, 0, 0, this.s), f);
  };
  Deflate2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    var endLen = chunk.length + this.s.z;
    if (endLen > this.b.length) {
      if (endLen > 2 * this.b.length - 32768) {
        var newBuf = new u8(endLen & -32768);
        newBuf.set(this.b.subarray(0, this.s.z));
        this.b = newBuf;
      }
      var split = this.b.length - this.s.z;
      this.b.set(chunk.subarray(0, split), this.s.z);
      this.s.z = this.b.length;
      this.p(this.b, false);
      this.b.set(this.b.subarray(-32768));
      this.b.set(chunk.subarray(split), 32768);
      this.s.z = chunk.length - split + 32768;
      this.s.i = 32766, this.s.w = 32768;
    } else {
      this.b.set(chunk, this.s.z);
      this.s.z += chunk.length;
    }
    this.s.l = final & 1;
    if (this.s.z > this.s.w + 8191 || final) {
      this.p(this.b, final || false);
      this.s.w = this.s.i, this.s.i -= 2;
    }
  };
  Deflate2.prototype.flush = function() {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    this.p(this.b, false);
    this.s.w = this.s.i, this.s.i -= 2;
  };
  return Deflate2;
}();
var AsyncDeflate = /* @__PURE__ */ function() {
  function AsyncDeflate2(opts, cb) {
    astrmify([
      bDflt,
      function() {
        return [astrm, Deflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6, 1);
  }
  return AsyncDeflate2;
}();
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var Inflate = function() {
  function Inflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
    this.s = { i: 0, b: dict ? dict.length : 0 };
    this.o = new u8(32768);
    this.p = new u8(0);
    if (dict)
      this.o.set(dict);
  }
  Inflate2.prototype.e = function(c) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    if (!this.p.length)
      this.p = c;
    else if (c.length) {
      var n = new u8(this.p.length + c.length);
      n.set(this.p), n.set(c, this.p.length), this.p = n;
    }
  };
  Inflate2.prototype.c = function(final) {
    this.s.i = +(this.d = final || false);
    var bts = this.s.b;
    var dt = inflt(this.p, this.s, this.o);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate2;
}();
var AsyncInflate = /* @__PURE__ */ function() {
  function AsyncInflate2(opts, cb) {
    astrmify([
      bInflt,
      function() {
        return [astrm, Inflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Inflate(ev.data);
      onmessage = astrm(strm);
    }, 7, 0);
  }
  return AsyncInflate2;
}();
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Gzip = function() {
  function Gzip2(opts, cb) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Gzip2.prototype.push = function(chunk, final) {
    this.c.p(chunk);
    this.l += chunk.length;
    Deflate.prototype.push.call(this, chunk, final);
  };
  Gzip2.prototype.p = function(c, f) {
    var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);
    if (this.v)
      gzh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f);
  };
  Gzip2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Gzip2;
}();
function gzip(data, opts, cb) {
  if (!cb)
    cb = opts, opts = {};
  if (typeof cb != "function")
    err(7);
  return cbify(data, opts, [
    bDflt,
    gze,
    function() {
      return [gzipSync];
    }
  ], function(ev) {
    return pbf(gzipSync(ev.data[0], ev.data[1]));
  }, 2, cb);
}
function gzipSync(data, opts) {
  if (!opts)
    opts = {};
  var c = crc(), l = data.length;
  c.p(data);
  var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
  return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
var Gunzip = function() {
  function Gunzip2(opts, cb) {
    this.v = 1;
    this.r = 0;
    Inflate.call(this, opts, cb);
  }
  Gunzip2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    this.r += chunk.length;
    if (this.v) {
      var p = this.p.subarray(this.v - 1);
      var s = p.length > 3 ? gzs(p) : 4;
      if (s > p.length) {
        if (!final)
          return;
      } else if (this.v > 1 && this.onmember) {
        this.onmember(this.r - p.length);
      }
      this.p = p.subarray(s), this.v = 0;
    }
    Inflate.prototype.c.call(this, final);
    if (this.s.f && !this.s.l && !final) {
      this.v = shft(this.s.p) + 9;
      this.s = { i: 0 };
      this.o = new u8(0);
      this.push(new u8(0), final);
    }
  };
  return Gunzip2;
}();
var AsyncGunzip = /* @__PURE__ */ function() {
  function AsyncGunzip2(opts, cb) {
    var _this = this;
    astrmify([
      bInflt,
      guze,
      function() {
        return [astrm, Inflate, Gunzip];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Gunzip(ev.data);
      strm.onmember = function(offset) {
        return postMessage(offset);
      };
      onmessage = astrm(strm);
    }, 9, 0, function(offset) {
      return _this.onmember && _this.onmember(offset);
    });
  }
  return AsyncGunzip2;
}();
var Zlib = function() {
  function Zlib2(opts, cb) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Zlib2.prototype.push = function(chunk, final) {
    this.c.p(chunk);
    Deflate.prototype.push.call(this, chunk, final);
  };
  Zlib2.prototype.p = function(c, f) {
    var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);
    if (this.v)
      zlh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f);
  };
  Zlib2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Zlib2;
}();
var Unzlib = function() {
  function Unzlib2(opts, cb) {
    Inflate.call(this, opts, cb);
    this.v = opts && opts.dictionary ? 2 : 1;
  }
  Unzlib2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      if (this.p.length < 6 && !final)
        return;
      this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        err(6, "invalid zlib data");
      this.p = this.p.subarray(0, -4);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Unzlib2;
}();
var AsyncUnzlib = /* @__PURE__ */ function() {
  function AsyncUnzlib2(opts, cb) {
    astrmify([
      bInflt,
      zule,
      function() {
        return [astrm, Inflate, Unzlib];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Unzlib(ev.data);
      onmessage = astrm(strm);
    }, 11, 0);
  }
  return AsyncUnzlib2;
}();
var Decompress = function() {
  function Decompress2(opts, cb) {
    this.o = StrmOpt.call(this, opts, cb) || {};
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
  }
  Decompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(dat, final) {
      _this.ondata(dat, final);
    };
  };
  Decompress2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (!this.s) {
      if (this.p && this.p.length) {
        var n = new u8(this.p.length + chunk.length);
        n.set(this.p), n.set(chunk, this.p.length);
      } else
        this.p = chunk;
      if (this.p.length > 2) {
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
        this.i();
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk, final);
  };
  return Decompress2;
}();
var AsyncDecompress = function() {
  function AsyncDecompress2(opts, cb) {
    Decompress.call(this, opts, cb);
    this.queuedSize = 0;
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
  }
  AsyncDecompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    };
    this.s.ondrain = function(size) {
      _this.queuedSize -= size;
      if (_this.ondrain)
        _this.ondrain(size);
    };
  };
  AsyncDecompress2.prototype.push = function(chunk, final) {
    this.queuedSize += chunk.length;
    Decompress.prototype.push.call(this, chunk, final);
  };
  return AsyncDecompress2;
}();
var te = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var dutf8 = function(d) {
  for (var r = "", i = 0; ; ) {
    var c = d[i++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i + eb > d.length)
      return { s: r, r: slc(d, i - 1) };
    if (!eb)
      r += String.fromCharCode(c);
    else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
    else
      r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
  }
};
var DecodeUTF8 = function() {
  function DecodeUTF82(cb) {
    this.ondata = cb;
    if (tds)
      this.t = new TextDecoder();
    else
      this.p = et;
  }
  DecodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          err(8);
        this.t = null;
      }
      return;
    }
    if (!this.p)
      err(4);
    var dat = new u8(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);
    var _a3 = dutf8(dat), s = _a3.s, r = _a3.r;
    if (final) {
      if (r.length)
        err(8);
      this.p = null;
    } else
      this.p = r;
    this.ondata(s, final);
  };
  return DecodeUTF82;
}();
var EncodeUTF8 = function() {
  function EncodeUTF82(cb) {
    this.ondata = cb;
  }
  EncodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    this.ondata(strToU8(chunk), this.d = final || false);
  };
  return EncodeUTF82;
}();
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i = 0; i < str.length; ++i)
      ar_1[i] = str.charCodeAt(i);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }
    var c = str.charCodeAt(i);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i = 0; i < dat.length; i += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    return r;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a3 = dutf8(dat), s = _a3.s, r = _a3.r;
    if (r.length)
      err(8);
    return s;
  }
}
var dbf = function(l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
var z64e = function(d, b) {
  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
    ;
  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        err(9);
      le += l + 4;
    }
  }
  return le;
};
var wzh = function(d, b, f, fn, u, c, ce, co) {
  var fl2 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
  if (ce != null)
    d[b++] = 20, d[b++] = f.os;
  d[b] = 20, b += 2;
  d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    err(10);
  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
  if (c != -1) {
    wbytes(d, b, f.crc);
    wbytes(d, b + 4, c < 0 ? -c - 2 : c);
    wbytes(d, b + 8, f.size);
  }
  wbytes(d, b + 12, fl2);
  wbytes(d, b + 14, exl), b += 16;
  if (ce != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f.attrs);
    wbytes(d, b + 10, ce), b += 14;
  }
  d.set(fn, b);
  b += fl2;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }
  if (col)
    d.set(co, b), b += col;
  return b;
};
var wzf = function(o, b, c, d, e) {
  wbytes(o, b, 101010256);
  wbytes(o, b + 8, c);
  wbytes(o, b + 10, c);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
var ZipPassThrough = function() {
  function ZipPassThrough2(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough2.prototype.process = function(chunk, final) {
    this.ondata(null, chunk, final);
  };
  ZipPassThrough2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    this.c.p(chunk);
    this.size += chunk.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk, final || false);
  };
  return ZipPassThrough2;
}();
var ZipDeflate = function() {
  function ZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function(dat, final) {
      _this.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }
  ZipDeflate2.prototype.process = function(chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  ZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return ZipDeflate2;
}();
var AsyncZipDeflate = function() {
  function AsyncZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate2.prototype.process = function(chunk, final) {
    this.d.push(chunk, final);
  };
  AsyncZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return AsyncZipDeflate2;
}();
var Zip = function() {
  function Zip2(cb) {
    this.ondata = cb;
    this.u = [];
    this.d = 1;
  }
  Zip2.prototype.add = function(file) {
    var _this = this;
    if (!this.ondata)
      err(5);
    if (this.d & 2)
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
    else {
      var f = strToU8(file.filename), fl_1 = f.length;
      var com = file.comment, o = com && strToU8(com);
      var u = fl_1 != file.filename.length || o && com.length != o.length;
      var hl_1 = fl_1 + exfl(file.extra) + 30;
      if (fl_1 > 65535)
        this.ondata(err(11, 0, 1), null, false);
      var header = new u8(hl_1);
      wzh(header, 0, file, f, u, -1);
      var chks_1 = [header];
      var pAll_1 = function() {
        for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
          var chk = chks_2[_i];
          _this.ondata(null, chk, false);
        }
        chks_1 = [];
      };
      var tr_1 = this.d;
      this.d = 0;
      var ind_1 = this.u.length;
      var uf_1 = mrg(file, {
        f,
        u,
        o,
        t: function() {
          if (file.terminate)
            file.terminate();
        },
        r: function() {
          pAll_1();
          if (tr_1) {
            var nxt = _this.u[ind_1 + 1];
            if (nxt)
              nxt.r();
            else
              _this.d = 1;
          }
          tr_1 = 1;
        }
      });
      var cl_1 = 0;
      file.ondata = function(err2, dat, final) {
        if (err2) {
          _this.ondata(err2, dat, final);
          _this.terminate();
        } else {
          cl_1 += dat.length;
          chks_1.push(dat);
          if (final) {
            var dd = new u8(16);
            wbytes(dd, 0, 134695760);
            wbytes(dd, 4, file.crc);
            wbytes(dd, 8, cl_1);
            wbytes(dd, 12, file.size);
            chks_1.push(dd);
            uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
            if (tr_1)
              uf_1.r();
            tr_1 = 1;
          } else if (tr_1)
            pAll_1();
        }
      };
      this.u.push(uf_1);
    }
  };
  Zip2.prototype.end = function() {
    var _this = this;
    if (this.d & 2) {
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
      return;
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this.d & 1))
            return;
          _this.u.splice(-1, 1);
          _this.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip2.prototype.e = function() {
    var bt = 0, l = 0, tl = 0;
    for (var _i = 0, _a3 = this.u; _i < _a3.length; _i++) {
      var f = _a3[_i];
      tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
    }
    var out = new u8(tl + 22);
    for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
      var f = _c[_b2];
      wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);
      bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
    }
    wzf(out, bt, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip2.prototype.terminate = function() {
    for (var _i = 0, _a3 = this.u; _i < _a3.length; _i++) {
      var f = _a3[_i];
      f.t();
    }
    this.d = 2;
  };
  return Zip2;
}();
var UnzipPassThrough = function() {
  function UnzipPassThrough2() {
  }
  UnzipPassThrough2.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough2.compression = 0;
  return UnzipPassThrough2;
}();
var UnzipInflate = function() {
  function UnzipInflate2() {
    var _this = this;
    this.i = new Inflate(function(dat, final) {
      _this.ondata(null, dat, final);
    });
  }
  UnzipInflate2.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  UnzipInflate2.compression = 8;
  return UnzipInflate2;
}();
var AsyncUnzipInflate = function() {
  function AsyncUnzipInflate2(_, sz) {
    var _this = this;
    if (sz < 32e4) {
      this.i = new Inflate(function(dat, final) {
        _this.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function(err2, dat, final) {
        _this.ondata(err2, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate2.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate2.compression = 8;
  return AsyncUnzipInflate2;
}();
var Unzip = function() {
  function Unzip2(cb) {
    this.onfile = cb;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  Unzip2.prototype.push = function(chunk, final) {
    var _this = this;
    if (!this.onfile)
      err(5);
    if (!this.p)
      err(4);
    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length)
        return this.push(chunk, final);
    } else {
      var f = 0, i = 0, is = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk;
      else if (!chunk.length)
        buf = this.p;
      else {
        buf = new u8(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l = buf.length, oc = this.c, add = oc && this.d;
      var _loop_2 = function() {
        var _a3;
        var sig = b4(buf, i);
        if (sig == 67324752) {
          f = 1, is = i;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
          if (l > i + 30 + fnl + es) {
            var chks_3 = [];
            this_1.k.unshift(chks_3);
            f = 2;
            var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
            var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
            if (sc_1 == 4294967295) {
              _a3 = dd ? [-2] : z64e(buf, i), sc_1 = _a3[0], su_1 = _a3[1];
            } else if (dd)
              sc_1 = -1;
            i += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  err(5);
                if (!sc_1)
                  file_1.ondata(null, et, true);
                else {
                  var ctr = _this.o[cmp_1];
                  if (!ctr)
                    file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                  d_1.ondata = function(err2, dat3, final2) {
                    file_1.ondata(err2, dat3, final2);
                  };
                  for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                    var dat2 = chks_4[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this.k[0] == chks_3 && _this.c)
                    _this.d = d_1;
                  else
                    d_1.push(et, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is = i -= 4, f = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i < l - 4; ++i) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et;
      if (oc < 0) {
        var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i);
        if (add)
          add.push(dat, !!f);
        else
          this.k[+(f == 2)].push(dat);
      }
      if (f & 2)
        return this.push(buf.subarray(i), final);
      this.p = buf.subarray(i);
    }
    if (final) {
      if (this.c)
        err(13);
      this.p = null;
    }
  };
  Unzip2.prototype.register = function(decoder) {
    this.o[decoder.compression] = decoder;
  };
  return Unzip2;
}();

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/attributeSender.js
var StringDictionary = class {
  constructor() {
    this.idx = 1;
    this.backDict = {};
  }
  getKey(str) {
    let isNew = false;
    if (!this.backDict[str]) {
      isNew = true;
      this.backDict[str] = this.idx++;
    }
    return [this.backDict[str], isNew];
  }
};
var AttributeSender = class {
  constructor(app, isDictDisabled) {
    this.app = app;
    this.isDictDisabled = isDictDisabled;
    this.dict = new StringDictionary();
  }
  sendSetAttribute(id2, name, value) {
    if (this.isDictDisabled) {
      const msg = [12, id2, name, value];
      return this.app.send(msg);
    } else {
      const message = [
        51,
        id2,
        this.applyDict(name),
        this.applyDict(value)
      ];
      return this.app.send(message);
    }
  }
  applyDict(str) {
    const [key, isNew] = this.dict.getKey(str);
    if (isNew) {
      this.app.send([50, key, str]);
    }
    return key;
  }
  clear() {
    this.dict = new StringDictionary();
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/conditionsManager.js
var ConditionsManager = class {
  constructor(app, startParams) {
    this.app = app;
    this.startParams = startParams;
    this.conditions = [];
    this.hasStarted = false;
    this.createConditionFromFilter = (filter) => {
      if (filter.value.length) {
        const resultCondition = mapCondition(filter);
        if (resultCondition.type) {
          return resultCondition;
        }
      }
      return void 0;
    };
    this.durationInt = null;
  }
  setConditions(conditions) {
    this.conditions = conditions;
  }
  async fetchConditions(projectId, token) {
    try {
      const r = await fetch(`${this.app.options.ingestPoint}/v1/web/conditions/${projectId}`, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token}`
        }
      });
      const { conditions } = await r.json();
      const mappedConditions = [];
      conditions.forEach((c) => {
        const filters = c.filters;
        filters.forEach((filter) => {
          let cond;
          if (filter.type === "fetch") {
            cond = {
              type: "network_request",
              subConditions: [],
              name: c.name
            };
            filter.filters.forEach((f) => {
              const subCond = this.createConditionFromFilter(f);
              if (subCond) {
                ;
                cond.subConditions.push(subCond);
              }
            });
          } else {
            cond = this.createConditionFromFilter(filter);
          }
          if (cond) {
            if (cond.type === "session_duration") {
              this.processDuration(cond.value[0], c.name);
            }
            mappedConditions.push({ ...cond, name: c.name });
          }
        });
      });
      this.conditions = mappedConditions;
    } catch (e) {
      this.app.debug.error("Critical: cannot fetch start conditions");
    }
  }
  trigger(conditionName) {
    if (this.hasStarted)
      return;
    try {
      this.hasStarted = true;
      void this.app.start(this.startParams, void 0, conditionName);
    } catch (e) {
      this.app.debug.error(e);
    }
  }
  processMessage(message) {
    if (this.hasStarted)
      return;
    switch (message[0]) {
      case 78:
        this.jsExceptionEvent(message);
        break;
      case 27:
        this.customEvent(message);
        break;
      case 68:
        this.clickEvent(message);
        break;
      case 122:
        this.pageLocationEvent(message);
        break;
      case 83:
        this.networkRequest(message);
        break;
      default:
        break;
    }
  }
  processFlags(flag) {
    const flagConds = this.conditions.filter((c) => c.type === "feature_flag");
    if (flagConds.length) {
      flagConds.forEach((flagCond) => {
        const operator = operators[flagCond.operator];
        if (operator && flag.find((f) => operator(f.key, flagCond.value))) {
          this.trigger(flagCond.name);
        }
      });
    }
  }
  processDuration(durationMs, condName) {
    this.durationInt = setInterval(() => {
      const sessionLength = performance.now();
      if (sessionLength > durationMs) {
        this.trigger(condName);
      }
    }, 1e3);
    this.app.attachStopCallback(() => {
      if (this.durationInt) {
        clearInterval(this.durationInt);
      }
    });
  }
  networkRequest(message) {
    const reqConds = this.conditions.filter((c) => c.type === "network_request");
    if (!reqConds.length)
      return;
    reqConds.forEach((reqCond) => {
      const validSubConditions = reqCond.subConditions.filter((c) => c.operator !== "isAny");
      if (validSubConditions.length) {
        const allPass = validSubConditions.every((subCond) => {
          let value;
          switch (subCond.key) {
            case "url":
              value = message[3];
              break;
            case "status":
              value = message[6];
              break;
            case "method":
              value = message[2];
              break;
            case "duration":
              value = message[8];
              break;
            default:
              break;
          }
          const operator = operators[subCond.operator];
          if (operator && operator(value, subCond.value)) {
            return true;
          }
        });
        if (allPass) {
          this.trigger(reqCond.name);
        }
      } else if (validSubConditions.length === 0 && reqCond.subConditions.length) {
        this.trigger(reqCond.name);
      }
    });
  }
  customEvent(message) {
    const evConds = this.conditions.filter((c) => c.type === "custom_event");
    if (evConds.length) {
      evConds.forEach((evCond) => {
        const operator = operators[evCond.operator];
        if (operator && (operator(message[1], evCond.value) || operator(message[2], evCond.value))) {
          this.trigger(evCond.name);
        }
      });
    }
  }
  clickEvent(message) {
    const clickCond = this.conditions.filter((c) => c.type === "click");
    if (clickCond.length) {
      clickCond.forEach((click) => {
        const operator = operators[click.operator];
        if (operator && (operator(message[3], click.value) || operator(message[4], click.value))) {
          this.trigger(click.name);
        }
      });
    }
  }
  pageLocationEvent(message) {
    const urlConds = this.conditions.filter((c) => c.type === "visited_url");
    if (urlConds) {
      urlConds.forEach((urlCond) => {
        const operator = operators[urlCond.operator];
        if (operator && operator(message[1], urlCond.value)) {
          this.trigger(urlCond.name);
        }
      });
    }
  }
  jsExceptionEvent(message) {
    const testedValues = [message[1], message[2], message[3]];
    const exceptionConds = this.conditions.filter((c) => c.type === "exception");
    if (exceptionConds) {
      exceptionConds.forEach((exceptionCond) => {
        const operator = operators[exceptionCond.operator];
        if (operator && testedValues.some((val) => operator(val, exceptionCond.value))) {
          this.trigger(exceptionCond.name);
        }
      });
    }
  }
};
var operators = {
  is: (val, target) => target.some((t) => val.includes(t)),
  isAny: () => true,
  isNot: (val, target) => !target.some((t) => val.includes(t)),
  contains: (val, target) => target.some((t) => val.includes(t)),
  notContains: (val, target) => !target.some((t) => val.includes(t)),
  startsWith: (val, target) => target.some((t) => val.startsWith(t)),
  endsWith: (val, target) => target.some((t) => val.endsWith(t)),
  greaterThan: (val, target) => val > target,
  greaterOrEqual: (val, target) => val >= target,
  lessOrEqual: (val, target) => val <= target,
  lessThan: (val, target) => val < target
};
var mapCondition = (condition) => {
  const opMap = {
    on: "is",
    notOn: "isNot",
    ">": "greaterThan",
    "<": "lessThan",
    "=": "is",
    "<=": "lessOrEqual",
    ">=": "greaterOrEqual"
  };
  const mapOperator = (operator) => {
    const keys = Object.keys(opMap);
    if (keys.includes(operator))
      return opMap[operator];
  };
  let con = {
    type: "",
    operator: "",
    value: condition.value,
    key: ""
  };
  switch (condition.type) {
    case "click":
      con = {
        type: "click",
        operator: mapOperator(condition.operator),
        value: condition.value,
        key: ""
      };
      break;
    case "location":
      con = {
        type: "visited_url",
        // @ts-ignore
        operator: condition.operator,
        value: condition.value,
        key: ""
      };
      break;
    case "custom":
      con = {
        type: "custom_event",
        // @ts-ignore
        operator: condition.operator,
        value: condition.value,
        key: ""
      };
      break;
    case "metadata":
      con = {
        // @ts-ignore
        type: condition.source === "featureFlag" ? "feature_flag" : condition.type,
        // @ts-ignore
        operator: condition.operator,
        value: condition.value,
        key: ""
      };
      break;
    case "error":
      con = {
        type: "exception",
        // @ts-ignore
        operator: condition.operator,
        value: condition.value,
        key: ""
      };
      break;
    case "duration":
      con = {
        type: "session_duration",
        // @ts-ignore
        value: condition.value[0],
        key: ""
      };
      break;
    case "fetchUrl":
      con = {
        type: "network_request",
        key: "url",
        operator: condition.operator,
        value: condition.value
      };
      break;
    case "fetchStatusCode":
      con = {
        type: "network_request",
        key: "status",
        operator: mapOperator(condition.operator),
        value: condition.value
      };
      break;
    case "fetchMethod":
      con = {
        type: "network_request",
        key: "method",
        operator: mapOperator(condition.operator),
        value: condition.value
      };
      break;
    case "fetchDuration":
      con = {
        type: "network_request",
        key: "duration",
        operator: mapOperator(condition.operator),
        value: condition.value
      };
      break;
  }
  return con;
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/featureFlags.js
var FeatureFlags = class {
  constructor(app) {
    this.app = app;
    this.flags = [];
    this.storageKey = "__openreplay_flags";
    const persistFlags = this.app.sessionStorage.getItem(this.storageKey);
    if (persistFlags) {
      const persistFlagsStrArr = persistFlags.split(";").filter(Boolean);
      this.flags = persistFlagsStrArr.map((flag) => JSON.parse(flag));
    }
  }
  getFeatureFlag(flagName) {
    return this.flags.find((flag) => flag.key === flagName);
  }
  isFlagEnabled(flagName) {
    return this.flags.findIndex((flag) => flag.key === flagName) !== -1;
  }
  onFlagsLoad(cb) {
    this.onFlagsCb = cb;
  }
  async reloadFlags(token) {
    const persistFlagsStr = this.app.sessionStorage.getItem(this.storageKey);
    const persistFlags = {};
    if (persistFlagsStr) {
      const persistArray = persistFlagsStr.split(";").filter(Boolean);
      persistArray.forEach((flag) => {
        const flagObj = JSON.parse(flag);
        persistFlags[flagObj.key] = { key: flagObj.key, value: flagObj.value };
      });
    }
    const sessionInfo = this.app.session.getInfo();
    const userInfo = this.app.session.userInfo;
    const requestObject = {
      projectID: sessionInfo.projectID,
      userID: sessionInfo.userID,
      metadata: sessionInfo.metadata,
      referrer: document.referrer,
      os: userInfo.userOS,
      device: userInfo.userDevice,
      country: userInfo.userCountry,
      state: userInfo.userState,
      city: userInfo.userCity,
      browser: userInfo.userBrowser,
      persistFlags
    };
    const authToken = token ?? this.app.session.getSessionToken();
    const resp = await fetch(this.app.options.ingestPoint + "/v1/web/feature-flags", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${authToken}`
      },
      body: JSON.stringify(requestObject)
    });
    if (resp.status === 200) {
      const data = await resp.json();
      return this.handleFlags(data.flags);
    }
  }
  handleFlags(flags) {
    var _a3;
    const persistFlags = [];
    flags.forEach((flag) => {
      if (flag.is_persist)
        persistFlags.push(flag);
    });
    let str = "";
    const uniquePersistFlags = this.diffPersist(persistFlags);
    uniquePersistFlags.forEach((flag) => {
      str += `${JSON.stringify(flag)};`;
    });
    this.app.sessionStorage.setItem(this.storageKey, str);
    this.flags = flags;
    return (_a3 = this.onFlagsCb) == null ? void 0 : _a3.call(this, flags);
  }
  clearPersistFlags() {
    this.app.sessionStorage.removeItem(this.storageKey);
  }
  diffPersist(flags) {
    const persistFlags = this.app.sessionStorage.getItem(this.storageKey);
    if (!persistFlags)
      return flags;
    const persistFlagsStrArr = persistFlags.split(";").filter(Boolean);
    const persistFlagsArr = persistFlagsStrArr.map((flag) => JSON.parse(flag));
    return flags.filter((flag) => persistFlagsArr.findIndex((pf) => pf.key === flag.key) === -1);
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/utils.js
var DEPRECATED_ATTRS = { htmlmasked: "hidden", masked: "obscured" };
var IN_BROWSER = !(typeof window === "undefined");
var IS_FIREFOX = IN_BROWSER && navigator.userAgent.match(/firefox|fxios/i);
var MAX_STR_LEN = 1e5;
var timeOrigin = IN_BROWSER ? Date.now() - performance.now() : 0;
function adjustTimeOrigin() {
  timeOrigin = Date.now() - performance.now();
}
function getTimeOrigin() {
  return timeOrigin;
}
var now = IN_BROWSER && !!performance.now ? () => Math.round(performance.now() + timeOrigin) : () => Date.now();
var stars = "repeat" in String.prototype ? (str) => "*".repeat(str.length) : (str) => str.replace(/./g, "*");
function normSpaces(str) {
  return str.trim().replace(/\s+/g, " ");
}
function isURL(s) {
  return s.startsWith("https://") || s.startsWith("http://");
}
var DOCS_HOST = "https://docs.openreplay.com";
var warnedFeatures = {};
function deprecationWarn(nameOfFeature, useInstead, docsPath = "/") {
  if (warnedFeatures[nameOfFeature]) {
    return;
  }
  console.warn(`OpenReplay: ${nameOfFeature} is deprecated. ${useInstead ? `Please, use ${useInstead} instead.` : ""} Visit ${DOCS_HOST}${docsPath} for more information.`);
  warnedFeatures[nameOfFeature] = true;
}
function getLabelAttribute(e) {
  let value = e.getAttribute("data-openreplay-label");
  if (value !== null) {
    return value;
  }
  value = e.getAttribute("data-asayer-label");
  if (value !== null) {
    deprecationWarn('"data-asayer-label" attribute', '"data-openreplay-label" attribute', "/");
  }
  return value;
}
function hasOpenreplayAttribute(e, attr2) {
  const newName = `data-openreplay-${attr2}`;
  if (e.hasAttribute(newName)) {
    if (DEPRECATED_ATTRS[attr2]) {
      deprecationWarn(
        `"${newName}" attribute`,
        // @ts-ignore
        `"${DEPRECATED_ATTRS[attr2]}" attribute`,
        "/installation/sanitize-data"
      );
    }
    return true;
  }
  return false;
}
function canAccessIframe(iframe) {
  try {
    return Boolean(iframe.contentDocument);
  } catch (e) {
    return false;
  }
}
function dec2hex(dec) {
  return dec.toString(16).padStart(2, "0");
}
function generateRandomId(len) {
  const arr = new Uint8Array((len || 40) / 2);
  const safeCrypto = window.crypto || window.msCrypto;
  if (safeCrypto) {
    safeCrypto.getRandomValues(arr);
    return Array.from(arr, dec2hex).join("");
  } else {
    return Array.from({ length: len || 40 }, () => dec2hex(Math.floor(Math.random() * 16))).join("");
  }
}
function inIframe() {
  try {
    return window.self && window.top && window.self !== window.top;
  } catch (e) {
    return true;
  }
}
function ngSafeBrowserMethod(method) {
  return window.Zone && "__symbol__" in window.Zone ? (
    // @ts-ignore
    window["Zone"]["__symbol__"](method)
  ) : method;
}
function createMutationObserver(cb) {
  const mObserver = ngSafeBrowserMethod("MutationObserver");
  return new window[mObserver](cb);
}
function createEventListener(target, event, cb, capture) {
  const safeAddEventListener = ngSafeBrowserMethod("addEventListener");
  try {
    target[safeAddEventListener](event, cb, capture);
  } catch (e) {
    const msg = e.message;
    console.debug(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Openreplay: ${msg}; if this error is caused by an IframeObserver, ignore it`
    );
  }
}
function deleteEventListener(target, event, cb, capture) {
  const safeRemoveEventListener = ngSafeBrowserMethod("removeEventListener");
  try {
    target[safeRemoveEventListener](event, cb, capture);
  } catch (e) {
    const msg = e.message;
    console.debug(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Openreplay: ${msg}; if this error is caused by an IframeObserver, ignore it`
    );
  }
}
var FIFOTaskScheduler = class {
  constructor() {
    this.taskQueue = [];
    this.isRunning = false;
  }
  // Adds a task to the queue
  addTask(task) {
    this.taskQueue.push(task);
    this.runTasks();
  }
  // Runs tasks from the queue
  runTasks() {
    if (this.isRunning || this.taskQueue.length === 0) {
      return;
    }
    this.isRunning = true;
    const executeNextTask = () => {
      if (this.taskQueue.length === 0) {
        this.isRunning = false;
        return;
      }
      const nextTask = this.taskQueue.shift();
      Promise.resolve(nextTask()).then(() => {
        requestAnimationFrame(() => executeNextTask());
      });
    };
    executeNextTask();
  }
};
var scheduler = new FIFOTaskScheduler();
function requestIdleCb(callback) {
  scheduler.addTask(callback);
}
function simpleMerge(defaultObj, givenObj) {
  const result = { ...defaultObj };
  for (const key in givenObj) {
    if (givenObj.hasOwnProperty(key)) {
      const userOptionValue = givenObj[key];
      const defaultOptionValue = defaultObj[key];
      if (typeof userOptionValue === "object" && !Array.isArray(userOptionValue) && userOptionValue !== null) {
        result[key] = simpleMerge(defaultOptionValue || {}, userOptionValue);
      } else {
        result[key] = userOptionValue;
      }
    }
  }
  return result;
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/messages.gen.js
var messages_gen_exports = {};
__export(messages_gen_exports, {
  AdoptedSSAddOwner: () => AdoptedSSAddOwner,
  AdoptedSSDeleteRule: () => AdoptedSSDeleteRule,
  AdoptedSSInsertRuleURLBased: () => AdoptedSSInsertRuleURLBased,
  AdoptedSSRemoveOwner: () => AdoptedSSRemoveOwner,
  AdoptedSSReplaceURLBased: () => AdoptedSSReplaceURLBased,
  BatchMetadata: () => BatchMetadata,
  CSSDeleteRule: () => CSSDeleteRule,
  CSSInsertRule: () => CSSInsertRule,
  CSSInsertRuleURLBased: () => CSSInsertRuleURLBased,
  CanvasNode: () => CanvasNode,
  ConnectionInformation: () => ConnectionInformation,
  ConsoleLog: () => ConsoleLog,
  CreateDocument: () => CreateDocument,
  CreateElementNode: () => CreateElementNode,
  CreateIFrameDocument: () => CreateIFrameDocument,
  CreateTextNode: () => CreateTextNode,
  CustomEvent: () => CustomEvent,
  CustomIssue: () => CustomIssue,
  Fetch: () => Fetch,
  GraphQL: () => GraphQL,
  GraphQLDeprecated: () => GraphQLDeprecated,
  InputChange: () => InputChange,
  JSException: () => JSException,
  LoadFontFace: () => LoadFontFace,
  LongTask: () => LongTask,
  Metadata: () => Metadata,
  MobX: () => MobX,
  MouseClick: () => MouseClick,
  MouseClickDeprecated: () => MouseClickDeprecated,
  MouseMove: () => MouseMove,
  MouseThrashing: () => MouseThrashing,
  MoveNode: () => MoveNode,
  NetworkRequest: () => NetworkRequest,
  NetworkRequestDeprecated: () => NetworkRequestDeprecated,
  NgRx: () => NgRx,
  OTable: () => OTable,
  PageLoadTiming: () => PageLoadTiming,
  PageRenderTiming: () => PageRenderTiming,
  PartitionedMessage: () => PartitionedMessage,
  PerformanceTrack: () => PerformanceTrack,
  Profiler: () => Profiler,
  Redux: () => Redux,
  ReduxDeprecated: () => ReduxDeprecated,
  RemoveNode: () => RemoveNode,
  RemoveNodeAttribute: () => RemoveNodeAttribute,
  ResourceTiming: () => ResourceTiming,
  ResourceTimingDeprecated: () => ResourceTimingDeprecated,
  SelectionChange: () => SelectionChange,
  SetCSSDataURLBased: () => SetCSSDataURLBased,
  SetInputChecked: () => SetInputChecked,
  SetInputTarget: () => SetInputTarget,
  SetInputValue: () => SetInputValue,
  SetNodeAttribute: () => SetNodeAttribute,
  SetNodeAttributeDict: () => SetNodeAttributeDict,
  SetNodeAttributeURLBased: () => SetNodeAttributeURLBased,
  SetNodeData: () => SetNodeData,
  SetNodeFocus: () => SetNodeFocus,
  SetNodeScroll: () => SetNodeScroll,
  SetPageLocation: () => SetPageLocation,
  SetPageLocationDeprecated: () => SetPageLocationDeprecated,
  SetPageVisibility: () => SetPageVisibility,
  SetViewportScroll: () => SetViewportScroll,
  SetViewportSize: () => SetViewportSize,
  StateAction: () => StateAction,
  StringDict: () => StringDict,
  TabChange: () => TabChange,
  TabData: () => TabData,
  TagTrigger: () => TagTrigger,
  TechnicalInfo: () => TechnicalInfo,
  Timestamp: () => Timestamp,
  UnbindNodes: () => UnbindNodes,
  UserAnonymousID: () => UserAnonymousID,
  UserID: () => UserID,
  Vuex: () => Vuex,
  WSChannel: () => WSChannel,
  Zustand: () => Zustand
});
function Timestamp(timestamp) {
  return [
    0,
    timestamp
  ];
}
function SetPageLocationDeprecated(url, referrer, navigationStart) {
  return [
    4,
    url,
    referrer,
    navigationStart
  ];
}
function SetViewportSize(width, height) {
  return [
    5,
    width,
    height
  ];
}
function SetViewportScroll(x, y) {
  return [
    6,
    x,
    y
  ];
}
function CreateDocument() {
  return [
    7
  ];
}
function CreateElementNode(id2, parentID, index2, tag, svg) {
  return [
    8,
    id2,
    parentID,
    index2,
    tag,
    svg
  ];
}
function CreateTextNode(id2, parentID, index2) {
  return [
    9,
    id2,
    parentID,
    index2
  ];
}
function MoveNode(id2, parentID, index2) {
  return [
    10,
    id2,
    parentID,
    index2
  ];
}
function RemoveNode(id2) {
  return [
    11,
    id2
  ];
}
function SetNodeAttribute(id2, name, value) {
  return [
    12,
    id2,
    name,
    value
  ];
}
function RemoveNodeAttribute(id2, name) {
  return [
    13,
    id2,
    name
  ];
}
function SetNodeData(id2, data) {
  return [
    14,
    id2,
    data
  ];
}
function SetNodeScroll(id2, x, y) {
  return [
    16,
    id2,
    x,
    y
  ];
}
function SetInputTarget(id2, label) {
  return [
    17,
    id2,
    label
  ];
}
function SetInputValue(id2, value, mask) {
  return [
    18,
    id2,
    value,
    mask
  ];
}
function SetInputChecked(id2, checked) {
  return [
    19,
    id2,
    checked
  ];
}
function MouseMove(x, y) {
  return [
    20,
    x,
    y
  ];
}
function NetworkRequestDeprecated(type, method, url, request, response, status, timestamp, duration) {
  return [
    21,
    type,
    method,
    url,
    request,
    response,
    status,
    timestamp,
    duration
  ];
}
function ConsoleLog(level, value) {
  return [
    22,
    level,
    value
  ];
}
function PageLoadTiming(requestStart, responseStart, responseEnd, domContentLoadedEventStart, domContentLoadedEventEnd, loadEventStart, loadEventEnd, firstPaint, firstContentfulPaint) {
  return [
    23,
    requestStart,
    responseStart,
    responseEnd,
    domContentLoadedEventStart,
    domContentLoadedEventEnd,
    loadEventStart,
    loadEventEnd,
    firstPaint,
    firstContentfulPaint
  ];
}
function PageRenderTiming(speedIndex, visuallyComplete, timeToInteractive) {
  return [
    24,
    speedIndex,
    visuallyComplete,
    timeToInteractive
  ];
}
function CustomEvent(name, payload) {
  return [
    27,
    name,
    payload
  ];
}
function UserID(id2) {
  return [
    28,
    id2
  ];
}
function UserAnonymousID(id2) {
  return [
    29,
    id2
  ];
}
function Metadata(key, value) {
  return [
    30,
    key,
    value
  ];
}
function CSSInsertRule(id2, rule, index2) {
  return [
    37,
    id2,
    rule,
    index2
  ];
}
function CSSDeleteRule(id2, index2) {
  return [
    38,
    id2,
    index2
  ];
}
function Fetch(method, url, request, response, status, timestamp, duration) {
  return [
    39,
    method,
    url,
    request,
    response,
    status,
    timestamp,
    duration
  ];
}
function Profiler(name, duration, args, result) {
  return [
    40,
    name,
    duration,
    args,
    result
  ];
}
function OTable(key, value) {
  return [
    41,
    key,
    value
  ];
}
function StateAction(type) {
  return [
    42,
    type
  ];
}
function ReduxDeprecated(action, state, duration) {
  return [
    44,
    action,
    state,
    duration
  ];
}
function Vuex(mutation, state) {
  return [
    45,
    mutation,
    state
  ];
}
function MobX(type, payload) {
  return [
    46,
    type,
    payload
  ];
}
function NgRx(action, state, duration) {
  return [
    47,
    action,
    state,
    duration
  ];
}
function GraphQLDeprecated(operationKind, operationName, variables, response, duration) {
  return [
    48,
    operationKind,
    operationName,
    variables,
    response,
    duration
  ];
}
function PerformanceTrack(frames, ticks, totalJSHeapSize, usedJSHeapSize) {
  return [
    49,
    frames,
    ticks,
    totalJSHeapSize,
    usedJSHeapSize
  ];
}
function StringDict(key, value) {
  return [
    50,
    key,
    value
  ];
}
function SetNodeAttributeDict(id2, nameKey, valueKey) {
  return [
    51,
    id2,
    nameKey,
    valueKey
  ];
}
function ResourceTimingDeprecated(timestamp, duration, ttfb, headerSize, encodedBodySize, decodedBodySize, url, initiator) {
  return [
    53,
    timestamp,
    duration,
    ttfb,
    headerSize,
    encodedBodySize,
    decodedBodySize,
    url,
    initiator
  ];
}
function ConnectionInformation(downlink, type) {
  return [
    54,
    downlink,
    type
  ];
}
function SetPageVisibility(hidden) {
  return [
    55,
    hidden
  ];
}
function LoadFontFace(parentID, family, source, descriptors) {
  return [
    57,
    parentID,
    family,
    source,
    descriptors
  ];
}
function SetNodeFocus(id2) {
  return [
    58,
    id2
  ];
}
function LongTask(timestamp, duration, context, containerType, containerSrc, containerId, containerName) {
  return [
    59,
    timestamp,
    duration,
    context,
    containerType,
    containerSrc,
    containerId,
    containerName
  ];
}
function SetNodeAttributeURLBased(id2, name, value, baseURL) {
  return [
    60,
    id2,
    name,
    value,
    baseURL
  ];
}
function SetCSSDataURLBased(id2, data, baseURL) {
  return [
    61,
    id2,
    data,
    baseURL
  ];
}
function TechnicalInfo(type, value) {
  return [
    63,
    type,
    value
  ];
}
function CustomIssue(name, payload) {
  return [
    64,
    name,
    payload
  ];
}
function CSSInsertRuleURLBased(id2, rule, index2, baseURL) {
  return [
    67,
    id2,
    rule,
    index2,
    baseURL
  ];
}
function MouseClick(id2, hesitationTime, label, selector2, normalizedX, normalizedY) {
  return [
    68,
    id2,
    hesitationTime,
    label,
    selector2,
    normalizedX,
    normalizedY
  ];
}
function MouseClickDeprecated(id2, hesitationTime, label, selector2) {
  return [
    69,
    id2,
    hesitationTime,
    label,
    selector2
  ];
}
function CreateIFrameDocument(frameID, id2) {
  return [
    70,
    frameID,
    id2
  ];
}
function AdoptedSSReplaceURLBased(sheetID, text, baseURL) {
  return [
    71,
    sheetID,
    text,
    baseURL
  ];
}
function AdoptedSSInsertRuleURLBased(sheetID, rule, index2, baseURL) {
  return [
    73,
    sheetID,
    rule,
    index2,
    baseURL
  ];
}
function AdoptedSSDeleteRule(sheetID, index2) {
  return [
    75,
    sheetID,
    index2
  ];
}
function AdoptedSSAddOwner(sheetID, id2) {
  return [
    76,
    sheetID,
    id2
  ];
}
function AdoptedSSRemoveOwner(sheetID, id2) {
  return [
    77,
    sheetID,
    id2
  ];
}
function JSException(name, message, payload, metadata) {
  return [
    78,
    name,
    message,
    payload,
    metadata
  ];
}
function Zustand(mutation, state) {
  return [
    79,
    mutation,
    state
  ];
}
function BatchMetadata(version, pageNo, firstIndex, timestamp, location2) {
  return [
    81,
    version,
    pageNo,
    firstIndex,
    timestamp,
    location2
  ];
}
function PartitionedMessage(partNo, partTotal) {
  return [
    82,
    partNo,
    partTotal
  ];
}
function NetworkRequest(type, method, url, request, response, status, timestamp, duration, transferredBodySize) {
  return [
    83,
    type,
    method,
    url,
    request,
    response,
    status,
    timestamp,
    duration,
    transferredBodySize
  ];
}
function WSChannel(chType, channelName, data, timestamp, dir, messageType) {
  return [
    84,
    chType,
    channelName,
    data,
    timestamp,
    dir,
    messageType
  ];
}
function InputChange(id2, value, valueMasked, label, hesitationTime, inputDuration) {
  return [
    112,
    id2,
    value,
    valueMasked,
    label,
    hesitationTime,
    inputDuration
  ];
}
function SelectionChange(selectionStart, selectionEnd, selection2) {
  return [
    113,
    selectionStart,
    selectionEnd,
    selection2
  ];
}
function MouseThrashing(timestamp) {
  return [
    114,
    timestamp
  ];
}
function UnbindNodes(totalRemovedPercent) {
  return [
    115,
    totalRemovedPercent
  ];
}
function ResourceTiming(timestamp, duration, ttfb, headerSize, encodedBodySize, decodedBodySize, url, initiator, transferredSize, cached) {
  return [
    116,
    timestamp,
    duration,
    ttfb,
    headerSize,
    encodedBodySize,
    decodedBodySize,
    url,
    initiator,
    transferredSize,
    cached
  ];
}
function TabChange(tabId) {
  return [
    117,
    tabId
  ];
}
function TabData(tabId) {
  return [
    118,
    tabId
  ];
}
function CanvasNode(nodeId, timestamp) {
  return [
    119,
    nodeId,
    timestamp
  ];
}
function TagTrigger(tagId) {
  return [
    120,
    tagId
  ];
}
function Redux(action, state, duration, actionTime) {
  return [
    121,
    action,
    state,
    duration,
    actionTime
  ];
}
function SetPageLocation(url, referrer, navigationStart, documentTitle) {
  return [
    122,
    url,
    referrer,
    navigationStart,
    documentTitle
  ];
}
function GraphQL(operationKind, operationName, variables, response, duration) {
  return [
    123,
    operationKind,
    operationName,
    variables,
    response,
    duration
  ];
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/performance.js
var perf = IN_BROWSER && "performance" in window && "memory" in performance ? performance : { memory: {} };
var deviceMemory = IN_BROWSER ? (navigator.deviceMemory || 0) * 1024 : 0;
var jsHeapSizeLimit = perf.memory.jsHeapSizeLimit || 0;
function performance_default(app, opts) {
  const options = Object.assign({
    capturePerformance: true
  }, opts);
  if (!options.capturePerformance) {
    return;
  }
  let frames;
  let ticks;
  const nextFrame = () => {
    if (frames === void 0 || frames === -1) {
      return;
    }
    frames++;
    requestAnimationFrame(nextFrame);
  };
  app.ticker.attach(() => {
    if (ticks === void 0 || ticks === -1) {
      return;
    }
    ticks++;
  }, 0, false);
  const sendPerformanceTrack = () => {
    if (frames === void 0 || ticks === void 0) {
      return;
    }
    app.send(PerformanceTrack(frames, ticks, perf.memory.totalJSHeapSize || 0, perf.memory.usedJSHeapSize || 0));
    ticks = frames = document.hidden ? -1 : 0;
  };
  app.attachStartCallback(() => {
    ticks = frames = -1;
    sendPerformanceTrack();
    nextFrame();
  });
  app.attachStopCallback(() => {
    ticks = frames = void 0;
  });
  app.ticker.attach(sendPerformanceTrack, 40, false);
  if (document.hidden !== void 0) {
    app.attachEventListener(document, "visibilitychange", sendPerformanceTrack, false, false);
  }
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/tagWatcher.js
var WATCHED_TAGS_KEY = "__or__watched_tags__";
var TagWatcher = class {
  constructor(sessionStorage, errLog, onTag) {
    this.sessionStorage = sessionStorage;
    this.errLog = errLog;
    this.onTag = onTag;
    this.intervals = {};
    this.tags = [];
    const tags = JSON.parse(sessionStorage.getItem(WATCHED_TAGS_KEY) ?? "[]");
    this.setTags(tags);
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          if (entry.target) {
            const tag = entry.target.__or_watcher_tagname;
            if (tag) {
              this.onTagRendered(tag);
            }
            this.observer.unobserve(entry.target);
          }
        }
      });
    });
  }
  async fetchTags(ingest, token) {
    return fetch(`${ingest}/v1/web/tags`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`
      }
    }).then((r) => r.json()).then(({ tags }) => {
      if (tags && tags.length) {
        this.setTags(tags);
        const tagString = JSON.stringify(tags);
        this.sessionStorage.setItem(WATCHED_TAGS_KEY, tagString || "");
      }
    }).catch((e) => this.errLog(e));
  }
  setTags(tags) {
    this.tags = tags;
    this.intervals = {};
    tags.forEach((tag) => {
      this.intervals[tag.id] = setInterval(() => {
        const possibleEls = document.querySelectorAll(tag.selector);
        if (possibleEls.length > 0) {
          const el = possibleEls[0];
          el.__or_watcher_tagname = tag.id;
          this.observer.observe(el);
        }
      }, 500);
    });
  }
  onTagRendered(tagId) {
    if (this.intervals[tagId]) {
      clearInterval(this.intervals[tagId]);
    }
    this.onTag(tagId);
  }
  clear() {
    this.tags.forEach((tag) => {
      clearInterval(this.intervals[tag.id]);
    });
    this.tags = [];
    this.intervals = {};
    this.observer.disconnect();
  }
};
var tagWatcher_default = TagWatcher;

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/styles.js
var bgStyle = {
  position: "fixed",
  top: 0,
  left: 0,
  width: "100vw",
  height: "100vh",
  background: "rgba(0, 0, 0, 0.40)",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  zIndex: 999999,
  fontFamily: `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`
};
var containerStyle = {
  display: "flex",
  flexDirection: "column",
  gap: "2rem",
  alignItems: "center",
  padding: "1.5rem",
  borderRadius: "2px",
  border: "1px solid #D9D9D9",
  background: "#FFF",
  width: "22rem"
};
var containerWidgetStyle = {
  display: "flex",
  "flex-direction": "column",
  gap: "unset",
  "align-items": "center",
  padding: "unset",
  fontFamily: `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
  "border-radius": "2px",
  border: "1px solid #D9D9D9",
  background: "rgba(255, 255, 255, 0.75)",
  width: "22rem"
};
var titleStyle = {
  fontFamily: "Verdana, sans-serif",
  fontSize: "1.25rem",
  fontStyle: "normal",
  fontWeight: "500",
  lineHeight: "1.75rem",
  color: "rgba(0, 0, 0, 0.85)"
};
var descriptionStyle = {
  borderTop: "1px solid rgba(0, 0, 0, 0.06)",
  borderBottom: "1px solid rgba(0, 0, 0, 0.06)",
  padding: "1.25rem 0rem",
  color: "rgba(0, 0, 0, 0.85)",
  fontFamily: "Verdana, sans-serif",
  fontSize: "13px",
  fontStyle: "normal",
  fontWeight: "400",
  lineHeight: "auto",
  whiteSpace: "pre-wrap"
};
var buttonStyle = {
  display: "flex",
  padding: "0.4rem 0.9375rem",
  justifyContent: "center",
  alignItems: "center",
  gap: "0.625rem",
  borderRadius: "0.25rem",
  border: "1px solid #394EFF",
  background: "#394EFF",
  boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
  color: "#FFF",
  textAlign: "center",
  fontFamily: "Verdana, sans-serif",
  fontSize: "1rem",
  fontStyle: "normal",
  fontWeight: "500",
  lineHeight: "1.5rem",
  cursor: "pointer"
};
var sectionTitleStyle = {
  fontFamily: "Verdana, sans-serif",
  fontSize: "13px",
  fontWeight: "500",
  lineHeight: "auto",
  display: "flex",
  justifyContent: "space-between",
  width: "100%",
  cursor: "pointer"
};
var contentStyle = {
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start",
  gap: "0.625rem",
  fontSize: "13px",
  lineHeight: "auto"
};
var titleWidgetStyle = {
  padding: "0.5rem",
  gap: "0.5rem",
  fontFamily: "Verdana, sans-serif",
  fontSize: "16px",
  fontStyle: "normal",
  fontWeight: "500",
  lineHeight: "auto",
  color: "white",
  display: "flex",
  alignItems: "center",
  width: "100%",
  borderRadius: "2px",
  background: "rgba(0, 0, 0, 0.75)",
  boxSizing: "border-box"
};
var descriptionWidgetStyle = {
  boxSizing: "border-box",
  display: "block",
  width: "100%",
  borderBottom: "1px solid #D9D9D9",
  background: "#FFF",
  padding: "0.65rem",
  alignSelf: "stretch",
  color: "#000",
  fontFamily: "Verdana, sans-serif",
  // fontSize: '0.875rem',
  fontStyle: "normal",
  fontWeight: "400"
  // lineHeight: '1.375rem',
};
var endSectionStyle = {
  ...descriptionWidgetStyle,
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  gap: "0.625rem"
};
var symbolIcon = {
  fontSize: "1.25rem",
  fontWeight: "500",
  cursor: "pointer",
  color: "#394EFF"
};
var buttonWidgetStyle = {
  display: "flex",
  padding: "0.4rem 0.9375rem",
  justifyContent: "center",
  alignItems: "center",
  gap: "0.625rem",
  borderRadius: "0.25rem",
  border: "1px solid #394EFF",
  background: "#394EFF",
  boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
  color: "#FFF",
  textAlign: "center",
  fontFamily: "Verdana, sans-serif",
  fontSize: "1rem",
  fontStyle: "normal",
  fontWeight: "500",
  lineHeight: "1.5rem",
  width: "100%",
  boxSizing: "border-box",
  cursor: "pointer"
};
var stopWidgetStyle = {
  marginTop: "1rem",
  marginBottom: "1rem",
  cursor: "pointer",
  display: "block",
  fontWeight: "500",
  fontSize: "13px!important",
  lineHeight: "auto"
};
var paginationStyle = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  gap: "1rem",
  padding: "0.5rem",
  width: "100%",
  boxSizing: "border-box"
};
var taskNumberActive = {
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: "6.25em",
  outline: "1px solid #394EFF",
  fontSize: "13px",
  height: "24px",
  width: "24px"
};
var taskNumberDone = {
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: "6.25em",
  outline: "1px solid #D2DFFF",
  boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
  background: "#D2DFFF",
  fontSize: "13px",
  height: "24px",
  width: "24px"
};
var taskDescriptionCard = {
  borderRadius: "0.375rem",
  border: "1px solid rgba(0, 0, 0, 0.06)",
  background: "#F5F7FF",
  boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
  display: "flex",
  flexDirection: "column",
  padding: "0.625rem 0.9375rem",
  gap: "0.5rem",
  alignSelf: "stretch"
};
var taskTextStyle = {
  fontWeight: "bold"
};
var taskDescriptionStyle = {
  fontSize: "13px",
  lineHeight: "auto"
};
var taskButtonStyle = {
  marginRight: "0.5rem",
  cursor: "pointer",
  color: "#394EFF",
  textAlign: "center",
  fontFamily: "Verdana, sans-serif",
  fontSize: "13px",
  fontStyle: "normal",
  fontWeight: "500",
  lineHeight: "auto"
};
var taskButtonBorderedStyle = {
  ...taskButtonStyle,
  display: "flex",
  padding: "0.25rem 0.9375rem",
  justifyContent: "center",
  alignItems: "center",
  gap: "0.5rem",
  borderRadius: "0.25rem",
  border: "1px solid #394EFF"
};
var taskButtonsRow = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  width: "100%",
  boxSizing: "border-box"
};
var spinnerStyles = {
  border: "4px solid rgba(255, 255, 255, 0.4)",
  width: "16px",
  height: "16px",
  borderRadius: "50%",
  borderLeftColor: "#fff",
  animation: "spin 0.5s linear infinite"
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/recorder.js
var Quality = {
  Standard: { width: 1280, height: 720 },
  High: { width: 1920, height: 1080 }
};
var Recorder = class {
  constructor(app) {
    this.app = app;
    this.mediaRecorder = null;
    this.recordedChunks = [];
    this.stream = null;
    this.recStartTs = null;
  }
  async startRecording(fps, quality, micReq, camReq) {
    this.recStartTs = this.app.timestamp();
    const videoConstraints = quality;
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({
        video: camReq ? { ...videoConstraints, frameRate: { ideal: fps } } : false,
        audio: micReq
      });
      this.mediaRecorder = new MediaRecorder(this.stream, {
        mimeType: "video/webm;codecs=vp9"
      });
      this.recordedChunks = [];
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.recordedChunks.push(event.data);
        }
      };
      this.mediaRecorder.start();
    } catch (error) {
      console.error(error);
    }
  }
  async stopRecording() {
    return new Promise((resolve) => {
      if (!this.mediaRecorder)
        return;
      this.mediaRecorder.onstop = () => {
        const blob = new Blob(this.recordedChunks, {
          type: "video/webm"
        });
        resolve(blob);
      };
      this.mediaRecorder.stop();
    });
  }
  async sendToAPI() {
    const blob = await this.stopRecording();
    return fetch(`${this.app.options.ingestPoint}/v1/web/uxt/upload-url`, {
      headers: {
        Authorization: `Bearer ${this.app.session.getSessionToken()}`
      }
    }).then((r) => {
      if (r.ok) {
        return r.json();
      } else {
        throw new Error("Failed to get upload url");
      }
    }).then(({ url }) => {
      return fetch(url, {
        method: "PUT",
        headers: {
          "Content-Type": "video/webm"
        },
        body: blob
      });
    }).catch(console.error).finally(() => {
      this.discard();
    });
  }
  async saveToFile(fileName = "recorded-video.webm") {
    const blob = await this.stopRecording();
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
  }
  discard() {
    var _a3, _b2;
    (_a3 = this.mediaRecorder) == null ? void 0 : _a3.stop();
    (_b2 = this.stream) == null ? void 0 : _b2.getTracks().forEach((track) => track.stop());
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/dnd.js
function attachDND(element, dragTarget) {
  dragTarget.onmousedown = function(event) {
    const clientRect = element.getBoundingClientRect();
    const shiftX = event.clientX - clientRect.left;
    const shiftY = event.clientY - clientRect.top;
    element.style.position = "fixed";
    element.style.zIndex = 99999999999999;
    moveAt(event.pageX, event.pageY);
    function moveAt(pageX, pageY) {
      let leftC = pageX - shiftX;
      let topC = pageY - shiftY;
      if (leftC <= 5)
        leftC = 5;
      if (topC <= 5)
        topC = 5;
      if (leftC >= window.innerWidth - clientRect.width)
        leftC = window.innerWidth - clientRect.width;
      if (topC >= window.innerHeight - clientRect.height)
        topC = window.innerHeight - clientRect.height;
      element.style.left = `${leftC}px`;
      element.style.top = `${topC}px`;
    }
    function onMouseMove(event2) {
      moveAt(event2.pageX, event2.pageY);
    }
    document.addEventListener("mousemove", onMouseMove);
    const clearAll = () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", clearAll);
    };
    document.addEventListener("mouseup", clearAll);
  };
  dragTarget.ondragstart = function() {
    return false;
  };
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/utils.js
function generateGrid() {
  const grid = document.createElement("div");
  grid.className = "grid";
  for (let i = 0; i < 16; i++) {
    const cell = document.createElement("div");
    Object.assign(cell.style, {
      width: "2px",
      height: "2px",
      borderRadius: "10px",
      background: "white"
    });
    cell.className = "cell";
    grid.appendChild(cell);
  }
  Object.assign(grid.style, {
    display: "grid",
    gridTemplateColumns: "repeat(4, 1fr)",
    gridTemplateRows: "repeat(4, 1fr)",
    gap: "2px",
    cursor: "grab"
  });
  return grid;
}
function generateChevron() {
  const triangle = document.createElement("div");
  Object.assign(triangle.style, {
    width: "0",
    height: "0",
    borderLeft: "7px solid transparent",
    borderRight: "7px solid transparent",
    borderBottom: "7px solid white"
  });
  const container = document.createElement("div");
  container.appendChild(triangle);
  Object.assign(container.style, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: "16px",
    height: "16px",
    cursor: "pointer",
    marginLeft: "auto",
    transform: "rotate(180deg)"
  });
  return container;
}
function addKeyframes() {
  const styleSheet = document.createElement("style");
  styleSheet.type = "text/css";
  styleSheet.innerText = `@keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }`;
  document.head.appendChild(styleSheet);
}
function createSpinner() {
  addKeyframes();
  const spinner = document.createElement("div");
  spinner.classList.add("spinner");
  Object.assign(spinner.style, spinnerStyles);
  return spinner;
}
function createElement(tag, className, styles, textContent, id2) {
  const element = document.createElement(tag);
  element.className = className;
  Object.assign(element.style, styles);
  if (textContent) {
    element.textContent = textContent;
  }
  if (id2) {
    element.id = id2;
  }
  return element;
}
var TEST_START = "or_uxt_test_start";
var TASK_IND = "or_uxt_task_index";
var SESSION_ID = "or_uxt_session_id";
var TEST_ID = "or_uxt_test_id";

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/SignalManager.js
var SignalManager = class {
  constructor(ingestPoint, getTimestamp, token, testId, storageKey, setStorageKey, removeStorageKey, getStorageKey, getSessionId) {
    this.ingestPoint = ingestPoint;
    this.getTimestamp = getTimestamp;
    this.token = token;
    this.testId = testId;
    this.storageKey = storageKey;
    this.setStorageKey = setStorageKey;
    this.removeStorageKey = removeStorageKey;
    this.getStorageKey = getStorageKey;
    this.getSessionId = getSessionId;
    this.durations = {
      testStart: 0,
      tasks: []
    };
    this.getDurations = () => {
      return this.durations;
    };
    this.setDurations = (durations) => {
      this.durations.testStart = durations.testStart;
      this.durations.tasks = durations.tasks;
    };
    this.signalTask = (taskId, status, taskAnswer) => {
      if (!taskId)
        return console.error("User Testing: No Task ID Given");
      const taskStart = this.durations.tasks.find((t) => t.taskId === taskId);
      const timestamp = this.getTimestamp();
      const duration = taskStart ? timestamp - taskStart.started : 0;
      return fetch(`${this.ingestPoint}/v1/web/uxt/signals/task`, {
        method: "POST",
        headers: {
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          Authorization: `Bearer ${this.token}`
        },
        body: JSON.stringify({
          testId: this.testId,
          taskId,
          status,
          duration,
          timestamp,
          taskAnswer
        })
      });
    };
    this.signalTest = (status) => {
      const timestamp = this.getTimestamp();
      if (status === "begin" && this.testId) {
        const sessionId = this.getSessionId();
        this.setStorageKey(SESSION_ID, sessionId);
        this.setStorageKey(this.storageKey, this.testId.toString());
        this.setStorageKey(TEST_START, timestamp.toString());
      } else {
        this.removeStorageKey(this.storageKey);
        this.removeStorageKey(TASK_IND);
        this.removeStorageKey(TEST_START);
      }
      const start2 = this.durations.testStart || timestamp;
      const duration = timestamp - start2;
      return fetch(`${this.ingestPoint}/v1/web/uxt/signals/test`, {
        method: "POST",
        headers: {
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          Authorization: `Bearer ${this.token}`
        },
        body: JSON.stringify({
          testId: this.testId,
          status,
          duration,
          timestamp
        })
      });
    };
    const possibleStart = this.getStorageKey(TEST_START);
    if (possibleStart) {
      this.durations.testStart = parseInt(possibleStart, 10);
    }
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/index.js
var UserTestManager = class {
  constructor(app, storageKey) {
    this.app = app;
    this.storageKey = storageKey;
    this.bg = createElement("div", "bg", bgStyle, void 0, "__or_ut_bg");
    this.container = createElement("div", "container", containerStyle, void 0, "__or_ut_ct");
    this.widgetGuidelinesVisible = true;
    this.widgetTasksVisible = false;
    this.widgetVisible = true;
    this.isActive = false;
    this.descriptionSection = null;
    this.taskSection = null;
    this.endSection = null;
    this.stopButton = null;
    this.stopButtonContainer = null;
    this.test = null;
    this.testId = null;
    this.signalManager = null;
    this.getTest = (id2, token, inProgress) => {
      this.testId = id2;
      const ingest = this.app.options.ingestPoint;
      return fetch(`${ingest}/v1/web/uxt/test/${id2}`, {
        headers: {
          Authorization: `Bearer ${token}`
        }
      }).then((res) => res.json()).then(({ test }) => {
        this.isActive = true;
        this.test = test;
        this.signalManager = new SignalManager(this.app.options.ingestPoint, () => this.app.timestamp(), token, id2, this.storageKey, (k, v) => this.app.localStorage.setItem(k, v), (k) => this.app.localStorage.removeItem(k), (k) => this.app.localStorage.getItem(k), () => this.app.getSessionID());
        this.createGreeting(test.title, test.reqMic, test.reqCamera);
        if (inProgress) {
          if (test.reqMic || test.reqCamera) {
            void this.userRecorder.startRecording(30, Quality.Standard, test.reqMic, test.reqCamera);
          }
          this.showWidget(test.description, test.tasks, true);
          this.showTaskSection();
        }
      }).then(() => id2).catch((err2) => {
        console.log("OR: Error fetching test", err2);
      });
    };
    this.hideTaskSection = () => false;
    this.showTaskSection = () => true;
    this.collapseWidget = () => false;
    this.removeGreeting = () => false;
    this.toggleDescriptionVisibility = () => {
    };
    this.currentTaskIndex = 0;
    this.userRecorder = new Recorder(app);
    const sessionId = this.app.getSessionID();
    const savedSessionId = this.app.localStorage.getItem(SESSION_ID);
    if (sessionId !== savedSessionId) {
      this.app.localStorage.removeItem(this.storageKey);
      this.app.localStorage.removeItem(SESSION_ID);
      this.app.localStorage.removeItem(TEST_ID);
      this.app.localStorage.removeItem(TASK_IND);
      this.app.localStorage.removeItem(TEST_START);
    }
    const taskIndex = this.app.localStorage.getItem(TASK_IND);
    if (taskIndex) {
      this.currentTaskIndex = parseInt(taskIndex, 10);
    }
  }
  getTestId() {
    return this.testId;
  }
  createGreeting(title, micRequired, cameraRequired) {
    const titleElement = createElement("div", "title", titleStyle, title);
    const descriptionElement = createElement("div", "description", descriptionStyle, `Welcome, you're here to help us improve, not to be judged. Your insights matter!

 We're recording this browser tab to learn from your experience.
 Please enable mic and camera if asked, to give us a complete picture.`);
    const buttonElement = createElement("div", "button", buttonStyle, "Read guidelines to begin");
    this.removeGreeting = () => {
      if (micRequired || cameraRequired) {
        void this.userRecorder.startRecording(30, Quality.Standard, micRequired, cameraRequired);
      }
      this.container.removeChild(buttonElement);
      this.container.removeChild(descriptionElement);
      this.container.removeChild(titleElement);
      return false;
    };
    buttonElement.onclick = () => {
      var _a3, _b2, _c, _d;
      this.removeGreeting();
      const durations = (_a3 = this.signalManager) == null ? void 0 : _a3.getDurations();
      if (durations && this.signalManager) {
        durations.testStart = this.app.timestamp();
        this.signalManager.setDurations(durations);
      }
      void ((_b2 = this.signalManager) == null ? void 0 : _b2.signalTest("begin"));
      this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
      Object.assign(this.container.style, containerWidgetStyle);
      this.showWidget(((_c = this.test) == null ? void 0 : _c.guidelines) || "", ((_d = this.test) == null ? void 0 : _d.tasks) || []);
    };
    this.container.append(titleElement, descriptionElement, buttonElement);
    this.bg.appendChild(this.container);
    document.body.appendChild(this.bg);
  }
  showWidget(guidelines, tasks, inProgress) {
    this.container.innerHTML = "";
    Object.assign(this.bg.style, {
      position: "fixed",
      zIndex: 99999999999999,
      right: "8px",
      left: "unset",
      width: "fit-content",
      top: "8px",
      height: "fit-content",
      background: "unset",
      display: "unset",
      alignItems: "unset",
      justifyContent: "unset"
    });
    const titleSection = this.createTitleSection();
    this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
    Object.assign(this.container.style, containerWidgetStyle);
    const descriptionSection = this.createDescriptionSection(guidelines);
    const tasksSection = this.createTasksSection(tasks);
    const stopButton = createElement("div", "stop_bn_or", stopWidgetStyle, "Abort Session");
    const stopContainer = createElement("div", "stop_ct_or", { fontSize: "13px!important" });
    stopContainer.style.fontSize = "13px";
    stopContainer.append(stopButton);
    this.container.append(titleSection, descriptionSection, tasksSection, stopContainer);
    this.taskSection = tasksSection;
    this.descriptionSection = descriptionSection;
    this.stopButton = stopButton;
    this.stopButtonContainer = stopContainer;
    stopButton.onclick = () => {
      var _a3;
      this.userRecorder.discard();
      void ((_a3 = this.signalManager) == null ? void 0 : _a3.signalTest("skipped"));
      document.body.removeChild(this.bg);
      window.close();
    };
    if (!inProgress) {
      this.hideTaskSection();
    } else {
      this.toggleDescriptionVisibility();
    }
  }
  createTitleSection() {
    var _a3;
    const title = createElement("div", "title", titleWidgetStyle);
    const leftIcon = generateGrid();
    const titleText = createElement("div", "title_text", {
      maxWidth: "19rem",
      overflow: "hidden",
      textOverflow: "ellipsis",
      width: "100%",
      fontSize: 16,
      lineHeight: "auto",
      cursor: "pointer"
    }, (_a3 = this.test) == null ? void 0 : _a3.title);
    const rightIcon = generateChevron();
    title.append(leftIcon, titleText, rightIcon);
    const toggleWidget = (isVisible) => {
      this.widgetVisible = isVisible;
      this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
      Object.assign(this.container.style, this.widgetVisible ? containerWidgetStyle : { border: "none", background: "none", padding: 0 });
      if (this.taskSection) {
        Object.assign(this.taskSection.style, this.widgetVisible ? descriptionWidgetStyle : { display: "none" });
      }
      if (this.descriptionSection) {
        Object.assign(this.descriptionSection.style, this.widgetVisible ? descriptionWidgetStyle : { display: "none" });
      }
      if (this.endSection) {
        Object.assign(this.endSection.style, this.widgetVisible ? descriptionWidgetStyle : { display: "none" });
      }
      if (this.stopButton) {
        Object.assign(this.stopButton.style, this.widgetVisible ? stopWidgetStyle : { display: "none" });
      }
      return isVisible;
    };
    const collapseWidget = () => {
      Object.assign(rightIcon.style, {
        transform: this.widgetVisible ? "rotate(0deg)" : "rotate(180deg)"
      });
      toggleWidget(!this.widgetVisible);
    };
    titleText.onclick = collapseWidget;
    rightIcon.onclick = collapseWidget;
    attachDND(this.bg, leftIcon);
    this.collapseWidget = () => toggleWidget(false);
    return title;
  }
  createDescriptionSection(guidelines) {
    const section = createElement("div", "description_section_or", descriptionWidgetStyle);
    const titleContainer = createElement("div", "description_s_title_or", sectionTitleStyle);
    const title = createElement("div", "title", {
      fontSize: 13,
      fontWeight: 500,
      lineHeight: "auto"
    }, "Introduction & Guidelines");
    const icon = createElement("div", "icon", symbolIcon, "-");
    const content = createElement("div", "content", contentStyle);
    const descriptionC = createElement("div", "text_description", {
      maxHeight: "250px",
      overflowY: "auto",
      whiteSpace: "pre-wrap",
      fontSize: 13,
      color: "#454545",
      lineHeight: "auto"
    });
    descriptionC.innerHTML = guidelines;
    const button = createElement("div", "button_begin_or", buttonWidgetStyle, "Begin Test");
    titleContainer.append(title, icon);
    content.append(descriptionC, button);
    section.append(titleContainer, content);
    const toggleDescriptionVisibility = () => {
      this.widgetGuidelinesVisible = !this.widgetGuidelinesVisible;
      icon.textContent = this.widgetGuidelinesVisible ? "-" : "+";
      Object.assign(content.style, this.widgetGuidelinesVisible ? contentStyle : { display: "none" });
    };
    titleContainer.onclick = toggleDescriptionVisibility;
    this.toggleDescriptionVisibility = () => {
      this.widgetGuidelinesVisible = false;
      icon.textContent = this.widgetGuidelinesVisible ? "-" : "+";
      Object.assign(content.style, this.widgetGuidelinesVisible ? contentStyle : { display: "none" });
      content.removeChild(button);
    };
    button.onclick = () => {
      var _a3, _b2, _c;
      toggleDescriptionVisibility();
      if (this.test) {
        const durations = (_a3 = this.signalManager) == null ? void 0 : _a3.getDurations();
        const taskDurationInd = durations ? durations.tasks.findIndex((t) => this.test && t.taskId === this.test.tasks[0].task_id) : null;
        if (durations && taskDurationInd === -1) {
          durations.tasks.push({
            taskId: this.test.tasks[0].task_id,
            started: this.app.timestamp()
          });
          (_b2 = this.signalManager) == null ? void 0 : _b2.setDurations(durations);
        }
        void ((_c = this.signalManager) == null ? void 0 : _c.signalTask(this.test.tasks[0].task_id, "begin"));
      }
      this.showTaskSection();
      content.removeChild(button);
    };
    return section;
  }
  createTasksSection(tasks) {
    this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
    Object.assign(this.container.style, containerWidgetStyle);
    const section = createElement("div", "task_section_or", descriptionWidgetStyle);
    const titleContainer = createElement("div", "description_t_title_or", sectionTitleStyle);
    const title = createElement("div", "title", {
      fontSize: "13px",
      fontWeight: "500",
      lineHeight: "auto"
    }, "Tasks");
    const icon = createElement("div", "icon", symbolIcon, "-");
    const content = createElement("div", "content", contentStyle);
    const pagination = createElement("div", "pagination", paginationStyle);
    const taskCard = createElement("div", "taskCard", taskDescriptionCard);
    const taskText = createElement("div", "taskText", taskTextStyle);
    const taskDescription = createElement("div", "taskDescription", taskDescriptionStyle);
    const taskButtons = createElement("div", "taskButtons", taskButtonsRow);
    const inputTitle = createElement("div", "taskText", taskTextStyle);
    inputTitle.textContent = "Your answer";
    const inputArea = createElement("textarea", "taskDescription", {
      resize: "vertical"
    });
    const inputContainer = createElement("div", "inputArea", taskDescriptionCard);
    inputContainer.append(inputTitle, inputArea);
    const closePanelButton = createElement("div", "closePanelButton", taskButtonStyle, "Collapse Panel");
    const nextButton = createElement("div", "nextButton", taskButtonBorderedStyle, "Done, Next");
    titleContainer.append(title, icon);
    taskCard.append(taskText, taskDescription);
    taskButtons.append(closePanelButton, nextButton);
    content.append(pagination, taskCard, inputContainer, taskButtons);
    section.append(titleContainer, content);
    const updateTaskContent = () => {
      const task = tasks[this.currentTaskIndex];
      taskText.textContent = task.title;
      taskDescription.textContent = task.description;
      if (task.allow_typing) {
        inputContainer.style.display = "flex";
      } else {
        inputContainer.style.display = "none";
      }
    };
    tasks.forEach((_, index2) => {
      const pageNumber = createElement("span", `or_task_${index2}`, {
        outline: "1px solid #efefef",
        fontSize: "13px",
        height: "24px",
        width: "24px",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "6.25em"
      }, (index2 + 1).toString());
      pageNumber.id = `or_task_${index2}`;
      pagination.append(pageNumber);
    });
    const toggleTasksVisibility = () => {
      this.widgetTasksVisible = !this.widgetTasksVisible;
      icon.textContent = this.widgetTasksVisible ? "-" : "+";
      Object.assign(content.style, this.widgetTasksVisible ? contentStyle : { display: "none" });
    };
    this.hideTaskSection = () => {
      icon.textContent = "+";
      Object.assign(content.style, {
        display: "none"
      });
      this.widgetTasksVisible = false;
      return false;
    };
    this.showTaskSection = () => {
      icon.textContent = "-";
      Object.assign(content.style, contentStyle);
      this.widgetTasksVisible = true;
      return true;
    };
    const highlightActive = () => {
      const activeTaskEl = document.getElementById(`or_task_${this.currentTaskIndex}`);
      if (activeTaskEl) {
        Object.assign(activeTaskEl.style, taskNumberActive);
      }
      for (let i = 0; i < this.currentTaskIndex; i++) {
        const taskEl = document.getElementById(`or_task_${i}`);
        if (taskEl) {
          Object.assign(taskEl.style, taskNumberDone);
        }
      }
    };
    titleContainer.onclick = toggleTasksVisibility;
    closePanelButton.onclick = this.collapseWidget;
    nextButton.onclick = () => {
      var _a3, _b2, _c, _d;
      const textAnswer = tasks[this.currentTaskIndex].allow_typing ? inputArea.value : void 0;
      inputArea.value = "";
      void ((_a3 = this.signalManager) == null ? void 0 : _a3.signalTask(tasks[this.currentTaskIndex].task_id, "done", textAnswer));
      if (this.currentTaskIndex < tasks.length - 1) {
        this.currentTaskIndex++;
        updateTaskContent();
        const durations = (_b2 = this.signalManager) == null ? void 0 : _b2.getDurations();
        if (durations && durations.tasks.findIndex((t) => t.taskId === tasks[this.currentTaskIndex].task_id) === -1) {
          durations.tasks.push({
            taskId: tasks[this.currentTaskIndex].task_id,
            started: this.app.timestamp()
          });
          (_c = this.signalManager) == null ? void 0 : _c.setDurations(durations);
        }
        void ((_d = this.signalManager) == null ? void 0 : _d.signalTask(tasks[this.currentTaskIndex].task_id, "begin"));
        highlightActive();
      } else {
        this.showEndSection();
      }
      this.app.localStorage.setItem("or_uxt_task_index", this.currentTaskIndex.toString());
    };
    setTimeout(() => {
      const firstTaskEl = document.getElementById("or_task_0");
      if (firstTaskEl) {
        Object.assign(firstTaskEl.style, taskNumberActive);
      }
      updateTaskContent();
      highlightActive();
    }, 1);
    return section;
  }
  showEndSection() {
    var _a3, _b2, _c, _d;
    let isLoading = true;
    void ((_a3 = this.signalManager) == null ? void 0 : _a3.signalTest("done"));
    const section = createElement("div", "end_section_or", endSectionStyle);
    const title = createElement("div", "end_title_or", {
      fontSize: "1.25rem",
      fontWeight: "500"
    }, "Thank you! ");
    const description = createElement("div", "end_description_or", {}, ((_b2 = this.test) == null ? void 0 : _b2.conclusion) ?? "Thank you for participating in our usability test. Your feedback has been captured and will be used to enhance our website. \n\nWe appreciate your time and valuable input.");
    const button = createElement("div", "end_button_or", buttonWidgetStyle, "Submitting Feedback");
    const spinner = createSpinner();
    button.appendChild(spinner);
    if (((_c = this.test) == null ? void 0 : _c.reqMic) || ((_d = this.test) == null ? void 0 : _d.reqCamera)) {
      void this.userRecorder.sendToAPI().then(() => {
        button.removeChild(spinner);
        button.textContent = "End Session";
        isLoading = false;
      }).catch((err2) => {
        console.error(err2);
        button.removeChild(spinner);
        button.textContent = "End Session";
        isLoading = false;
      });
    } else {
      button.removeChild(spinner);
      button.textContent = "End Session";
      isLoading = false;
    }
    if (this.taskSection) {
      this.container.removeChild(this.taskSection);
    }
    if (this.descriptionSection) {
      this.container.removeChild(this.descriptionSection);
    }
    if (this.stopButton && this.stopButtonContainer) {
      this.container.removeChild(this.stopButtonContainer);
    }
    button.onclick = () => {
      if (isLoading)
        return;
      window.close();
      document.body.removeChild(this.bg);
    };
    section.append(title, description, button);
    this.endSection = section;
    this.container.append(section);
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/guards.js
function isNode(sth) {
  return !!sth && sth.nodeType != null;
}
function isSVGElement(node) {
  return node.namespaceURI === "http://www.w3.org/2000/svg";
}
function isElementNode(node) {
  return node.nodeType === Node.ELEMENT_NODE;
}
function isCommentNode(node) {
  return node.nodeType === Node.COMMENT_NODE;
}
function isTextNode(node) {
  return node.nodeType === Node.TEXT_NODE;
}
function isDocument(node) {
  return node.nodeType === Node.DOCUMENT_NODE;
}
function isRootNode(node) {
  return node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
function hasTag(el, tagName2) {
  return el.localName === tagName2;
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/canvas.js
var CanvasRecorder = class {
  constructor(app, options) {
    this.app = app;
    this.options = options;
    this.snapshots = {};
    this.intervals = [];
    this.restartTracking = () => {
      this.clear();
      this.app.nodes.scanTree(this.captureCanvas);
    };
    this.captureCanvas = (node) => {
      const id2 = this.app.nodes.getID(node);
      if (!id2 || !hasTag(node, "canvas")) {
        return;
      }
      const isIgnored2 = this.app.sanitizer.isObscured(id2) || this.app.sanitizer.isHidden(id2);
      if (isIgnored2 || !hasTag(node, "canvas") || this.snapshots[id2]) {
        return;
      }
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            if (entry.target) {
              if (this.snapshots[id2] && this.snapshots[id2].createdAt) {
                this.snapshots[id2].paused = false;
              } else {
                this.recordCanvas(entry.target, id2);
              }
            } else {
              if (this.snapshots[id2]) {
                this.snapshots[id2].paused = true;
              }
            }
          }
        });
      });
      observer.observe(node);
    };
    this.recordCanvas = (node, id2) => {
      const ts = this.app.timestamp();
      this.snapshots[id2] = {
        images: [],
        createdAt: ts,
        paused: false,
        dummy: document.createElement("canvas")
      };
      const canvasMsg = CanvasNode(id2.toString(), ts);
      this.app.send(canvasMsg);
      const captureFn = (canvas) => {
        captureSnapshot(canvas, this.options.quality, this.snapshots[id2].dummy, this.options.fixedScaling, this.fileExt, (blob) => {
          if (!blob)
            return;
          this.snapshots[id2].images.push({ id: this.app.timestamp(), data: blob });
          if (this.snapshots[id2].images.length > 9) {
            this.sendSnaps(this.snapshots[id2].images, id2, this.snapshots[id2].createdAt);
            this.snapshots[id2].images = [];
          }
        });
      };
      const int = setInterval(() => {
        const cid = this.app.nodes.getID(node);
        const canvas = cid ? this.app.nodes.getNode(cid) : void 0;
        if (!canvas || !hasTag(canvas, "canvas") || canvas !== node) {
          this.app.debug.log("Canvas element not in sync");
          clearInterval(int);
        } else {
          if (!this.snapshots[id2].paused) {
            if (this.options.useAnimationFrame) {
              requestAnimationFrame(() => {
                captureFn(canvas);
              });
            } else {
              captureFn(canvas);
            }
          }
        }
      }, this.interval);
      this.intervals.push(int);
    };
    this.fileExt = options.fileExt ?? "webp";
    this.interval = 1e3 / options.fps;
  }
  startTracking() {
    setTimeout(() => {
      this.app.nodes.scanTree(this.captureCanvas);
      this.app.nodes.attachNodeCallback((node) => {
        this.captureCanvas(node);
      });
    }, 500);
  }
  sendSnaps(images, canvasId, createdAt) {
    if (Object.keys(this.snapshots).length === 0) {
      return;
    }
    const formData = new FormData();
    images.forEach((snapshot) => {
      const blob = snapshot.data;
      if (!blob)
        return;
      formData.append("snapshot", blob, `${createdAt}_${canvasId}_${snapshot.id}.${this.fileExt}`);
      if (this.options.isDebug) {
        saveImageData(blob, `${createdAt}_${canvasId}_${snapshot.id}.${this.fileExt}`);
      }
    });
    fetch(this.app.options.ingestPoint + "/v1/web/images", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.app.session.getSessionToken() ?? ""}`
      },
      body: formData
    }).then(() => {
      return true;
    }).catch((e) => {
      this.app.debug.error("error saving canvas", e);
    });
  }
  clear() {
    this.intervals.forEach((int) => clearInterval(int));
    this.snapshots = {};
  }
};
var qualityInt = {
  low: 0.35,
  medium: 0.55,
  high: 0.8
};
function captureSnapshot(canvas, quality = "medium", dummy, fixedScaling = false, fileExt, onBlob) {
  const imageFormat = `image/${fileExt}`;
  if (fixedScaling) {
    const canvasScaleRatio = window.devicePixelRatio || 1;
    dummy.width = canvas.width / canvasScaleRatio;
    dummy.height = canvas.height / canvasScaleRatio;
    const ctx = dummy.getContext("2d");
    if (!ctx) {
      return "";
    }
    ctx.clearRect(0, 0, dummy.width, dummy.height);
    ctx.drawImage(canvas, 0, 0, dummy.width, dummy.height);
    dummy.toBlob(onBlob, imageFormat, qualityInt[quality]);
  } else {
    canvas.toBlob(onBlob, imageFormat, qualityInt[quality]);
  }
}
function saveImageData(imageDataBlob, name) {
  const imageDataUrl = URL.createObjectURL(imageDataBlob);
  const link = document.createElement("a");
  link.href = imageDataUrl;
  link.download = name;
  link.style.display = "none";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
var canvas_default = CanvasRecorder;

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/logger.js
var LogLevel = {
  Verbose: 5,
  Log: 4,
  Warnings: 3,
  Errors: 2,
  Silent: 0
};
var Logger = class {
  constructor(debugLevel = LogLevel.Silent) {
    this.shouldLog = (level) => {
      return this.level >= level;
    };
    this.log = (...args) => {
      if (this.shouldLog(LogLevel.Log)) {
        console.log(...args);
      }
    };
    this.warn = (...args) => {
      if (this.shouldLog(LogLevel.Warnings)) {
        console.warn(...args);
      }
    };
    this.error = (...args) => {
      if (this.shouldLog(LogLevel.Errors)) {
        console.error(...args);
      }
    };
    this.level = debugLevel;
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/nodes.js
var Nodes = class {
  constructor(node_id) {
    this.node_id = node_id;
    this.nodes = [];
    this.totalNodeAmount = 0;
    this.nodeCallbacks = [];
    this.elementListeners = /* @__PURE__ */ new Map();
    this.nextNodeId = 0;
    this.scanTree = (cb) => {
      this.nodes.forEach((node) => cb(node));
    };
  }
  syntheticMode(frameOrder) {
    const maxSafeNumber = 9007199254740900;
    const placeholderSize = 99999999;
    const nextFrameId = placeholderSize * frameOrder;
    if (nextFrameId > maxSafeNumber) {
      throw new Error("Placeholder id overflow");
    }
    this.nextNodeId = nextFrameId;
  }
  // Attached once per Tracker instance
  attachNodeCallback(nodeCallback) {
    this.nodeCallbacks.push(nodeCallback);
  }
  attachNodeListener(node, type, listener, useCapture = true) {
    const id2 = this.getID(node);
    if (id2 === void 0) {
      return;
    }
    createEventListener(node, type, listener, useCapture);
    let listeners = this.elementListeners.get(id2);
    if (listeners === void 0) {
      listeners = [];
      this.elementListeners.set(id2, listeners);
    }
    listeners.push([type, listener, useCapture]);
  }
  registerNode(node) {
    let id2 = node[this.node_id];
    const isNew = id2 === void 0;
    if (isNew) {
      id2 = this.nextNodeId;
      this.totalNodeAmount++;
      this.nextNodeId++;
      this.nodes[id2] = node;
      node[this.node_id] = id2;
    }
    return [id2, isNew];
  }
  unregisterNode(node) {
    const id2 = node[this.node_id];
    if (id2 !== void 0) {
      ;
      node[this.node_id] = void 0;
      delete node[this.node_id];
      delete this.nodes[id2];
      const listeners = this.elementListeners.get(id2);
      if (listeners !== void 0) {
        this.elementListeners.delete(id2);
        listeners.forEach((listener) => deleteEventListener(node, listener[0], listener[1], listener[2]));
      }
      this.totalNodeAmount--;
    }
    return id2;
  }
  cleanTree() {
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      if (node && !document.contains(node)) {
        this.unregisterNode(node);
      }
    }
  }
  callNodeCallbacks(node, isStart) {
    this.nodeCallbacks.forEach((cb) => cb(node, isStart));
  }
  getID(node) {
    if (!node)
      return void 0;
    return node[this.node_id];
  }
  getNode(id2) {
    return this.nodes[id2];
  }
  getNodeCount() {
    return this.totalNodeAmount;
  }
  clear() {
    for (let id2 = 0; id2 < this.nodes.length; id2++) {
      const node = this.nodes[id2];
      if (!node) {
        continue;
      }
      this.unregisterNode(node);
    }
    this.nextNodeId = 0;
    this.nodes.length = 0;
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/observer/observer.js
function isIgnored(node) {
  if (isCommentNode(node)) {
    return true;
  }
  if (isTextNode(node)) {
    return false;
  }
  if (!isElementNode(node)) {
    return true;
  }
  const tag = node.tagName.toUpperCase();
  if (tag === "LINK") {
    const rel = node.getAttribute("rel");
    const as = node.getAttribute("as");
    return !((rel == null ? void 0 : rel.includes("stylesheet")) || as === "style" || as === "font");
  }
  return tag === "SCRIPT" || tag === "NOSCRIPT" || tag === "META" || tag === "TITLE" || tag === "BASE";
}
function isObservable(node) {
  if (isRootNode(node)) {
    return true;
  }
  return !isIgnored(node);
}
var RecentsType;
(function(RecentsType2) {
  RecentsType2[RecentsType2["New"] = 0] = "New";
  RecentsType2[RecentsType2["Removed"] = 1] = "Removed";
  RecentsType2[RecentsType2["Changed"] = 2] = "Changed";
})(RecentsType || (RecentsType = {}));
var Observer = class {
  constructor(app, isTopContext = false) {
    this.app = app;
    this.isTopContext = isTopContext;
    this.commited = [];
    this.recents = /* @__PURE__ */ new Map();
    this.indexes = [];
    this.attributesMap = /* @__PURE__ */ new Map();
    this.textSet = /* @__PURE__ */ new Set();
    this.observer = createMutationObserver(this.app.safe((mutations) => {
      for (const mutation of mutations) {
        const target = mutation.target;
        const type = mutation.type;
        if (!isObservable(target)) {
          continue;
        }
        if (type === "childList") {
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            if (isObservable(mutation.removedNodes[i])) {
              this.bindNode(mutation.removedNodes[i]);
            }
          }
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            this.bindTree(mutation.addedNodes[i]);
          }
          continue;
        }
        const id2 = this.app.nodes.getID(target);
        if (id2 === void 0) {
          continue;
        }
        if (!this.recents.has(id2)) {
          this.recents.set(id2, RecentsType.Changed);
        }
        if (type === "attributes") {
          const name = mutation.attributeName;
          if (name === null) {
            continue;
          }
          let attr2 = this.attributesMap.get(id2);
          if (attr2 === void 0) {
            this.attributesMap.set(id2, attr2 = /* @__PURE__ */ new Set());
          }
          attr2.add(name);
          continue;
        }
        if (type === "characterData") {
          this.textSet.add(id2);
          continue;
        }
      }
      this.commitNodes();
    }));
  }
  clear() {
    this.commited.length = 0;
    this.recents.clear();
    this.indexes.length = 1;
    this.attributesMap.clear();
    this.textSet.clear();
  }
  sendNodeAttribute(id2, node, name, value) {
    if (isSVGElement(node)) {
      if (name.substr(0, 6) === "xlink:") {
        name = name.substr(6);
      }
      if (value === null) {
        this.app.send(RemoveNodeAttribute(id2, name));
      } else if (name === "href") {
        if (value.length > 1e5) {
          value = "";
        }
        this.app.send(SetNodeAttributeURLBased(id2, name, value, this.app.getBaseHref()));
      } else {
        this.app.attributeSender.sendSetAttribute(id2, name, value);
      }
      return;
    }
    if (name === "src" || name === "srcset" || name === "integrity" || name === "crossorigin" || name === "autocomplete" || name.substr(0, 2) === "on") {
      return;
    }
    if (name === "value" && hasTag(node, "input") && node.type !== "button" && node.type !== "reset" && node.type !== "submit") {
      return;
    }
    if (value === null) {
      this.app.send(RemoveNodeAttribute(id2, name));
      return;
    }
    if (name === "style" || name === "href" && hasTag(node, "link")) {
      this.app.send(SetNodeAttributeURLBased(id2, name, value, this.app.getBaseHref()));
      return;
    }
    if (name === "href" || value.length > 1e5) {
      value = "";
    }
    this.app.attributeSender.sendSetAttribute(id2, name, value);
  }
  sendNodeData(id2, parentElement, data) {
    if (hasTag(parentElement, "style")) {
      this.app.send(SetCSSDataURLBased(id2, data, this.app.getBaseHref()));
      return;
    }
    data = this.app.sanitizer.sanitize(id2, data);
    this.app.send(SetNodeData(id2, data));
  }
  bindNode(node) {
    const [id2, isNew] = this.app.nodes.registerNode(node);
    if (isNew) {
      this.recents.set(id2, RecentsType.New);
    } else if (this.recents.get(id2) !== RecentsType.New) {
      this.recents.set(id2, RecentsType.Removed);
    }
  }
  bindTree(node) {
    if (!isObservable(node)) {
      return;
    }
    this.bindNode(node);
    const walker = document.createTreeWalker(
      node,
      NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node2) => {
          if (this.app.nodes.getID(node2) !== void 0) {
            this.app.debug.error("! Node is already bound", node2);
          }
          return isIgnored(node2) || this.app.nodes.getID(node2) !== void 0 ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
        }
      },
      // @ts-ignore
      false
    );
    while (walker.nextNode()) {
      this.bindNode(walker.currentNode);
    }
  }
  unbindTree(node) {
    const id2 = this.app.nodes.unregisterNode(node);
    if (id2 !== void 0 && this.recents.get(id2) === RecentsType.Removed) {
      this.app.send(RemoveNode(id2));
      const walker = document.createTreeWalker(
        node,
        NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT,
        {
          acceptNode: (node2) => isIgnored(node2) || this.app.nodes.getID(node2) === void 0 ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT
        },
        // @ts-ignore
        false
      );
      let removed = 0;
      const totalBeforeRemove = this.app.nodes.getNodeCount();
      while (walker.nextNode()) {
        removed += 1;
        this.app.nodes.unregisterNode(walker.currentNode);
      }
      const removedPercent = Math.floor(removed / totalBeforeRemove * 100);
      if (removedPercent > 30) {
        this.app.send(UnbindNodes(removedPercent));
      }
    }
  }
  // A top-consumption function on the infinite lists test. (~1% of performance resources)
  _commitNode(id2, node) {
    if (isRootNode(node)) {
      return true;
    }
    const parent = node.parentNode;
    let parentID;
    if (!hasTag(node, "html") || !this.isTopContext) {
      if (parent === null) {
        this.unbindTree(node);
        return false;
      }
      parentID = this.app.nodes.getID(parent);
      if (parentID === void 0) {
        this.unbindTree(node);
        return false;
      }
      if (!this.commitNode(parentID)) {
        this.unbindTree(node);
        return false;
      }
      this.app.sanitizer.handleNode(id2, parentID, node);
      if (this.app.sanitizer.isHidden(parentID)) {
        return false;
      }
    }
    let sibling = node.previousSibling;
    while (sibling !== null) {
      const siblingID = this.app.nodes.getID(sibling);
      if (siblingID !== void 0) {
        this.commitNode(siblingID);
        this.indexes[id2] = this.indexes[siblingID] + 1;
        break;
      }
      sibling = sibling.previousSibling;
    }
    if (sibling === null) {
      this.indexes[id2] = 0;
    }
    const recentsType = this.recents.get(id2);
    const isNew = recentsType === RecentsType.New;
    const index2 = this.indexes[id2];
    if (index2 === void 0) {
      throw "commitNode: missing node index";
    }
    if (isNew) {
      if (isElementNode(node)) {
        let el = node;
        if (parentID !== void 0) {
          if (this.app.sanitizer.isHidden(id2)) {
            const width = el.clientWidth;
            const height = el.clientHeight;
            el = node.cloneNode();
            el.style.width = `${width}px`;
            el.style.height = `${height}px`;
          }
          this.app.send(CreateElementNode(id2, parentID, index2, el.tagName, isSVGElement(node)));
        }
        for (let i = 0; i < el.attributes.length; i++) {
          const attr3 = el.attributes[i];
          this.sendNodeAttribute(id2, el, attr3.nodeName, attr3.value);
        }
      } else if (isTextNode(node)) {
        this.app.send(CreateTextNode(id2, parentID, index2));
        this.sendNodeData(id2, parent, node.data);
      }
      return true;
    }
    if (recentsType === RecentsType.Removed && parentID !== void 0) {
      this.app.send(MoveNode(id2, parentID, index2));
    }
    const attr2 = this.attributesMap.get(id2);
    if (attr2 !== void 0) {
      if (!isElementNode(node)) {
        throw "commitNode: node is not an element";
      }
      for (const name of attr2) {
        this.sendNodeAttribute(id2, node, name, node.getAttribute(name));
      }
    }
    if (this.textSet.has(id2)) {
      if (!isTextNode(node)) {
        throw "commitNode: node is not a text";
      }
      this.sendNodeData(id2, parent, node.data);
    }
    return true;
  }
  commitNode(id2) {
    const node = this.app.nodes.getNode(id2);
    if (node === void 0) {
      return false;
    }
    const cmt = this.commited[id2];
    if (cmt !== void 0) {
      return cmt;
    }
    return this.commited[id2] = this._commitNode(id2, node);
  }
  commitNodes(isStart = false) {
    let node;
    this.recents.forEach((type, id2) => {
      this.commitNode(id2);
      if (type === RecentsType.New && (node = this.app.nodes.getNode(id2))) {
        this.app.nodes.callNodeCallbacks(node, isStart);
      }
    });
    this.clear();
  }
  // ISSSUE (nodeToBinde should be the same as node in all cases. Look at the comment about 0-node at the beginning of the file.)
  // TODO: use one observer instance for all iframes/shadowRoots (composition instiad of inheritance)
  observeRoot(node, beforeCommit, nodeToBind = node) {
    this.observer.observe(node, {
      childList: true,
      attributes: true,
      characterData: true,
      subtree: true,
      attributeOldValue: false,
      characterDataOldValue: false
    });
    this.bindTree(nodeToBind);
    beforeCommit(this.app.nodes.getID(node));
    this.commitNodes(true);
  }
  disconnect() {
    this.observer.disconnect();
    this.clear();
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/observer/iframe_observer.js
var IFrameObserver = class extends Observer {
  observe(iframe) {
    const doc = iframe.contentDocument;
    const hostID = this.app.nodes.getID(iframe);
    if (!doc || hostID === void 0) {
      return;
    }
    this.observeRoot(doc, (docID) => {
      if (docID === void 0) {
        this.app.debug.log("OpenReplay: Iframe document not bound");
        return;
      }
      this.app.send(CreateIFrameDocument(hostID, docID));
    });
  }
  syntheticObserve(selfId, doc) {
    this.observeRoot(doc, (docID) => {
      if (docID === void 0) {
        this.app.debug.log("OpenReplay: Iframe document not bound");
        return;
      }
      this.app.send(CreateIFrameDocument(selfId, docID));
    });
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/observer/shadow_root_observer.js
var ShadowRootObserver = class extends Observer {
  observe(el) {
    const shRoot = el.shadowRoot;
    const hostID = this.app.nodes.getID(el);
    if (!shRoot || hostID === void 0) {
      return;
    }
    this.observeRoot(shRoot, (rootID) => {
      if (rootID === void 0) {
        this.app.debug.error("OpenReplay: Shadow Root was not bound");
        return;
      }
      this.app.send(CreateIFrameDocument(hostID, rootID));
    });
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/observer/iframe_offsets.js
var IFrameOffsets = class {
  constructor() {
    this.states = /* @__PURE__ */ new Map();
  }
  calcOffset(state) {
    let parLeft = 0, parTop = 0;
    if (state.parent) {
      ;
      [parLeft, parTop] = this.calcOffset(state.parent);
    }
    if (!state.offset) {
      const { left: left2, top: top2 } = state.iFrame.getBoundingClientRect();
      state.offset = [left2, top2];
    }
    const [left, top] = state.offset;
    return [parLeft + left, parTop + top];
  }
  getDocumentOffset(doc) {
    const state = this.states.get(doc);
    if (!state) {
      return [0, 0];
    }
    return this.calcOffset(state);
  }
  observe(iFrame) {
    var _a3;
    const doc = iFrame.contentDocument;
    if (!doc) {
      return;
    }
    const parentDoc = iFrame.ownerDocument;
    const parentState = this.states.get(parentDoc);
    const state = {
      offset: null,
      iFrame,
      parent: parentState || null,
      clear: () => {
        var _a4;
        parentDoc.removeEventListener("scroll", invalidateOffset);
        (_a4 = parentDoc.defaultView) == null ? void 0 : _a4.removeEventListener("resize", invalidateOffset);
      }
    };
    const invalidateOffset = () => {
      state.offset = null;
    };
    parentDoc.addEventListener("scroll", invalidateOffset);
    (_a3 = parentDoc.defaultView) == null ? void 0 : _a3.addEventListener("resize", invalidateOffset);
    this.states.set(doc, state);
  }
  clear() {
    this.states.forEach((s) => s.clear());
    this.states.clear();
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/observer/top_observer.js
var attachShadowNativeFn = IN_BROWSER ? Element.prototype.attachShadow : () => new ShadowRoot();
var TopObserver = class extends Observer {
  constructor(app, options) {
    super(app, true);
    this.iframeOffsets = new IFrameOffsets();
    this.contextCallbacks = [];
    this.contextsSet = /* @__PURE__ */ new Set();
    this.iframeObservers = [];
    this.shadowRootObservers = [];
    this.options = Object.assign({
      captureIFrames: true
    }, options);
    this.app.nodes.attachNodeCallback((node) => {
      if (hasTag(node, "iframe") && (this.options.captureIFrames && !hasOpenreplayAttribute(node, "obscured") || hasOpenreplayAttribute(node, "capture"))) {
        this.handleIframe(node);
      }
    });
    this.app.nodes.attachNodeCallback((node) => {
      if (isElementNode(node) && node.shadowRoot !== null) {
        this.handleShadowRoot(node.shadowRoot);
      }
    });
  }
  attachContextCallback(cb) {
    this.contextCallbacks.push(cb);
  }
  getDocumentOffset(doc) {
    return this.iframeOffsets.getDocumentOffset(doc);
  }
  handleIframe(iframe) {
    let doc = null;
    const handle = this.app.safe(() => setTimeout(() => {
      const id2 = this.app.nodes.getID(iframe);
      if (id2 === void 0) {
        return;
      }
      if (!canAccessIframe(iframe))
        return;
      const currentWin = iframe.contentWindow;
      const currentDoc = iframe.contentDocument;
      if (currentDoc && currentDoc !== doc) {
        const observer = new IFrameObserver(this.app);
        this.iframeObservers.push(observer);
        observer.observe(iframe);
        doc = currentDoc;
        this.iframeOffsets.observe(iframe);
      }
      if (currentWin && // Sometimes currentWin.window is null (not in specification). Such window object is not functional
      currentWin === currentWin.window && !this.contextsSet.has(currentWin)) {
        this.contextsSet.add(currentWin);
        this.contextCallbacks.forEach((cb) => cb(currentWin));
      }
    }, 100));
    iframe.addEventListener("load", handle);
    handle();
  }
  handleShadowRoot(shRoot) {
    const observer = new ShadowRootObserver(this.app);
    this.shadowRootObservers.push(observer);
    observer.observe(shRoot.host);
  }
  observe() {
    const observer = this;
    Element.prototype.attachShadow = function() {
      const shadow = attachShadowNativeFn.apply(this, arguments);
      observer.handleShadowRoot(shadow);
      return shadow;
    };
    this.app.nodes.clear();
    this.observeRoot(window.document, () => {
      this.app.send(CreateDocument());
      this.app.nodes.callNodeCallbacks(document, true);
    }, window.document.documentElement);
  }
  crossdomainObserve(selfId, frameOder) {
    const observer = this;
    Element.prototype.attachShadow = function() {
      const shadow = attachShadowNativeFn.apply(this, arguments);
      observer.handleShadowRoot(shadow);
      return shadow;
    };
    this.app.nodes.clear();
    this.app.nodes.syntheticMode(frameOder);
    const iframeObserver = new IFrameObserver(this.app);
    this.iframeObservers.push(iframeObserver);
    iframeObserver.syntheticObserve(selfId, window.document);
  }
  disconnect() {
    this.iframeOffsets.clear();
    Element.prototype.attachShadow = attachShadowNativeFn;
    this.iframeObservers.forEach((o) => o.disconnect());
    this.iframeObservers = [];
    this.shadowRootObservers.forEach((o) => o.disconnect());
    this.shadowRootObservers = [];
    super.disconnect();
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/sanitizer.js
var SanitizeLevel;
(function(SanitizeLevel2) {
  SanitizeLevel2[SanitizeLevel2["Plain"] = 0] = "Plain";
  SanitizeLevel2[SanitizeLevel2["Obscured"] = 1] = "Obscured";
  SanitizeLevel2[SanitizeLevel2["Hidden"] = 2] = "Hidden";
})(SanitizeLevel || (SanitizeLevel = {}));
var stringWiper = (input) => input.trim().replace(/[^\f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/g, "");
var Sanitizer = class {
  constructor(app, options) {
    this.app = app;
    this.obscured = /* @__PURE__ */ new Set();
    this.hidden = /* @__PURE__ */ new Set();
    this.options = Object.assign({
      obscureTextEmails: true,
      obscureTextNumbers: false
    }, options);
  }
  handleNode(id2, parentID, node) {
    if (this.obscured.has(parentID) || isElementNode(node) && (hasOpenreplayAttribute(node, "masked") || hasOpenreplayAttribute(node, "obscured"))) {
      this.obscured.add(id2);
    }
    if (this.hidden.has(parentID) || isElementNode(node) && (hasOpenreplayAttribute(node, "htmlmasked") || hasOpenreplayAttribute(node, "hidden"))) {
      this.hidden.add(id2);
    }
    if (this.options.domSanitizer !== void 0 && isElementNode(node)) {
      const sanitizeLevel = this.options.domSanitizer(node);
      if (sanitizeLevel === SanitizeLevel.Obscured) {
        this.obscured.add(id2);
      }
      if (sanitizeLevel === SanitizeLevel.Hidden) {
        this.hidden.add(id2);
      }
    }
  }
  sanitize(id2, data) {
    if (this.obscured.has(id2)) {
      return stringWiper(data);
    }
    if (this.options.obscureTextNumbers) {
      data = data.replace(/\d/g, "0");
    }
    if (this.options.obscureTextEmails) {
      data = data.replace(/^\w+([+.-]\w+)*@\w+([.-]\w+)*\.\w{2,3}$/g, (email) => {
        const [name, domain] = email.split("@");
        const [domainName, host] = domain.split(".");
        return `${stars(name)}@${stars(domainName)}.${stars(host)}`;
      });
    }
    return data;
  }
  isObscured(id2) {
    return this.obscured.has(id2);
  }
  isHidden(id2) {
    return this.hidden.has(id2);
  }
  getInnerTextSecure(el) {
    const id2 = this.app.nodes.getID(el);
    if (!id2) {
      return "";
    }
    return this.sanitize(id2, el.innerText);
  }
  clear() {
    this.obscured.clear();
    this.hidden.clear();
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/session.js
var Session = class {
  constructor(app, options) {
    this.app = app;
    this.options = options;
    this.metadata = {};
    this.userID = null;
    this.callbacks = [];
    this.timestamp = 0;
    this.createTabId();
  }
  attachUpdateCallback(cb) {
    this.callbacks.push(cb);
  }
  handleUpdate(newInfo) {
    if (newInfo.userID == null) {
      delete newInfo.userID;
    }
    if (newInfo.sessionID == null) {
      delete newInfo.sessionID;
    }
    this.callbacks.forEach((cb) => cb(newInfo));
  }
  assign(newInfo) {
    if (newInfo.userID !== void 0) {
      this.userID = newInfo.userID;
    }
    if (newInfo.metadata !== void 0) {
      Object.entries(newInfo.metadata).forEach(([k, v]) => this.metadata[k] = v);
    }
    if (newInfo.sessionID !== void 0) {
      this.sessionID = newInfo.sessionID;
    }
    if (newInfo.timestamp !== void 0) {
      this.timestamp = newInfo.timestamp;
    }
    if (newInfo.projectID !== void 0) {
      this.projectID = newInfo.projectID;
    }
    this.handleUpdate(newInfo);
  }
  setMetadata(key, value) {
    this.metadata[key] = value;
    this.handleUpdate({ metadata: { [key]: value } });
  }
  setUserID(userID) {
    this.userID = userID;
    this.handleUpdate({ userID });
  }
  setUserInfo(userInfo) {
    this.userInfo = userInfo;
  }
  getPageNumber() {
    const pageNoStr = this.app.sessionStorage.getItem(this.options.session_pageno_key);
    if (pageNoStr == null) {
      return void 0;
    }
    return parseInt(pageNoStr);
  }
  incPageNo() {
    let pageNo = this.getPageNumber();
    if (pageNo === void 0) {
      pageNo = 0;
    } else {
      pageNo++;
    }
    this.app.sessionStorage.setItem(this.options.session_pageno_key, pageNo.toString());
    return pageNo;
  }
  getSessionToken() {
    return this.app.sessionStorage.getItem(this.options.session_token_key) || void 0;
  }
  setSessionToken(token) {
    this.app.sessionStorage.setItem(this.options.session_token_key, token);
  }
  applySessionHash(hash) {
    const hashParts = decodeURI(hash).split("&");
    let token = hash;
    let pageNoStr = "100500";
    if (hashParts.length == 2) {
      ;
      [pageNoStr, token] = hashParts;
    }
    if (!pageNoStr || !token) {
      return;
    }
    this.app.sessionStorage.setItem(this.options.session_token_key, token);
    this.app.sessionStorage.setItem(this.options.session_pageno_key, pageNoStr);
  }
  getSessionHash() {
    const pageNo = this.getPageNumber();
    const token = this.getSessionToken();
    if (pageNo === void 0 || token === void 0) {
      return;
    }
    return encodeURI(String(pageNo) + "&" + token);
  }
  getTabId() {
    if (!this.tabId)
      this.createTabId();
    return this.tabId;
  }
  regenerateTabId() {
    const randomId = generateRandomId(12);
    this.app.sessionStorage.setItem(this.options.session_tabid_key, randomId);
    this.tabId = randomId;
  }
  createTabId() {
    const localId = this.app.sessionStorage.getItem(this.options.session_tabid_key);
    if (localId) {
      this.tabId = localId;
    } else {
      this.regenerateTabId();
    }
  }
  getInfo() {
    return {
      sessionID: this.sessionID,
      metadata: this.metadata,
      userID: this.userID,
      timestamp: this.timestamp,
      projectID: this.projectID
    };
  }
  reset() {
    this.app.sessionStorage.removeItem(this.options.session_token_key);
    this.metadata = {};
    this.userID = null;
    this.sessionID = void 0;
    this.timestamp = 0;
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/ticker.js
function wrap(callback, n) {
  let t = 0;
  return () => {
    if (t++ >= n) {
      t = 0;
      callback();
    }
  };
}
var Ticker = class {
  constructor(app) {
    this.app = app;
    this.timer = null;
    this.callbacks = [];
  }
  /**
   * @param {Callback} callback - repeated cb
   * @param {number} n - number of turn skips; ticker have a 30 ms cycle
   * @param {boolean} useSafe - using safe wrapper to check if app is active
   * @param {object} thisArg - link to <this>
   * */
  attach(callback, n = 0, useSafe = true, thisArg) {
    if (thisArg) {
      callback = callback.bind(thisArg);
    }
    if (useSafe) {
      callback = this.app.safe(callback);
    }
    this.callbacks.unshift(n ? wrap(callback, n) : callback) - 1;
  }
  start() {
    if (this.timer === null) {
      this.timer = setInterval(() => this.callbacks.forEach((cb) => {
        if (cb)
          cb();
      }), 30);
    }
  }
  stop() {
    if (this.timer !== null) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/index.js
var CANCELED = "canceled";
var uxtStorageKey = "or_uxt_active";
var bufferStorageKey = "or_buffer_1";
var UnsuccessfulStart = (reason) => ({ reason, success: false });
var SuccessfulStart = (body) => ({ ...body, success: true });
var ActivityState;
(function(ActivityState2) {
  ActivityState2[ActivityState2["NotActive"] = 0] = "NotActive";
  ActivityState2[ActivityState2["Starting"] = 1] = "Starting";
  ActivityState2[ActivityState2["Active"] = 2] = "Active";
  ActivityState2[ActivityState2["ColdStart"] = 3] = "ColdStart";
})(ActivityState || (ActivityState = {}));
var DEFAULT_INGEST_POINT = "https://api.openreplay.com/ingest";
function getTimezone() {
  const offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * -1;
  const sign = offset >= 0 ? "+" : "-";
  const hours = Math.floor(Math.abs(offset) / 60);
  const minutes = Math.abs(offset) % 60;
  return `UTC${sign}${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}`;
}
var delay = (ms) => new Promise((res) => setTimeout(res, ms));
var proto = {
  // ask if there are any tabs alive
  ask: "never-gonna-give-you-up",
  // response from another tab
  resp: "never-gonna-let-you-down",
  // regenerating id (copied other tab)
  reg: "never-gonna-run-around-and-desert-you",
  // tracker inside a child iframe
  iframeSignal: "never-gonna-make-you-cry",
  // getting node id for child iframe
  iframeId: "never-gonna-say-goodbye",
  // batch of messages from an iframe window
  iframeBatch: "never-gonna-tell-a-lie-and-hurt-you"
};
var App = class {
  constructor(projectKey, sessionToken, options, signalError, insideIframe) {
    this.signalError = signalError;
    this.insideIframe = insideIframe;
    this.messages = [];
    this.bufferedMessages1 = [];
    this.bufferedMessages2 = [];
    this.startCallbacks = [];
    this.stopCallbacks = [];
    this.commitCallbacks = [];
    this.activityState = ActivityState.NotActive;
    this.version = "14.0.3";
    this.socketMode = false;
    this.compressionThreshold = 24 * 1e3;
    this.bc = null;
    this.canvasRecorder = null;
    this.conditionsManager = null;
    this.canStart = false;
    this.rootId = null;
    this.pageFrames = [];
    this.frameOderNumber = 0;
    this.initialHostName = location.hostname;
    this.startTimeout = null;
    this.coldStartCommitN = 0;
    this.delay = 0;
    this.coldInterval = null;
    this.orderNumber = 0;
    this.coldStartTs = 0;
    this.singleBuffer = false;
    this.onSessionSent = () => {
      return;
    };
    this.restartCanvasTracking = () => {
      var _a3;
      (_a3 = this.canvasRecorder) == null ? void 0 : _a3.restartTracking();
    };
    this.flushBuffer = async (buffer) => {
      return new Promise((res) => {
        let ended = false;
        const messagesBatch = [buffer.shift()];
        while (!ended) {
          const nextMsg = buffer[0];
          if (!nextMsg || nextMsg[0] === 0) {
            ended = true;
          } else {
            messagesBatch.push(buffer.shift());
          }
        }
        this.postToWorker(messagesBatch);
        res(null);
      });
    };
    this.onUxtCb = [];
    this.contextId = Math.random().toString(36).slice(2);
    this.projectKey = projectKey;
    if (Object.keys(options).findIndex((k) => ["fixedCanvasScaling", "disableCanvas"].includes(k)) !== -1) {
      console.warn('Openreplay: canvas options are moving to separate key "canvas" in next update. Please update your configuration.');
      options = {
        ...options,
        canvas: {
          __save_canvas_locally: options.__save_canvas_locally,
          fixedCanvasScaling: options.fixedCanvasScaling,
          disableCanvas: options.disableCanvas
        }
      };
    }
    this.networkOptions = options.network;
    const defaultOptions = {
      revID: "",
      node_id: "__openreplay_id",
      session_token_key: "__openreplay_token",
      session_pageno_key: "__openreplay_pageno",
      session_reset_key: "__openreplay_reset",
      session_tabid_key: "__openreplay_tabid",
      local_uuid_key: "__openreplay_uuid",
      ingestPoint: DEFAULT_INGEST_POINT,
      resourceBaseHref: null,
      __is_snippet: false,
      __debug_report_edp: null,
      __debug__: LogLevel.Silent,
      __save_canvas_locally: false,
      localStorage: null,
      sessionStorage: null,
      disableStringDict: false,
      forceSingleTab: false,
      assistSocketHost: "",
      fixedCanvasScaling: false,
      disableCanvas: false,
      captureIFrames: true,
      obscureTextEmails: true,
      obscureTextNumbers: false,
      crossdomain: {
        parentDomain: "*"
      },
      canvas: {
        disableCanvas: false,
        fixedCanvasScaling: false,
        __save_canvas_locally: false,
        useAnimationFrame: false
      }
    };
    this.options = simpleMerge(defaultOptions, options);
    if (!this.insideIframe && !this.options.forceSingleTab && globalThis && "BroadcastChannel" in globalThis) {
      const host = location.hostname.split(".").slice(-2).join("_");
      this.bc = new BroadcastChannel(`rick_${host}`);
    }
    this.revID = this.options.revID;
    this.localStorage = this.options.localStorage ?? window.localStorage;
    this.sessionStorage = this.options.sessionStorage ?? window.sessionStorage;
    this.sanitizer = new Sanitizer(this, options);
    this.nodes = new Nodes(this.options.node_id);
    this.observer = new TopObserver(this, options);
    this.ticker = new Ticker(this);
    this.ticker.attach(() => this.commit());
    this.debug = new Logger(this.options.__debug__);
    this.session = new Session(this, this.options);
    this.attributeSender = new AttributeSender(this, Boolean(this.options.disableStringDict));
    this.featureFlags = new FeatureFlags(this);
    this.tagWatcher = new tagWatcher_default(this.sessionStorage, this.debug.error, (tag) => {
      this.send(TagTrigger(tag));
    });
    this.session.attachUpdateCallback(({ userID, metadata }) => {
      if (userID != null) {
        this.send(UserID(userID));
      }
      if (metadata != null) {
        Object.entries(metadata).forEach(([key, value]) => this.send(Metadata(key, value)));
      }
    });
    if (sessionToken != null) {
      this.session.applySessionHash(sessionToken);
    }
    this.initWorker();
    const thisTab = this.session.getTabId();
    if (!this.insideIframe) {
      let crossdomainFrameCount = 0;
      const catchIframeMessage = (event) => {
        const { data } = event;
        if (data.line === proto.iframeSignal) {
          const childIframeDomain = data.domain;
          const pageIframes = Array.from(document.querySelectorAll("iframe"));
          this.pageFrames = pageIframes;
          const signalId = async () => {
            let tries = 0;
            while (tries < 10) {
              const id2 = this.checkNodeId(pageIframes, childIframeDomain);
              if (id2) {
                this.waitStarted().then(() => {
                  var _a3;
                  crossdomainFrameCount++;
                  const token = this.session.getSessionToken();
                  const iframeData = {
                    line: proto.iframeId,
                    context: this.contextId,
                    domain: childIframeDomain,
                    id: id2,
                    token,
                    frameOrderNumber: crossdomainFrameCount
                  };
                  this.debug.log("iframe_data", iframeData);
                  (_a3 = event.source) == null ? void 0 : _a3.postMessage(iframeData, "*");
                }).catch(console.error);
                tries = 10;
                break;
              }
              tries++;
              await delay(100);
            }
          };
          void signalId();
        }
        if (data.line === proto.iframeBatch) {
          const msgBatch = data.messages;
          const mappedMessages = msgBatch.map((msg) => {
            if (msg[0] === 20) {
              let fixedMessage = msg;
              this.pageFrames.forEach((frame) => {
                if (frame.dataset.domain === event.data.domain) {
                  const [type, x, y] = msg;
                  const { left, top } = frame.getBoundingClientRect();
                  fixedMessage = [type, x + left, y + top];
                }
              });
              return fixedMessage;
            }
            if (msg[0] === 68) {
              let fixedMessage = msg;
              this.pageFrames.forEach((frame) => {
                if (frame.dataset.domain === event.data.domain) {
                  const [type, id2, hesitationTime, label, selector2, normX, normY] = msg;
                  const { left, top, width, height } = frame.getBoundingClientRect();
                  const contentWidth = document.documentElement.scrollWidth;
                  const contentHeight = document.documentElement.scrollHeight;
                  const fullX = normX / 100 * width + left;
                  const fullY = normY / 100 * height + top;
                  const fixedX = fullX / contentWidth;
                  const fixedY = fullY / contentHeight;
                  fixedMessage = [
                    type,
                    id2,
                    hesitationTime,
                    label,
                    selector2,
                    Math.round(fixedX * 1e3) / 10,
                    Math.round(fixedY * 1e3) / 10
                  ];
                }
              });
              return fixedMessage;
            }
            return msg;
          });
          this.messages.push(...mappedMessages);
        }
      };
      window.addEventListener("message", catchIframeMessage);
      this.attachStopCallback(() => {
        window.removeEventListener("message", catchIframeMessage);
      });
    } else {
      const catchParentMessage = (event) => {
        const { data } = event;
        if (data.line !== proto.iframeId) {
          return;
        }
        this.rootId = data.id;
        this.session.setSessionToken(data.token);
        this.frameOderNumber = data.frameOrderNumber;
        this.debug.log("starting iframe tracking", data);
        this.allowAppStart();
      };
      window.addEventListener("message", catchParentMessage);
      this.attachStopCallback(() => {
        window.removeEventListener("message", catchParentMessage);
      });
      const domain = this.initialHostName;
      window.parent.postMessage({
        line: proto.iframeSignal,
        source: thisTab,
        context: this.contextId,
        domain
      }, "*");
    }
    if (this.bc !== null) {
      this.bc.postMessage({
        line: proto.ask,
        source: thisTab,
        context: this.contextId
      });
      this.startTimeout = setTimeout(() => {
        this.allowAppStart();
      }, 500);
      this.bc.onmessage = (ev) => {
        if (ev.data.context === this.contextId) {
          return;
        }
        if (ev.data.line === proto.resp) {
          const sessionToken2 = ev.data.token;
          this.session.setSessionToken(sessionToken2);
          this.allowAppStart();
        }
        if (ev.data.line === proto.reg) {
          const sessionToken2 = ev.data.token;
          this.session.regenerateTabId();
          this.session.setSessionToken(sessionToken2);
          this.allowAppStart();
        }
        if (ev.data.line === proto.ask) {
          const token = this.session.getSessionToken();
          if (token && this.bc) {
            this.bc.postMessage({
              line: ev.data.source === thisTab ? proto.reg : proto.resp,
              token,
              source: thisTab,
              context: this.contextId
            });
          }
        }
      };
    }
  }
  allowAppStart() {
    this.canStart = true;
    if (this.startTimeout) {
      clearTimeout(this.startTimeout);
      this.startTimeout = null;
    }
  }
  checkNodeId(iframes, domain) {
    for (const iframe of iframes) {
      if (iframe.dataset.domain === domain) {
        return iframe[this.options.node_id];
      }
    }
    return null;
  }
  initWorker() {
    try {
      this.worker = new Worker(URL.createObjectURL(new Blob(['"use strict";class t{constructor(t,s,i,e=10,n=250,h,r){this.onUnauthorised=s,this.onFailure=i,this.MAX_ATTEMPTS_COUNT=e,this.ATTEMPT_TIMEOUT=n,this.onCompress=h,this.pageNo=r,this.attemptsCount=0,this.busy=!1,this.queue=[],this.token=null,this.lastBatchNum=0,this.ingestURL=t+"/v1/web/i",this.isCompressing=void 0!==h}getQueueStatus(){return 0===this.queue.length&&!this.busy}authorise(t){this.token=t,this.busy||this.sendNext()}push(t){if(this.busy||!this.token)this.queue.push(t);else if(this.busy=!0,this.isCompressing&&this.onCompress)this.onCompress(t);else{const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}}sendNext(){const t=this.queue.shift();if(t)if(this.busy=!0,this.isCompressing&&this.onCompress)this.onCompress(t);else{const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}else this.busy=!1}retry(t,s,i){this.attemptsCount>=this.MAX_ATTEMPTS_COUNT?this.onFailure(`Failed to send batch after ${this.attemptsCount} attempts.`):(this.attemptsCount++,setTimeout((()=>this.sendBatch(t,s,i)),this.ATTEMPT_TIMEOUT*this.attemptsCount))}sendBatch(t,s,i){const e=i?.toString().replace(/^([^_]+)_([^_]+).*/,"$1_$2_$3");this.busy=!0;const n={Authorization:`Bearer ${this.token}`};s&&(n["Content-Encoding"]="gzip"),null!==this.token?fetch(`${this.ingestURL}?batch=${this.pageNo??"noPageNum"}_${e??"noBatchNum"}`,{body:t,method:"POST",headers:n,keepalive:t.length<65536}).then((e=>{if(401===e.status)return this.busy=!1,void this.onUnauthorised();e.status>=400?this.retry(t,s,`${i??"noBatchNum"}_network:${e.status}`):(this.attemptsCount=0,this.sendNext())})).catch((e=>{console.warn("OpenReplay:",e),this.retry(t,s,`${i??"noBatchNum"}_reject:${e.message}`)})):setTimeout((()=>{this.sendBatch(t,s,`${i??"noBatchNum"}_newToken`)}),500)}sendCompressed(t){const s=++this.lastBatchNum;this.sendBatch(t,!0,s)}sendUncompressed(t){const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}clean(){this.sendNext(),setTimeout((()=>{this.token=null,this.queue.length=0}),10)}}const s="function"==typeof TextEncoder?new TextEncoder:{encode(t){const s=t.length,i=new Uint8Array(3*s);let e=-1;for(let n=0,h=0,r=0;r!==s;){if(n=t.charCodeAt(r),r+=1,n>=55296&&n<=56319){if(r===s){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;break}if(h=t.charCodeAt(r),!(h>=56320&&h<=57343)){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;continue}if(n=1024*(n-55296)+h-56320+65536,r+=1,n>65535){i[e+=1]=240|n>>>18,i[e+=1]=128|n>>>12&63,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n;continue}}n<=127?i[e+=1]=0|n:n<=2047?(i[e+=1]=192|n>>>6,i[e+=1]=128|63&n):(i[e+=1]=224|n>>>12,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n)}return i.subarray(0,e+1)}};class i{constructor(t){this.size=t,this.offset=0,this.checkpointOffset=0,this.data=new Uint8Array(t)}getCurrentOffset(){return this.offset}checkpoint(){this.checkpointOffset=this.offset}get isEmpty(){return 0===this.offset}skip(t){return this.offset+=t,this.offset<=this.size}set(t,s){this.data.set(t,s)}boolean(t){return this.data[this.offset++]=+t,this.offset<=this.size}uint(t){for((t<0||t>Number.MAX_SAFE_INTEGER)&&(t=0);t>=128;)this.data[this.offset++]=t%256|128,t=Math.floor(t/128);return this.data[this.offset++]=t,this.offset<=this.size}int(t){return t=Math.round(t),this.uint(t>=0?2*t:-2*t-1)}string(t){const i=s.encode(t),e=i.byteLength;return!(!this.uint(e)||this.offset+e>this.size)&&(this.data.set(i,this.offset),this.offset+=e,!0)}reset(){this.offset=0,this.checkpointOffset=0}flush(){const t=this.data.slice(0,this.checkpointOffset);return this.reset(),t}}class e extends i{encode(t){switch(t[0]){case 0:case 11:case 114:case 115:return this.uint(t[1]);case 4:case 44:case 47:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3]);case 5:case 20:case 38:case 70:case 75:case 76:case 77:case 82:return this.uint(t[1])&&this.uint(t[2]);case 6:return this.int(t[1])&&this.int(t[2]);case 7:return!0;case 8:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.string(t[4])&&this.boolean(t[5]);case 9:case 10:case 24:case 51:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3]);case 12:case 61:case 71:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3]);case 13:case 14:case 17:case 50:case 54:return this.uint(t[1])&&this.string(t[2]);case 16:return this.uint(t[1])&&this.int(t[2])&&this.int(t[3]);case 18:return this.uint(t[1])&&this.string(t[2])&&this.int(t[3]);case 19:return this.uint(t[1])&&this.boolean(t[2]);case 21:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8]);case 22:case 27:case 30:case 41:case 45:case 46:case 63:case 64:case 79:return this.string(t[1])&&this.string(t[2]);case 23:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 28:case 29:case 42:case 117:case 118:return this.string(t[1]);case 37:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3]);case 39:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7]);case 40:return this.string(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 48:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.int(t[5]);case 49:return this.int(t[1])&&this.int(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 53:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8]);case 55:return this.boolean(t[1]);case 57:case 60:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 58:case 120:return this.int(t[1]);case 59:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6])&&this.string(t[7]);case 67:case 73:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 68:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6]);case 69:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 78:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 81:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.int(t[4])&&this.string(t[5]);case 83:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 84:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6]);case 112:return this.uint(t[1])&&this.string(t[2])&&this.boolean(t[3])&&this.string(t[4])&&this.int(t[5])&&this.int(t[6]);case 113:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3]);case 116:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8])&&this.uint(t[9])&&this.boolean(t[10]);case 119:return this.string(t[1])&&this.uint(t[2]);case 121:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 122:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 123:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])}}}class n{constructor(t,s,i,n,h,r){this.pageNo=t,this.timestamp=s,this.url=i,this.onBatch=n,this.tabId=h,this.onOfflineEnd=r,this.nextIndex=0,this.beaconSize=2e5,this.encoder=new e(this.beaconSize),this.sizeBuffer=new Uint8Array(3),this.isEmpty=!0,this.beaconSizeLimit=1e6,this.prepare()}writeType(t){return this.encoder.uint(t[0])}writeFields(t){return this.encoder.encode(t)}writeSizeAt(t,s){for(let s=0;s<3;s++)this.sizeBuffer[s]=t>>8*s;this.encoder.set(this.sizeBuffer,s)}prepare(){if(!this.encoder.isEmpty)return;const t=[81,1,this.pageNo,this.nextIndex,this.timestamp,this.url],s=[118,this.tabId];this.writeType(t),this.writeFields(t),this.writeWithSize(s),this.isEmpty=!0}writeWithSize(t){const s=this.encoder;if(!this.writeType(t)||!s.skip(3))return!1;const i=s.getCurrentOffset(),e=this.writeFields(t);if(e){const e=s.getCurrentOffset()-i;if(e>16777215)return console.warn("OpenReplay: max message size overflow."),!1;this.writeSizeAt(e,i-3),s.checkpoint(),this.isEmpty=this.isEmpty&&0===t[0],this.nextIndex++}return e}setBeaconSizeLimit(t){this.beaconSizeLimit=t}writeMessage(t){if("q_end"===t[0])return this.finaliseBatch(),this.onOfflineEnd();0===t[0]&&(this.timestamp=t[1]),122===t[0]&&(this.url=t[1]),this.writeWithSize(t)||(this.finaliseBatch(),this.writeWithSize(t)||(this.encoder=new e(this.beaconSizeLimit),this.prepare(),this.writeWithSize(t)?this.finaliseBatch():console.warn("OpenReplay: beacon size overflow. Skipping large message.",t,this),this.encoder=new e(this.beaconSize),this.prepare()))}finaliseBatch(){if(this.isEmpty)return;const t=this.encoder.flush();this.onBatch(t),this.prepare()}clean(){this.encoder.reset()}}var h;!function(t){t[t.NotActive=0]="NotActive",t[t.Starting=1]="Starting",t[t.Stopping=2]="Stopping",t[t.Active=3]="Active",t[t.Stopped=4]="Stopped"}(h||(h={}));let r=null,a=null,u=h.NotActive;function o(){a&&a.finaliseBatch()}function c(){return new Promise((t=>{u=h.Stopping,null!==l&&(clearInterval(l),l=null),a&&(a.clean(),a=null),r&&(r.clean(),setTimeout((()=>{r=null}),20)),setTimeout((()=>{u=h.NotActive,t(null)}),100)}))}function g(){u!==h.Stopped&&(postMessage("a_stop"),c().then((()=>{postMessage("a_start")})))}let p,l=null;self.onmessage=({data:s})=>{if(null!=s){if("stop"===s)return o(),void c().then((()=>{u=h.Stopped}));if("forceFlushBatch"!==s){if(!Array.isArray(s)){if("compressed"===s.type){if(!r)return console.debug("OR WebWorker: sender not initialised. Compressed batch."),void g();s.batch&&r.sendCompressed(s.batch)}if("uncompressed"===s.type){if(!r)return console.debug("OR WebWorker: sender not initialised. Uncompressed batch."),void g();s.batch&&r.sendUncompressed(s.batch)}return"start"===s.type?(u=h.Starting,r=new t(s.ingestPoint,(()=>{g()}),(t=>{!function(t){postMessage({type:"failure",reason:t}),c()}(t)}),s.connAttemptCount,s.connAttemptGap,(t=>{postMessage({type:"compress",batch:t},[t.buffer])}),s.pageNo),a=new n(s.pageNo,s.timestamp,s.url,(t=>{r&&r.push(t)}),s.tabId,(()=>postMessage({type:"queue_empty"}))),null===l&&(l=setInterval(o,1e4)),u=h.Active):"auth"===s.type?r?a?(r.authorise(s.token),void(s.beaconSizeLimit&&a.setBeaconSizeLimit(s.beaconSizeLimit))):(console.debug("OR WebWorker: writer not initialised. Received auth."),void g()):(console.debug("OR WebWorker: sender not initialised. Received auth."),void g()):void 0}if(a){const t=a;s.forEach((s=>{55===s[0]&&(s[1]?p=setTimeout((()=>g()),18e5):clearTimeout(p)),t.writeMessage(s)}))}else postMessage("not_init"),g()}else o()}else o()};'], { type: "text/javascript" })));
      this.worker.onerror = (e) => {
        this._debug("webworker_error", e);
      };
      this.worker.onmessage = ({ data }) => {
        this.handleWorkerMsg(data);
      };
      const alertWorker = () => {
        if (this.worker) {
          this.worker.postMessage(null);
        }
      };
      this.attachEventListener(window, "beforeunload", alertWorker, false);
      this.attachEventListener(document.body, "mouseleave", alertWorker, false, false);
      this.attachEventListener(document, "visibilitychange", alertWorker, false);
    } catch (e) {
      this._debug("worker_start", e);
    }
  }
  handleWorkerMsg(data) {
    var _a3;
    if (data === "a_stop") {
      this.stop(false);
    } else if (data === "a_start") {
      void this.start({}, true);
    } else if (data === "not_init") {
      this.debug.warn("OR WebWorker: writer not initialised. Restarting tracker");
    } else if (data.type === "failure") {
      this.stop(false);
      this.debug.error("worker_failed", data.reason);
      this._debug("worker_failed", data.reason);
    } else if (data.type === "compress") {
      const batch = data.batch;
      const batchSize = batch.byteLength;
      if (batchSize > this.compressionThreshold) {
        gzip(data.batch, { mtime: 0 }, (err2, result) => {
          var _a4, _b2;
          if (err2) {
            this.debug.error("Openreplay compression error:", err2);
            (_a4 = this.worker) == null ? void 0 : _a4.postMessage({ type: "uncompressed", batch });
          } else {
            (_b2 = this.worker) == null ? void 0 : _b2.postMessage({ type: "compressed", batch: result });
          }
        });
      } else {
        (_a3 = this.worker) == null ? void 0 : _a3.postMessage({ type: "uncompressed", batch });
      }
    } else if (data.type === "queue_empty") {
      this.onSessionSent();
    }
  }
  _debug(context, e) {
    if (this.options.__debug_report_edp !== null) {
      void fetch(this.options.__debug_report_edp, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          context,
          // @ts-ignore
          error: `${e}`
        })
      });
    }
    this.debug.error("OpenReplay error: ", context, e);
  }
  send(message, urgent = false) {
    var _a3;
    if (this.activityState === ActivityState.NotActive) {
      return;
    }
    if (this.activityState === ActivityState.ColdStart) {
      this.bufferedMessages1.push(message);
      if (!this.singleBuffer) {
        this.bufferedMessages2.push(message);
      }
      (_a3 = this.conditionsManager) == null ? void 0 : _a3.processMessage(message);
    } else {
      this.messages.push(message);
    }
    if (this.activityState === ActivityState.Active && urgent) {
      this.commit();
    }
  }
  /**
   * Normal workflow: add timestamp and tab data to batch, then commit it
   * every ~30ms
   * */
  _nCommit() {
    if (this.socketMode) {
      this.messages.unshift(TabData(this.session.getTabId()));
      this.messages.unshift(Timestamp(this.timestamp()));
      this.commitCallbacks.forEach((cb) => cb(this.messages));
      this.messages.length = 0;
      return;
    }
    if (this.worker === void 0 || !this.messages.length) {
      return;
    }
    if (this.insideIframe) {
      window.parent.postMessage({
        line: proto.iframeBatch,
        messages: this.messages,
        domain: this.initialHostName
      }, "*");
      this.commitCallbacks.forEach((cb) => cb(this.messages));
      this.messages.length = 0;
      return;
    }
    try {
      requestIdleCb(() => {
        var _a3;
        this.messages.unshift(TabData(this.session.getTabId()));
        this.messages.unshift(Timestamp(this.timestamp()));
        (_a3 = this.worker) == null ? void 0 : _a3.postMessage(this.messages);
        this.commitCallbacks.forEach((cb) => cb(this.messages));
        this.messages.length = 0;
      });
    } catch (e) {
      this._debug("worker_commit", e);
      this.stop(true);
      setTimeout(() => {
        void this.start();
      }, 500);
    }
  }
  /**
   * Cold start: add timestamp and tab data to both batches
   * every 2nd tick, ~60ms
   * this will make batches a bit larger and replay will work with bigger jumps every frame
   * but in turn we don't overload batch writer on session start with 1000 batches
   * */
  _cStartCommit() {
    this.coldStartCommitN += 1;
    if (this.coldStartCommitN === 2) {
      this.bufferedMessages1.push(Timestamp(this.timestamp()));
      this.bufferedMessages1.push(TabData(this.session.getTabId()));
      this.bufferedMessages2.push(Timestamp(this.timestamp()));
      this.bufferedMessages2.push(TabData(this.session.getTabId()));
      this.coldStartCommitN = 0;
    }
  }
  commit() {
    if (this.activityState === ActivityState.ColdStart) {
      this._cStartCommit();
    } else {
      this._nCommit();
    }
  }
  postToWorker(messages) {
    var _a3;
    (_a3 = this.worker) == null ? void 0 : _a3.postMessage(messages);
    this.commitCallbacks.forEach((cb) => cb(messages));
    messages.length = 0;
  }
  timestamp() {
    return now() + this.delay;
  }
  safe(fn) {
    const app = this;
    return function(...args) {
      try {
        fn.apply(this, args);
      } catch (e) {
        app._debug("safe_fn_call", e);
      }
    };
  }
  attachCommitCallback(cb) {
    this.commitCallbacks.push(cb);
  }
  attachStartCallback(cb, useSafe = false) {
    if (useSafe) {
      cb = this.safe(cb);
    }
    this.startCallbacks.push(cb);
  }
  attachStopCallback(cb, useSafe = false) {
    if (useSafe) {
      cb = this.safe(cb);
    }
    this.stopCallbacks.push(cb);
  }
  // Use  app.nodes.attachNodeListener for registered nodes instead
  attachEventListener(target, type, listener, useSafe = true, useCapture = true) {
    if (useSafe) {
      listener = this.safe(listener);
    }
    const createListener = () => target ? createEventListener(target, type, listener, useCapture) : null;
    const deleteListener = () => target ? deleteEventListener(target, type, listener, useCapture) : null;
    this.attachStartCallback(createListener, useSafe);
    this.attachStopCallback(deleteListener, useSafe);
  }
  // TODO: full correct semantic
  checkRequiredVersion(version) {
    const reqVer = version.split(/[.-]/);
    const ver = this.version.split(/[.-]/);
    for (let i = 0; i < 3; i++) {
      if (isNaN(Number(ver[i])) || isNaN(Number(reqVer[i]))) {
        return false;
      }
      if (Number(ver[i]) > Number(reqVer[i])) {
        return true;
      }
      if (Number(ver[i]) < Number(reqVer[i])) {
        return false;
      }
    }
    return true;
  }
  getTrackerInfo() {
    return {
      userUUID: this.localStorage.getItem(this.options.local_uuid_key),
      projectKey: this.projectKey,
      revID: this.revID,
      trackerVersion: this.version,
      isSnippet: this.options.__is_snippet
    };
  }
  getSessionInfo() {
    return {
      ...this.session.getInfo(),
      ...this.getTrackerInfo()
    };
  }
  getSessionToken() {
    return this.session.getSessionToken();
  }
  getSessionID() {
    return this.session.getInfo().sessionID || void 0;
  }
  getSessionURL(options) {
    const { projectID, sessionID, timestamp } = this.session.getInfo();
    if (!projectID || !sessionID) {
      this.debug.error("OpenReplay error: Unable to build session URL");
      return void 0;
    }
    const ingest = this.options.ingestPoint;
    const isSaas = /api\.openreplay\.com/.test(ingest);
    const projectPath = isSaas ? "https://app.openreplay.com/ingest" : ingest;
    const url = projectPath.replace(/ingest$/, `${projectID}/session/${sessionID}`);
    if (options == null ? void 0 : options.withCurrentTime) {
      const jumpTo = now() - timestamp;
      return `${url}?jumpto=${jumpTo}`;
    }
    return url;
  }
  getHost() {
    return new URL(this.options.ingestPoint).host;
  }
  getProjectKey() {
    return this.projectKey;
  }
  getBaseHref() {
    var _a3, _b2;
    if (typeof this.options.resourceBaseHref === "string") {
      return this.options.resourceBaseHref;
    } else if (typeof this.options.resourceBaseHref === "object") {
    }
    if (document.baseURI) {
      return document.baseURI;
    }
    return ((_b2 = (_a3 = document.head) == null ? void 0 : _a3.getElementsByTagName("base")[0]) == null ? void 0 : _b2.getAttribute("href")) || location.origin + location.pathname;
  }
  resolveResourceURL(resourceURL) {
    const base = new URL(this.getBaseHref());
    base.pathname += "/" + new URL(resourceURL).pathname;
    base.pathname.replace(/\/+/g, "/");
    return base.toString();
  }
  isServiceURL(url) {
    return url.startsWith(this.options.ingestPoint);
  }
  active() {
    return this.activityState === ActivityState.Active;
  }
  resetNextPageSession(flag) {
    if (flag) {
      this.sessionStorage.setItem(this.options.session_reset_key, "t");
    } else {
      this.sessionStorage.removeItem(this.options.session_reset_key);
    }
  }
  checkSessionToken(forceNew) {
    const lsReset = this.sessionStorage.getItem(this.options.session_reset_key) !== null;
    const needNewSessionID = forceNew || lsReset;
    const sessionToken = this.session.getSessionToken();
    return needNewSessionID || !sessionToken;
  }
  /**
   * start buffering messages without starting the actual session, which gives
   * user 30 seconds to "activate" and record session by calling `start()` on conditional trigger,
   * and we will then send buffered batch, so it won't get lost
   * */
  async coldStart(startOpts = {}, conditional) {
    this.singleBuffer = false;
    const second = 1e3;
    const isNewSession = this.checkSessionToken(startOpts.forceNew);
    if (conditional) {
      await this.setupConditionalStart(startOpts);
    }
    const cycle = () => {
      this.orderNumber += 1;
      adjustTimeOrigin();
      this.coldStartTs = now();
      if (this.orderNumber % 2 === 0) {
        this.bufferedMessages1.length = 0;
        this.bufferedMessages1.push(Timestamp(this.timestamp()));
        this.bufferedMessages1.push(TabData(this.session.getTabId()));
      } else {
        this.bufferedMessages2.length = 0;
        this.bufferedMessages2.push(Timestamp(this.timestamp()));
        this.bufferedMessages2.push(TabData(this.session.getTabId()));
      }
      this.stop(false);
      this.activityState = ActivityState.ColdStart;
      if (startOpts.sessionHash) {
        this.session.applySessionHash(startOpts.sessionHash);
      }
      if (startOpts.forceNew) {
        this.session.reset();
      }
      this.session.assign({
        userID: startOpts.userID,
        metadata: startOpts.metadata
      });
      if (!isNewSession) {
        this.debug.log("continuing session on new tab", this.session.getTabId());
        this.send(TabChange(this.session.getTabId()));
      }
      this.observer.observe();
      this.ticker.start();
    };
    this.coldInterval = setInterval(() => {
      cycle();
    }, 30 * second);
    cycle();
  }
  async setupConditionalStart(startOpts) {
    var _a3, _b2;
    this.conditionsManager = new ConditionsManager(this, startOpts);
    const r = await fetch(this.options.ingestPoint + "/v1/web/start", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        ...this.getTrackerInfo(),
        timestamp: now(),
        doNotRecord: true,
        bufferDiff: 0,
        userID: this.session.getInfo().userID,
        token: void 0,
        deviceMemory,
        jsHeapSizeLimit,
        timezone: getTimezone(),
        width: window.innerWidth,
        height: window.innerHeight
      })
    });
    const {
      // this token is needed to fetch conditions and flags,
      // but it can't be used to record a session
      token,
      userBrowser,
      userCity,
      userCountry,
      userDevice,
      userOS,
      userState,
      projectID
    } = await r.json();
    this.session.assign({ projectID });
    this.session.setUserInfo({
      userBrowser,
      userCity,
      userCountry,
      userDevice,
      userOS,
      userState
    });
    const onStartInfo = { sessionToken: token, userUUID: "", sessionID: "" };
    this.startCallbacks.forEach((cb) => cb(onStartInfo));
    await ((_a3 = this.conditionsManager) == null ? void 0 : _a3.fetchConditions(projectID, token));
    await this.featureFlags.reloadFlags(token);
    await this.tagWatcher.fetchTags(this.options.ingestPoint, token);
    (_b2 = this.conditionsManager) == null ? void 0 : _b2.processFlags(this.featureFlags.flags);
  }
  /**
   * Starts offline session recording
   * @param {Object} startOpts - options for session start, same as .start()
   * @param {Function} onSessionSent - callback that will be called once session is fully sent
   * */
  offlineRecording(startOpts = {}, onSessionSent) {
    this.onSessionSent = onSessionSent;
    this.singleBuffer = true;
    const isNewSession = this.checkSessionToken(startOpts.forceNew);
    adjustTimeOrigin();
    this.coldStartTs = now();
    const saverBuffer = this.localStorage.getItem(bufferStorageKey);
    if (saverBuffer) {
      const data = JSON.parse(saverBuffer);
      this.bufferedMessages1 = Array.isArray(data) ? data : this.bufferedMessages1;
      this.localStorage.removeItem(bufferStorageKey);
    }
    this.bufferedMessages1.push(Timestamp(this.timestamp()));
    this.bufferedMessages1.push(TabData(this.session.getTabId()));
    this.activityState = ActivityState.ColdStart;
    if (startOpts.sessionHash) {
      this.session.applySessionHash(startOpts.sessionHash);
    }
    if (startOpts.forceNew) {
      this.session.reset();
    }
    this.session.assign({
      userID: startOpts.userID,
      metadata: startOpts.metadata
    });
    const onStartInfo = { sessionToken: "", userUUID: "", sessionID: "" };
    this.startCallbacks.forEach((cb) => cb(onStartInfo));
    if (!isNewSession) {
      this.send(TabChange(this.session.getTabId()));
    }
    this.observer.observe();
    this.ticker.start();
    return {
      saveBuffer: this.saveBuffer,
      getBuffer: this.getBuffer,
      setBuffer: this.setBuffer
    };
  }
  /**
   * Saves the captured messages in localStorage (or whatever is used in its place)
   *
   * Then, when this.offlineRecording is called, it will preload this messages and clear the storage item
   *
   * Keeping the size of local storage reasonable is up to the end users of this library
   * */
  saveBuffer() {
    this.localStorage.setItem(bufferStorageKey, JSON.stringify(this.bufferedMessages1));
  }
  /**
   * @returns buffer with stored messages for offline recording
   * */
  getBuffer() {
    return this.bufferedMessages1;
  }
  /**
   * Used to set a buffer with messages array
   * */
  setBuffer(buffer) {
    this.bufferedMessages1 = buffer;
  }
  /**
   * Uploads the stored session buffer to backend
   * @returns promise that resolves once messages are loaded, it has to be awaited
   * so the session can be uploaded properly
   * @resolve - if messages were loaded in service worker successfully
   * @reject {string} - error message
   * */
  async uploadOfflineRecording() {
    var _a3, _b2;
    this.stop(false);
    const timestamp = now();
    (_a3 = this.worker) == null ? void 0 : _a3.postMessage({
      type: "start",
      pageNo: this.session.incPageNo(),
      ingestPoint: this.options.ingestPoint,
      timestamp: this.coldStartTs,
      url: document.URL,
      connAttemptCount: this.options.connAttemptCount,
      connAttemptGap: this.options.connAttemptGap,
      tabId: this.session.getTabId()
    });
    const r = await fetch(this.options.ingestPoint + "/v1/web/start", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        ...this.getTrackerInfo(),
        timestamp,
        doNotRecord: false,
        bufferDiff: timestamp - this.coldStartTs,
        userID: this.session.getInfo().userID,
        token: void 0,
        deviceMemory,
        jsHeapSizeLimit,
        timezone: getTimezone()
      })
    });
    const { token, userBrowser, userCity, userCountry, userDevice, userOS, userState, beaconSizeLimit, projectID } = await r.json();
    (_b2 = this.worker) == null ? void 0 : _b2.postMessage({
      type: "auth",
      token,
      beaconSizeLimit
    });
    this.session.assign({ projectID });
    this.session.setUserInfo({
      userBrowser,
      userCity,
      userCountry,
      userDevice,
      userOS,
      userState
    });
    while (this.bufferedMessages1.length > 0) {
      await this.flushBuffer(this.bufferedMessages1);
    }
    this.postToWorker([["q_end"]]);
    this.clearBuffers();
  }
  async _start(startOpts = {}, resetByWorker = false, conditionName) {
    const isColdStart = this.activityState === ActivityState.ColdStart;
    if (isColdStart && this.coldInterval) {
      clearInterval(this.coldInterval);
    }
    if (!this.worker) {
      const reason = "No worker found: perhaps, CSP is not set.";
      this.signalError(reason, []);
      return Promise.resolve(UnsuccessfulStart(reason));
    }
    if (this.activityState === ActivityState.Active || this.activityState === ActivityState.Starting) {
      const reason = "OpenReplay: trying to call `start()` on the instance that has been started already.";
      return Promise.resolve(UnsuccessfulStart(reason));
    }
    this.activityState = ActivityState.Starting;
    if (!isColdStart) {
      adjustTimeOrigin();
    }
    if (startOpts.sessionHash) {
      this.session.applySessionHash(startOpts.sessionHash);
    }
    if (startOpts.forceNew) {
      this.session.reset();
    }
    this.session.assign({
      // MBTODO: maybe it would make sense to `forceNew` if the `userID` was changed
      userID: startOpts.userID,
      metadata: startOpts.metadata
    });
    const timestamp = now();
    this.worker.postMessage({
      type: "start",
      pageNo: this.session.incPageNo(),
      ingestPoint: this.options.ingestPoint,
      timestamp: isColdStart ? this.coldStartTs : timestamp,
      url: document.URL,
      connAttemptCount: this.options.connAttemptCount,
      connAttemptGap: this.options.connAttemptGap,
      tabId: this.session.getTabId()
    });
    const sessionToken = this.session.getSessionToken();
    const isNewSession = this.checkSessionToken(startOpts.forceNew);
    this.sessionStorage.removeItem(this.options.session_reset_key);
    this.debug.log("OpenReplay: starting session; need new session id?", isNewSession, "session token: ", sessionToken);
    try {
      const r = await window.fetch(this.options.ingestPoint + "/v1/web/start", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          ...this.getTrackerInfo(),
          timestamp,
          doNotRecord: false,
          bufferDiff: timestamp - this.coldStartTs,
          userID: this.session.getInfo().userID,
          token: isNewSession ? void 0 : sessionToken,
          deviceMemory,
          jsHeapSizeLimit,
          timezone: getTimezone(),
          condition: conditionName,
          assistOnly: startOpts.assistOnly ?? this.socketMode
        })
      });
      if (r.status !== 200) {
        const error = await r.text();
        const reason = error === CANCELED ? CANCELED : `Server error: ${r.status}. ${error}`;
        return Promise.reject(reason);
      }
      if (!this.worker) {
        const reason = "no worker found after start request (this might not happen)";
        this.signalError(reason, []);
        return Promise.reject(reason);
      }
      const {
        token,
        userUUID,
        projectID,
        beaconSizeLimit,
        compressionThreshold,
        // how big the batch should be before we decide to compress it
        delay: delay2,
        //  derived from token
        sessionID,
        //  derived from token
        startTimestamp,
        // real startTS (server time), derived from sessionID
        userBrowser,
        userCity,
        userCountry,
        userDevice,
        userOS,
        userState,
        canvasEnabled,
        canvasQuality,
        canvasFPS,
        assistOnly: socketOnly
      } = await r.json();
      if (typeof token !== "string" || typeof userUUID !== "string" || typeof startTimestamp !== "number" && typeof startTimestamp !== "undefined" || typeof sessionID !== "string" || typeof delay2 !== "number" || typeof beaconSizeLimit !== "number" && typeof beaconSizeLimit !== "undefined") {
        const reason = `Incorrect server response: ${JSON.stringify(r)}`;
        this.signalError(reason, []);
        return Promise.reject(reason);
      }
      this.delay = delay2;
      this.session.setSessionToken(token);
      this.session.setUserInfo({
        userBrowser,
        userCity,
        userCountry,
        userDevice,
        userOS,
        userState
      });
      this.session.assign({
        sessionID,
        timestamp: startTimestamp || timestamp,
        projectID
      });
      if (socketOnly) {
        this.socketMode = true;
        this.worker.postMessage("stop");
      } else {
        this.worker.postMessage({
          type: "auth",
          token,
          beaconSizeLimit
        });
      }
      if (!isNewSession && token === sessionToken) {
        this.debug.log("continuing session on new tab", this.session.getTabId());
        this.send(TabChange(this.session.getTabId()));
      }
      Object.entries(this.session.getInfo().metadata).forEach(([key, value]) => this.send(Metadata(key, value)));
      this.localStorage.setItem(this.options.local_uuid_key, userUUID);
      this.compressionThreshold = compressionThreshold;
      const onStartInfo = { sessionToken: token, userUUID, sessionID };
      this.startCallbacks.forEach((cb) => cb(onStartInfo));
      void this.featureFlags.reloadFlags();
      await this.tagWatcher.fetchTags(this.options.ingestPoint, token);
      this.activityState = ActivityState.Active;
      if (canvasEnabled && !this.options.canvas.disableCanvas) {
        this.canvasRecorder = this.canvasRecorder ?? new canvas_default(this, {
          fps: canvasFPS,
          quality: canvasQuality,
          isDebug: this.options.canvas.__save_canvas_locally,
          fixedScaling: this.options.canvas.fixedCanvasScaling,
          useAnimationFrame: this.options.canvas.useAnimationFrame
        });
        this.canvasRecorder.startTracking();
      }
      if (isColdStart) {
        const biggestBuffer = this.bufferedMessages1.length > this.bufferedMessages2.length ? this.bufferedMessages1 : this.bufferedMessages2;
        while (biggestBuffer.length > 0) {
          await this.flushBuffer(biggestBuffer);
        }
        this.clearBuffers();
        this.commit();
      } else {
        if (this.insideIframe && this.rootId) {
          this.observer.crossdomainObserve(this.rootId, this.frameOderNumber);
        } else {
          this.observer.observe();
        }
        this.ticker.start();
      }
      this.uxtManager = this.uxtManager ? this.uxtManager : new UserTestManager(this, uxtStorageKey);
      let uxtId;
      const savedUxtTag = this.localStorage.getItem(uxtStorageKey);
      if (savedUxtTag) {
        uxtId = parseInt(savedUxtTag, 10);
      }
      if (location == null ? void 0 : location.search) {
        const query = new URLSearchParams(location.search);
        if (query.has("oruxt")) {
          const qId = query.get("oruxt");
          uxtId = qId ? parseInt(qId, 10) : void 0;
        }
      }
      if (uxtId) {
        if (!this.uxtManager.isActive) {
          this.uxtManager.getTest(uxtId, token, Boolean(savedUxtTag)).then((id2) => {
            if (id2) {
              this.onUxtCb.forEach((cb) => cb(id2));
            }
          });
        } else {
          this.onUxtCb.forEach((cb) => cb(uxtId));
        }
      }
      return SuccessfulStart(onStartInfo);
    } catch (reason) {
      this.stop();
      this.session.reset();
      if (reason === CANCELED) {
        this.signalError(CANCELED, []);
        return UnsuccessfulStart(CANCELED);
      }
      this._debug("session_start", reason);
      const errorMessage = reason instanceof Error ? reason.message : reason.toString();
      this.signalError(errorMessage, []);
      return UnsuccessfulStart(errorMessage);
    }
  }
  addOnUxtCb(cb) {
    this.onUxtCb.push(cb);
  }
  getUxtId() {
    var _a3;
    return (_a3 = this.uxtManager) == null ? void 0 : _a3.getTestId();
  }
  async waitStart() {
    return new Promise((resolve) => {
      const check = () => {
        if (this.canStart) {
          resolve(true);
        } else {
          setTimeout(check, 25);
        }
      };
      check();
    });
  }
  async waitStarted() {
    return new Promise((resolve) => {
      const check = () => {
        if (this.activityState === ActivityState.Active) {
          resolve(true);
        } else {
          setTimeout(check, 25);
        }
      };
      check();
    });
  }
  /**
   * basically we ask other tabs during constructor
   * and here we just apply 10ms delay just in case
   * */
  async start(...args) {
    if (this.activityState === ActivityState.Active || this.activityState === ActivityState.Starting) {
      const reason = "OpenReplay: trying to call `start()` on the instance that has been started already.";
      return Promise.resolve(UnsuccessfulStart(reason));
    }
    if (!document.hidden) {
      await this.waitStart();
      return this._start(...args);
    } else {
      return new Promise((resolve) => {
        const onVisibilityChange = async () => {
          if (!document.hidden) {
            await this.waitStart();
            document.removeEventListener("visibilitychange", onVisibilityChange);
            resolve(this._start(...args));
          }
        };
        document.addEventListener("visibilitychange", onVisibilityChange);
      });
    }
  }
  forceFlushBatch() {
    var _a3;
    (_a3 = this.worker) == null ? void 0 : _a3.postMessage("forceFlushBatch");
  }
  getTabId() {
    return this.session.getTabId();
  }
  clearBuffers() {
    this.bufferedMessages1.length = 0;
    this.bufferedMessages2.length = 0;
  }
  /**
   * Creates a named hook that expects event name, data string and msg direction (up/down),
   * it will skip any message bigger than 5 mb or event name bigger than 255 symbols
   * @returns {(msgType: string, data: string, dir: "up" | "down") => void}
   * */
  trackWs(channelName) {
    const channel = channelName;
    return (msgType, data, dir = "down") => {
      if (typeof msgType !== "string" || typeof data !== "string" || data.length > 5 * 1024 * 1024 || msgType.length > 255) {
        return;
      }
      this.send(WSChannel("websocket", channel, data, this.timestamp(), dir, msgType));
    };
  }
  stop(stopWorker = true) {
    var _a3;
    if (this.activityState !== ActivityState.NotActive) {
      try {
        this.attributeSender.clear();
        this.sanitizer.clear();
        this.observer.disconnect();
        this.nodes.clear();
        this.ticker.stop();
        this.stopCallbacks.forEach((cb) => cb());
        this.debug.log("OpenReplay tracking stopped.");
        this.tagWatcher.clear();
        if (this.worker && stopWorker) {
          this.worker.postMessage("stop");
        }
        (_a3 = this.canvasRecorder) == null ? void 0 : _a3.clear();
      } finally {
        this.activityState = ActivityState.NotActive;
      }
    }
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/connection.js
function connection_default(app) {
  const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
  if (connection === void 0) {
    return;
  }
  const sendConnectionInformation = () => app.send(ConnectionInformation(Math.round(connection.downlink * 1e3), connection.type || "unknown"));
  sendConnectionInformation();
  connection.addEventListener("change", sendConnectionInformation);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/console.js
var printError = IN_BROWSER && "InstallTrigger" in window ? (e) => e.message + "\n" + e.stack : (e) => e.stack || e.message;
function printString(arg) {
  if (arg === void 0) {
    return "undefined";
  }
  if (arg === null) {
    return "null";
  }
  if (arg instanceof Error) {
    return printError(arg);
  }
  if (Array.isArray(arg)) {
    return `Array(${arg.length})`;
  }
  return String(arg);
}
function printFloat(arg) {
  if (typeof arg !== "number")
    return "NaN";
  return arg.toString();
}
function printInt(arg) {
  if (typeof arg !== "number")
    return "NaN";
  return Math.floor(arg).toString();
}
function printObject(arg) {
  if (arg === void 0) {
    return "undefined";
  }
  if (arg === null) {
    return "null";
  }
  if (arg instanceof Error) {
    return printError(arg);
  }
  if (Array.isArray(arg)) {
    const length = arg.length;
    const values = arg.slice(0, 10).map(printString).join(", ");
    return `Array(${length})[${values}]`;
  }
  if (typeof arg === "object") {
    const res = [];
    let i = 0;
    for (const k in arg) {
      if (++i === 10) {
        break;
      }
      const v = arg[k];
      res.push(k + ": " + printString(v));
    }
    return "{" + res.join(", ") + "}";
  }
  return arg.toString();
}
function printf(args) {
  if (typeof args[0] === "string") {
    args.unshift(args.shift().replace(/%(o|s|f|d|i)/g, (s, t) => {
      const arg = args.shift();
      if (arg === void 0)
        return s;
      switch (t) {
        case "o":
          return printObject(arg);
        case "s":
          return printString(arg);
        case "f":
          return printFloat(arg);
        case "d":
        case "i":
          return printInt(arg);
        default:
          return s;
      }
    }));
  }
  return args.map(printObject).join(" ");
}
var consoleMethods = ["log", "info", "warn", "error", "debug", "assert"];
function console_default(app, opts) {
  const options = Object.assign({
    consoleMethods,
    consoleThrottling: 30
  }, opts);
  if (!Array.isArray(options.consoleMethods) || options.consoleMethods.length === 0) {
    return;
  }
  const sendConsoleLog = app.safe((level, args) => app.send(ConsoleLog(level, printf(args))));
  let n = 0;
  const reset = () => {
    n = 0;
  };
  app.attachStartCallback(reset);
  app.ticker.attach(reset, 33, false);
  const patchConsole = (console2, ctx) => {
    const handler = {
      apply: function(target, thisArg, argumentsList) {
        Reflect.apply(target, ctx, argumentsList);
        n = n + 1;
        if (n > options.consoleThrottling) {
          return;
        } else {
          sendConsoleLog(target.name, argumentsList);
        }
      }
    };
    options.consoleMethods.forEach((method) => {
      if (consoleMethods.indexOf(method) === -1) {
        app.debug.error(`OpenReplay: unsupported console method "${method}"`);
        return;
      }
      const fn = ctx.console[method];
      console2[method] = new Proxy(fn, handler);
    });
  };
  const patchContext = app.safe((context) => patchConsole(context.console, context));
  patchContext(window);
  app.observer.attachContextCallback(patchContext);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/exception.js
var import_error_stack_parser = __toESM(require_error_stack_parser(), 1);
function getDefaultStack(e) {
  return [
    {
      columnNumber: e.colno,
      lineNumber: e.lineno,
      fileName: e.filename,
      functionName: "",
      source: ""
    }
  ];
}
function getExceptionMessage(error, fallbackStack, metadata = {}) {
  let stack = fallbackStack;
  try {
    stack = import_error_stack_parser.default.parse(error);
  } catch (e) {
  }
  return JSException(error.name, error.message, JSON.stringify(stack), JSON.stringify(metadata));
}
function getExceptionMessageFromEvent(e, context = window, metadata = {}) {
  if (e instanceof ErrorEvent) {
    if (e.error instanceof Error) {
      return getExceptionMessage(e.error, getDefaultStack(e), metadata);
    } else {
      let [name, message] = e.message.split(":");
      if (!message) {
        name = "Error";
        message = e.message;
      }
      return JSException(name, message, JSON.stringify(getDefaultStack(e)), JSON.stringify(metadata));
    }
  } else if ("PromiseRejectionEvent" in context && e instanceof context.PromiseRejectionEvent) {
    if (e.reason instanceof Error) {
      return getExceptionMessage(e.reason, [], metadata);
    } else {
      let message;
      try {
        message = JSON.stringify(e.reason);
      } catch (_) {
        message = String(e.reason);
      }
      return JSException("Unhandled Promise Rejection", message, "[]", JSON.stringify(metadata));
    }
  }
  return null;
}
function exception_default(app, opts) {
  const options = Object.assign({
    captureExceptions: true
  }, opts);
  function patchContext(context) {
    function handler(e) {
      const msg = getExceptionMessageFromEvent(e, context);
      if (msg != null) {
        app.send(msg);
      }
    }
    app.attachEventListener(context, "unhandledrejection", handler);
    app.attachEventListener(context, "error", handler);
  }
  if (options.captureExceptions) {
    app.observer.attachContextCallback(patchContext);
    patchContext(window);
  }
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/img.js
function resolveURL(url, location2 = document.location) {
  url = url.trim();
  if (url.startsWith("//") || url.startsWith("http://") || url.startsWith("https://") || url.startsWith("data:")) {
    return url;
  } else if (url.startsWith("/")) {
    return location2.origin + url;
  } else {
    return location2.origin + location2.pathname + url;
  }
}
function isSVGInFireFox(url) {
  return IS_FIREFOX && (url.startsWith("data:image/svg+xml") || url.match(/.svg$|/i));
}
var PLACEHOLDER_SRC = "https://static.openreplay.com/tracker/placeholder.jpeg";
function img_default(app) {
  function sendPlaceholder(id2, node) {
    app.attributeSender.sendSetAttribute(id2, "src", PLACEHOLDER_SRC);
    const { width, height } = node.getBoundingClientRect();
    if (!node.hasAttribute("width")) {
      app.attributeSender.sendSetAttribute(id2, "width", String(width));
    }
    if (!node.hasAttribute("height")) {
      app.attributeSender.sendSetAttribute(id2, "height", String(height));
    }
  }
  const sendSrcset = function(id2, img) {
    const { srcset } = img;
    if (!srcset) {
      return;
    }
    const resolvedSrcset = srcset.split(srcset.match(/,\s+/) ? /,\s+/ : ",").map((str) => resolveURL(str)).join(", ");
    app.attributeSender.sendSetAttribute(id2, "srcset", resolvedSrcset);
  };
  const sendSrc = function(id2, img) {
    if (img.src.length > MAX_STR_LEN) {
      sendPlaceholder(id2, img);
    }
    app.send(SetNodeAttributeURLBased(id2, "src", img.src, app.getBaseHref()));
  };
  const sendImgError = app.safe(function(img) {
    const resolvedSrc = resolveURL(img.src || "");
    if (isURL(resolvedSrc)) {
      app.send(ResourceTiming(app.timestamp(), 0, 0, 0, 0, 0, resolvedSrc, "img", 0, false));
    }
  });
  const sendImgAttrs = app.safe(function(img) {
    const id2 = app.nodes.getID(img);
    if (id2 === void 0) {
      return;
    }
    if (!img.complete) {
      return;
    }
    if (img.naturalHeight === 0 && img.naturalWidth === 0 && !isSVGInFireFox(img.src)) {
      sendImgError(img);
    } else if (app.sanitizer.isHidden(id2) || app.sanitizer.isObscured(id2)) {
      sendPlaceholder(id2, img);
    } else {
      sendSrc(id2, img);
      sendSrcset(id2, img);
    }
  });
  const observer = createMutationObserver(app.safe((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === "attributes") {
        const target = mutation.target;
        const id2 = app.nodes.getID(target);
        if (id2 === void 0) {
          return;
        }
        if (mutation.attributeName === "src") {
          sendSrc(id2, target);
        }
        if (mutation.attributeName === "srcset") {
          sendSrcset(id2, target);
        }
      }
    }
  }));
  app.attachStopCallback(() => {
    observer.disconnect();
  });
  app.nodes.attachNodeCallback((node) => {
    if (!hasTag(node, "img")) {
      return;
    }
    app.nodes.attachNodeListener(node, "error", () => sendImgError(node));
    app.nodes.attachNodeListener(node, "load", () => sendImgAttrs(node));
    sendImgAttrs(node);
    observer.observe(node, { attributes: true, attributeFilter: ["src", "srcset"] });
  });
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/input.js
var INPUT_TYPES = [
  "text",
  "password",
  "email",
  "search",
  "number",
  "range",
  "date",
  "tel",
  "time"
];
function isTextFieldElement(node) {
  if (hasTag(node, "textarea")) {
    return true;
  }
  if (!hasTag(node, "input")) {
    return false;
  }
  return INPUT_TYPES.includes(node.type);
}
function isCheckbox(node) {
  if (!hasTag(node, "input")) {
    return false;
  }
  const type = node.type;
  return type === "checkbox" || type === "radio";
}
var labelElementFor = IN_BROWSER && "labels" in HTMLInputElement.prototype ? (node) => {
  let p = node;
  while ((p = p.parentNode) !== null) {
    if (hasTag(p, "label")) {
      return p;
    }
  }
  const labels = node.labels;
  if (labels !== null && labels.length === 1) {
    return labels[0];
  }
} : (node) => {
  let p = node;
  while ((p = p.parentNode) !== null) {
    if (hasTag(p, "label")) {
      return p;
    }
  }
  const id2 = node.id;
  if (id2) {
    const labels = node.ownerDocument.querySelectorAll('label[for="' + id2 + '"]');
    if (labels !== null && labels.length === 1) {
      return labels[0];
    }
  }
};
function getInputLabel(node) {
  let label = getLabelAttribute(node);
  if (label === null) {
    const labelElement = labelElementFor(node);
    label = labelElement && labelElement.innerText || node.placeholder || node.name || node.id || node.className || node.type;
  }
  return normSpaces(label).slice(0, 100);
}
var InputMode = {
  Plain: 0,
  Obscured: 1,
  Hidden: 2
};
function input_default(app, opts) {
  const options = Object.assign({
    obscureInputNumbers: true,
    obscureInputEmails: true,
    defaultInputMode: InputMode.Obscured,
    obscureInputDates: false
  }, opts);
  function getInputValue(id2, node) {
    let value = node.value;
    let inputMode = options.defaultInputMode;
    if (node.type === "password" || app.sanitizer.isHidden(id2)) {
      inputMode = InputMode.Hidden;
    } else if (app.sanitizer.isObscured(id2) || inputMode === InputMode.Plain && (options.obscureInputNumbers && node.type !== "date" && /\d\d\d\d/.test(value) || options.obscureInputDates && node.type === "date" || options.obscureInputEmails && (node.type === "email" || !!~value.indexOf("@")))) {
      inputMode = InputMode.Obscured;
    }
    let mask = 0;
    switch (inputMode) {
      case InputMode.Hidden:
        mask = -1;
        value = "";
        break;
      case InputMode.Obscured:
        mask = value.length;
        value = "";
        break;
    }
    return { value, mask };
  }
  function sendInputValue(id2, node) {
    const { value, mask } = getInputValue(id2, node);
    app.send(SetInputValue(id2, value, mask));
  }
  const inputValues = /* @__PURE__ */ new Map();
  const checkboxValues = /* @__PURE__ */ new Map();
  app.attachStopCallback(() => {
    inputValues.clear();
    checkboxValues.clear();
  });
  function trackInputValue(id2, node) {
    if (inputValues.get(id2) === node.value) {
      return;
    }
    inputValues.set(id2, node.value);
    sendInputValue(id2, node);
  }
  function trackCheckboxValue(id2, value) {
    if (checkboxValues.get(id2) === value) {
      return;
    }
    checkboxValues.set(id2, value);
    app.send(SetInputChecked(id2, value));
  }
  app.ticker.attach(() => {
    inputValues.forEach((value, id2) => {
      const node = app.nodes.getNode(id2);
      if (!node)
        return inputValues.delete(id2);
      trackInputValue(id2, node);
    });
    checkboxValues.forEach((checked, id2) => {
      const node = app.nodes.getNode(id2);
      if (!node)
        return checkboxValues.delete(id2);
      trackCheckboxValue(id2, node.checked);
    });
  }, 3);
  function sendInputChange(id2, node, hesitationTime, inputTime) {
    const { value, mask } = getInputValue(id2, node);
    const label = getInputLabel(node);
    app.send(InputChange(id2, value, mask !== 0, label, hesitationTime, inputTime));
  }
  app.nodes.attachNodeCallback(app.safe((node) => {
    const id2 = app.nodes.getID(node);
    if (id2 === void 0) {
      return;
    }
    if (hasTag(node, "select")) {
      sendInputValue(id2, node);
      app.nodes.attachNodeListener(node, "change", () => sendInputValue(id2, node));
    }
    if (isTextFieldElement(node)) {
      trackInputValue(id2, node);
      let nodeFocusTime = 0;
      let nodeHesitationTime = 0;
      let inputTime = 0;
      const onFocus = () => {
        nodeFocusTime = now();
      };
      const onInput = () => {
        if (nodeHesitationTime === 0 && nodeFocusTime !== 0) {
          nodeHesitationTime = now() - nodeFocusTime;
        }
      };
      const onChange = () => {
        if (nodeFocusTime !== 0) {
          inputTime = now() - nodeFocusTime;
        }
        sendInputChange(id2, node, nodeHesitationTime, inputTime);
        nodeHesitationTime = 0;
        inputTime = 0;
        nodeFocusTime = 0;
      };
      app.nodes.attachNodeListener(node, "focus", onFocus);
      app.nodes.attachNodeListener(node, "input", onInput);
      app.nodes.attachNodeListener(node, "change", onChange);
      return;
    }
    if (isCheckbox(node)) {
      trackCheckboxValue(id2, node.checked);
      app.nodes.attachNodeListener(node, "change", () => trackCheckboxValue(id2, node.checked));
      return;
    }
  }));
}

// node_modules/.pnpm/@medv+finder@3.2.0/node_modules/@medv/finder/finder.js
var config;
var rootDocument;
var start;
function finder(input, options) {
  start = /* @__PURE__ */ new Date();
  if (input.nodeType !== Node.ELEMENT_NODE) {
    throw new Error(`Can't generate CSS selector for non-element node type.`);
  }
  if ("html" === input.tagName.toLowerCase()) {
    return "html";
  }
  const defaults = {
    root: document.body,
    idName: (name) => true,
    className: (name) => true,
    tagName: (name) => true,
    attr: (name, value) => false,
    seedMinLength: 1,
    optimizedMinLength: 2,
    threshold: 1e3,
    maxNumberOfTries: 1e4,
    timeoutMs: void 0
  };
  config = { ...defaults, ...options };
  rootDocument = findRootDocument(config.root, defaults);
  let path = bottomUpSearch(input, "all", () => bottomUpSearch(input, "two", () => bottomUpSearch(input, "one", () => bottomUpSearch(input, "none"))));
  if (path) {
    const optimized = sort(optimize(path, input));
    if (optimized.length > 0) {
      path = optimized[0];
    }
    return selector(path);
  } else {
    throw new Error(`Selector was not found.`);
  }
}
function findRootDocument(rootNode, defaults) {
  if (rootNode.nodeType === Node.DOCUMENT_NODE) {
    return rootNode;
  }
  if (rootNode === defaults.root) {
    return rootNode.ownerDocument;
  }
  return rootNode;
}
function bottomUpSearch(input, limit, fallback) {
  let path = null;
  let stack = [];
  let current = input;
  let i = 0;
  while (current) {
    const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - start.getTime();
    if (config.timeoutMs !== void 0 && elapsedTime > config.timeoutMs) {
      throw new Error(`Timeout: Can't find a unique selector after ${elapsedTime}ms`);
    }
    let level = maybe(id(current)) || maybe(...attr(current)) || maybe(...classNames(current)) || maybe(tagName(current)) || [any()];
    const nth = index(current);
    if (limit == "all") {
      if (nth) {
        level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));
      }
    } else if (limit == "two") {
      level = level.slice(0, 1);
      if (nth) {
        level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));
      }
    } else if (limit == "one") {
      const [node] = level = level.slice(0, 1);
      if (nth && dispensableNth(node)) {
        level = [nthChild(node, nth)];
      }
    } else if (limit == "none") {
      level = [any()];
      if (nth) {
        level = [nthChild(level[0], nth)];
      }
    }
    for (let node of level) {
      node.level = i;
    }
    stack.push(level);
    if (stack.length >= config.seedMinLength) {
      path = findUniquePath(stack, fallback);
      if (path) {
        break;
      }
    }
    current = current.parentElement;
    i++;
  }
  if (!path) {
    path = findUniquePath(stack, fallback);
  }
  if (!path && fallback) {
    return fallback();
  }
  return path;
}
function findUniquePath(stack, fallback) {
  const paths = sort(combinations(stack));
  if (paths.length > config.threshold) {
    return fallback ? fallback() : null;
  }
  for (let candidate of paths) {
    if (unique(candidate)) {
      return candidate;
    }
  }
  return null;
}
function selector(path) {
  let node = path[0];
  let query = node.name;
  for (let i = 1; i < path.length; i++) {
    const level = path[i].level || 0;
    if (node.level === level - 1) {
      query = `${path[i].name} > ${query}`;
    } else {
      query = `${path[i].name} ${query}`;
    }
    node = path[i];
  }
  return query;
}
function penalty(path) {
  return path.map((node) => node.penalty).reduce((acc, i) => acc + i, 0);
}
function unique(path) {
  const css = selector(path);
  switch (rootDocument.querySelectorAll(css).length) {
    case 0:
      throw new Error(`Can't select any node with this selector: ${css}`);
    case 1:
      return true;
    default:
      return false;
  }
}
function id(input) {
  const elementId = input.getAttribute("id");
  if (elementId && config.idName(elementId)) {
    return {
      name: "#" + CSS.escape(elementId),
      penalty: 0
    };
  }
  return null;
}
function attr(input) {
  const attrs = Array.from(input.attributes).filter((attr2) => config.attr(attr2.name, attr2.value));
  return attrs.map((attr2) => ({
    name: `[${CSS.escape(attr2.name)}="${CSS.escape(attr2.value)}"]`,
    penalty: 0.5
  }));
}
function classNames(input) {
  const names = Array.from(input.classList).filter(config.className);
  return names.map((name) => ({
    name: "." + CSS.escape(name),
    penalty: 1
  }));
}
function tagName(input) {
  const name = input.tagName.toLowerCase();
  if (config.tagName(name)) {
    return {
      name,
      penalty: 2
    };
  }
  return null;
}
function any() {
  return {
    name: "*",
    penalty: 3
  };
}
function index(input) {
  const parent = input.parentNode;
  if (!parent) {
    return null;
  }
  let child = parent.firstChild;
  if (!child) {
    return null;
  }
  let i = 0;
  while (child) {
    if (child.nodeType === Node.ELEMENT_NODE) {
      i++;
    }
    if (child === input) {
      break;
    }
    child = child.nextSibling;
  }
  return i;
}
function nthChild(node, i) {
  return {
    name: node.name + `:nth-child(${i})`,
    penalty: node.penalty + 1
  };
}
function dispensableNth(node) {
  return node.name !== "html" && !node.name.startsWith("#");
}
function maybe(...level) {
  const list = level.filter(notEmpty);
  if (list.length > 0) {
    return list;
  }
  return null;
}
function notEmpty(value) {
  return value !== null && value !== void 0;
}
function* combinations(stack, path = []) {
  if (stack.length > 0) {
    for (let node of stack[0]) {
      yield* combinations(stack.slice(1, stack.length), path.concat(node));
    }
  } else {
    yield path;
  }
}
function sort(paths) {
  return [...paths].sort((a, b) => penalty(a) - penalty(b));
}
function* optimize(path, input, scope = {
  counter: 0,
  visited: /* @__PURE__ */ new Map()
}) {
  if (path.length > 2 && path.length > config.optimizedMinLength) {
    for (let i = 1; i < path.length - 1; i++) {
      if (scope.counter > config.maxNumberOfTries) {
        return;
      }
      scope.counter += 1;
      const newPath = [...path];
      newPath.splice(i, 1);
      const newPathKey = selector(newPath);
      if (scope.visited.has(newPathKey)) {
        return;
      }
      if (unique(newPath) && same(newPath, input)) {
        yield newPath;
        scope.visited.set(newPathKey, true);
        yield* optimize(newPath, input, scope);
      }
    }
  }
}
function same(path, input) {
  return rootDocument.querySelector(selector(path)) === input;
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/mouse.js
function _getSelector(target, document2, options) {
  const selector2 = finder(target, {
    root: document2.body,
    seedMinLength: 3,
    optimizedMinLength: (options == null ? void 0 : options.minSelectorDepth) || 2,
    threshold: (options == null ? void 0 : options.nthThreshold) || 1e3,
    maxNumberOfTries: (options == null ? void 0 : options.maxOptimiseTries) || 1e4
  });
  return selector2;
}
function isClickable(element) {
  const tag = element.tagName.toUpperCase();
  return tag === "BUTTON" || tag === "A" || tag === "LI" || tag === "SELECT" || tag === "TR" || tag === "TH" || element.onclick != null || element.getAttribute("role") === "button";
}
function getTarget(target, document2) {
  if (target instanceof Element) {
    return _getTarget(target, document2);
  }
  return null;
}
function _getTarget(target, document2) {
  let element = target;
  while (element !== null && element !== document2.documentElement) {
    if (hasOpenreplayAttribute(element, "masked")) {
      return null;
    }
    element = element.parentElement;
  }
  if (isSVGElement(target)) {
    let owner = target.ownerSVGElement;
    while (owner !== null) {
      target = owner;
      owner = owner.ownerSVGElement;
    }
  }
  element = target;
  while (element !== null && element !== document2.documentElement) {
    const tag = element.tagName.toUpperCase();
    if (tag === "LABEL") {
      return null;
    }
    if (tag === "INPUT") {
      return element;
    }
    if (isClickable(element) || getLabelAttribute(element) !== null) {
      return element;
    }
    element = element.parentElement;
  }
  return target === document2.documentElement ? null : target;
}
function mouse_default(app, options) {
  const { disableClickmaps = false } = options || {};
  function getTargetLabel(target) {
    const dl = getLabelAttribute(target);
    if (dl !== null) {
      return dl;
    }
    if (hasTag(target, "input")) {
      return getInputLabel(target);
    }
    if (isClickable(target)) {
      let label = "";
      if (target instanceof HTMLElement) {
        label = app.sanitizer.getInnerTextSecure(target);
      }
      label = label || target.id || target.className;
      return normSpaces(label).slice(0, 100);
    }
    return "";
  }
  let mousePositionX = -1;
  let mousePositionY = -1;
  let mousePositionChanged = false;
  let mouseTarget = null;
  let mouseTargetTime = 0;
  let selectorMap = {};
  let velocity = 0;
  let direction = 0;
  let directionChangeCount = 0;
  let distance = 0;
  let checkIntervalId;
  const shakeThreshold = 8e-3;
  const shakeCheckInterval = 225;
  function checkMouseShaking() {
    const nextVelocity = distance / shakeCheckInterval;
    if (!velocity) {
      velocity = nextVelocity;
      return;
    }
    const acceleration = (nextVelocity - velocity) / shakeCheckInterval;
    if (directionChangeCount > 4 && acceleration > shakeThreshold) {
      app.send(MouseThrashing(now()));
    }
    distance = 0;
    directionChangeCount = 0;
    velocity = nextVelocity;
  }
  app.attachStartCallback(() => {
    checkIntervalId = setInterval(() => checkMouseShaking(), shakeCheckInterval);
  });
  app.attachStopCallback(() => {
    mousePositionX = -1;
    mousePositionY = -1;
    mousePositionChanged = false;
    mouseTarget = null;
    selectorMap = {};
    if (checkIntervalId) {
      clearInterval(checkIntervalId);
    }
  });
  const sendMouseMove = () => {
    if (mousePositionChanged) {
      app.send(MouseMove(mousePositionX, mousePositionY));
      mousePositionChanged = false;
    }
  };
  const patchDocument = (document2, topframe = false) => {
    function getSelector(id2, target, options2) {
      return selectorMap[id2] = selectorMap[id2] || _getSelector(target, document2, options2);
    }
    const attachListener = topframe ? app.attachEventListener.bind(app) : app.nodes.attachNodeListener.bind(app.nodes);
    attachListener(document2.documentElement, "mouseover", (e) => {
      const target = getTarget(e.target, document2);
      if (target !== mouseTarget) {
        mouseTarget = target;
        mouseTargetTime = performance.now();
      }
    });
    attachListener(document2, "mousemove", (e) => {
      const [left, top] = app.observer.getDocumentOffset(document2);
      mousePositionX = e.clientX + left;
      mousePositionY = e.clientY + top;
      mousePositionChanged = true;
      const nextDirection = Math.sign(e.movementX);
      distance += Math.abs(e.movementX) + Math.abs(e.movementY);
      if (nextDirection !== direction) {
        direction = nextDirection;
        directionChangeCount++;
      }
    }, false);
    attachListener(document2, "click", (e) => {
      const target = getTarget(e.target, document2);
      if (!e.clientX && !e.clientY || target === null) {
        return;
      }
      const id2 = app.nodes.getID(target);
      if (id2 !== void 0) {
        const clickX = e.pageX;
        const clickY = e.pageY;
        const contentWidth = document2.documentElement.scrollWidth;
        const contentHeight = document2.documentElement.scrollHeight;
        const normalizedX = roundNumber(clickX / contentWidth);
        const normalizedY = roundNumber(clickY / contentHeight);
        sendMouseMove();
        app.send(MouseClick(id2, mouseTarget === target ? Math.round(performance.now() - mouseTargetTime) : 0, getTargetLabel(target), isClickable(target) && !disableClickmaps ? getSelector(id2, target, options) : "", normalizedX, normalizedY), true);
      }
      mouseTarget = null;
    });
  };
  app.nodes.attachNodeCallback((node) => {
    if (isDocument(node)) {
      patchDocument(node);
    }
  });
  patchDocument(document, true);
  app.ticker.attach(sendMouseMove, (options == null ? void 0 : options.trackingOffset) || 7);
}
function roundNumber(num) {
  return Math.round(num * 1e4);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/timing.js
function getPaintBlocks(resources) {
  const paintBlocks = [];
  const elements = document.getElementsByTagName("*");
  const styleURL = /url\(("[^"]*"|'[^']*'|[^)]*)\)/i;
  for (let i = 0; i < elements.length; i++) {
    const element = elements[i];
    let src = "";
    if (hasTag(element, "img")) {
      src = element.currentSrc || element.src;
    }
    if (!src) {
      const backgroundImage = getComputedStyle(element).getPropertyValue("background-image");
      if (backgroundImage) {
        const matches = styleURL.exec(backgroundImage);
        if (matches !== null) {
          src = matches[1];
          if (src.startsWith('"') || src.startsWith("'")) {
            src = src.substr(1, src.length - 2);
          }
        }
      }
    }
    if (!src)
      continue;
    const time = src.substr(0, 10) === "data:image" ? 0 : resources[src];
    if (time === void 0)
      continue;
    const rect = element.getBoundingClientRect();
    const top = Math.max(rect.top, 0);
    const left = Math.max(rect.left, 0);
    const bottom = Math.min(rect.bottom, window.innerHeight || document.documentElement && document.documentElement.clientHeight || 0);
    const right = Math.min(rect.right, window.innerWidth || document.documentElement && document.documentElement.clientWidth || 0);
    if (bottom <= top || right <= left)
      continue;
    const area = (bottom - top) * (right - left);
    paintBlocks.push({ time, area });
  }
  return paintBlocks;
}
function calculateSpeedIndex(firstContentfulPaint, paintBlocks) {
  let a = Math.max(document.documentElement && document.documentElement.clientWidth || 0, window.innerWidth || 0) * Math.max(document.documentElement && document.documentElement.clientHeight || 0, window.innerHeight || 0) / 10;
  let s = a * firstContentfulPaint;
  for (let i = 0; i < paintBlocks.length; i++) {
    const { time, area } = paintBlocks[i];
    a += area;
    s += area * (time > firstContentfulPaint ? time : firstContentfulPaint);
  }
  return a === 0 ? 0 : s / a;
}
function timing_default(app, opts) {
  const options = Object.assign({
    captureResourceTimings: true,
    capturePageLoadTimings: true,
    capturePageRenderTimings: true,
    excludedResourceUrls: []
  }, opts);
  if (!("PerformanceObserver" in window)) {
    options.captureResourceTimings = false;
  }
  if (!options.captureResourceTimings) {
    return;
  }
  let resources = {};
  function resourceTiming(entry) {
    var _a3;
    if (entry.duration < 0 || !isURL(entry.name) || app.isServiceURL(entry.name))
      return;
    if (resources !== null) {
      resources[entry.name] = entry.startTime + entry.duration;
    }
    let shouldSkip = false;
    (_a3 = options.excludedResourceUrls) == null ? void 0 : _a3.forEach((url) => {
      if (entry.name.startsWith(url)) {
        shouldSkip = true;
        return;
      }
    });
    if (shouldSkip) {
      return;
    }
    app.send(ResourceTiming(
      entry.startTime + getTimeOrigin(),
      entry.duration,
      entry.responseStart && entry.startTime ? entry.responseStart - entry.startTime : 0,
      entry.transferSize > entry.encodedBodySize ? entry.transferSize - entry.encodedBodySize : 0,
      entry.encodedBodySize || 0,
      entry.decodedBodySize || 0,
      entry.name,
      entry.initiatorType,
      entry.transferSize,
      // @ts-ignore
      entry.responseStatus && entry.responseStatus === 304 || entry.transferSize === 0
    ));
  }
  const observer = new PerformanceObserver((list) => list.getEntries().forEach(resourceTiming));
  let prevSessionID;
  app.attachStartCallback(function({ sessionID }) {
    if (sessionID !== prevSessionID) {
      performance.getEntriesByType("resource").forEach(resourceTiming);
      prevSessionID = sessionID;
    }
    observer.observe({ entryTypes: ["resource"] });
  });
  app.attachStopCallback(function() {
    observer.disconnect();
  });
  let firstPaint = 0, firstContentfulPaint = 0;
  if (options.capturePageLoadTimings) {
    let pageLoadTimingSent = false;
    app.ticker.attach(() => {
      if (pageLoadTimingSent) {
        return;
      }
      if (firstPaint === 0 || firstContentfulPaint === 0) {
        performance.getEntriesByType("paint").forEach((entry) => {
          const { name, startTime } = entry;
          switch (name) {
            case "first-paint":
              firstPaint = startTime;
              break;
            case "first-contentful-paint":
              firstContentfulPaint = startTime;
              break;
          }
        });
      }
      if (performance.timing.loadEventEnd || performance.now() > 3e4) {
        pageLoadTimingSent = true;
        const {
          // should be ok to use here, (https://github.com/mdn/content/issues/4713)
          // since it is compared with the values obtained on the page load (before any possible sleep state)
          // deprecated though
          navigationStart,
          requestStart,
          responseStart,
          responseEnd,
          domContentLoadedEventStart,
          domContentLoadedEventEnd,
          loadEventStart,
          loadEventEnd
        } = performance.timing;
        app.send(PageLoadTiming(requestStart - navigationStart || 0, responseStart - navigationStart || 0, responseEnd - navigationStart || 0, domContentLoadedEventStart - navigationStart || 0, domContentLoadedEventEnd - navigationStart || 0, loadEventStart - navigationStart || 0, loadEventEnd - navigationStart || 0, firstPaint, firstContentfulPaint));
      }
    }, 30);
  }
  if (options.capturePageRenderTimings) {
    let visuallyComplete = 0, interactiveWindowStartTime = 0, interactiveWindowTickTime = 0, paintBlocks = null;
    let pageRenderTimingSent = false;
    app.ticker.attach(() => {
      if (pageRenderTimingSent) {
        return;
      }
      const time = performance.now();
      if (resources !== null) {
        visuallyComplete = Math.max.apply(null, Object.keys(resources).map((k) => resources[k]));
        if (time - visuallyComplete > 1e3) {
          paintBlocks = getPaintBlocks(resources);
          resources = null;
        }
      }
      if (interactiveWindowTickTime !== null) {
        if (time - interactiveWindowTickTime > 50) {
          interactiveWindowStartTime = time;
        }
        interactiveWindowTickTime = time - interactiveWindowStartTime > 5e3 ? null : time;
      }
      if (paintBlocks !== null && interactiveWindowTickTime === null || time > 3e4) {
        pageRenderTimingSent = true;
        resources = null;
        const speedIndex = paintBlocks === null ? 0 : calculateSpeedIndex(firstContentfulPaint || firstPaint, paintBlocks);
        const { domContentLoadedEventEnd, navigationStart } = performance.timing;
        const timeToInteractive = interactiveWindowTickTime === null ? Math.max(interactiveWindowStartTime, firstContentfulPaint, domContentLoadedEventEnd - navigationStart || 0) : 0;
        app.send(PageRenderTiming(speedIndex, firstContentfulPaint > visuallyComplete ? firstContentfulPaint : visuallyComplete, timeToInteractive));
      }
    });
  }
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/scroll.js
function getDocumentScroll(doc) {
  const win = doc.defaultView;
  return [
    win && win.scrollX || doc.documentElement && doc.documentElement.scrollLeft || doc.body && doc.body.scrollLeft || 0,
    win && win.scrollY || doc.documentElement && doc.documentElement.scrollTop || doc.body && doc.body.scrollTop || 0
  ];
}
function scroll_default(app, insideIframe) {
  let documentScroll = false;
  const nodeScroll = /* @__PURE__ */ new Map();
  function setNodeScroll(target) {
    if (!isNode(target)) {
      return;
    }
    if (isElementNode(target)) {
      nodeScroll.set(target, [target.scrollLeft, target.scrollTop]);
    }
    if (isDocument(target)) {
      nodeScroll.set(target, getDocumentScroll(target));
    }
  }
  const sendSetViewportScroll = app.safe(() => {
    if (insideIframe) {
      return;
    }
    app.send(SetViewportScroll(...getDocumentScroll(document)));
  });
  const sendSetNodeScroll = app.safe((s, node) => {
    const id2 = app.nodes.getID(node);
    if (id2 !== void 0) {
      app.send(SetNodeScroll(id2, s[0], s[1]));
    }
  });
  app.attachStartCallback(sendSetViewportScroll);
  app.attachStopCallback(() => {
    documentScroll = false;
    nodeScroll.clear();
  });
  app.nodes.attachNodeCallback((node, isStart) => {
    if (isStart) {
      if (isElementNode(node) && node.scrollLeft + node.scrollTop > 0) {
        nodeScroll.set(node, [node.scrollLeft, node.scrollTop]);
      } else if (isDocument(node)) {
        nodeScroll.set(node, getDocumentScroll(node));
      }
    }
    if (isRootNode(node)) {
      app.nodes.attachNodeListener(node, "scroll", (e) => {
        setNodeScroll(e.target);
      });
    }
  });
  app.attachEventListener(document, "scroll", (e) => {
    const target = e.target;
    if (target === document) {
      documentScroll = true;
      return;
    }
    setNodeScroll(target);
  });
  app.ticker.attach(() => {
    if (documentScroll) {
      sendSetViewportScroll();
      documentScroll = false;
    }
    nodeScroll.forEach(sendSetNodeScroll);
    nodeScroll.clear();
  }, 5, false);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/viewport.js
function viewport_default(app) {
  let url, width, height;
  let navigationStart;
  let referrer = document.referrer;
  const sendSetPageLocation = app.safe(() => {
    const { URL: URL2 } = document;
    if (URL2 !== url) {
      url = URL2;
      app.send(SetPageLocation(url, referrer, navigationStart, document.title));
      navigationStart = 0;
      referrer = url;
    }
  });
  const sendSetViewportSize = app.safe(() => {
    const { innerWidth, innerHeight } = window;
    if (innerWidth !== width || innerHeight !== height) {
      width = innerWidth;
      height = innerHeight;
      app.send(SetViewportSize(width, height));
    }
  });
  const sendSetPageVisibility = document.hidden === void 0 ? Function.prototype : app.safe(() => app.send(SetPageVisibility(document.hidden)));
  app.attachStartCallback(() => {
    url = null;
    navigationStart = getTimeOrigin();
    width = height = -1;
    sendSetPageLocation();
    sendSetViewportSize();
    sendSetPageVisibility();
  });
  if (document.hidden !== void 0) {
    app.attachEventListener(document, "visibilitychange", sendSetPageVisibility, false, false);
  }
  app.ticker.attach(sendSetPageLocation, 1, false);
  app.ticker.attach(sendSetViewportSize, 5, false);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/constructedStyleSheets.js
function hasAdoptedSS(node) {
  return isRootNode(node) && // @ts-ignore
  !!node.adoptedStyleSheets;
}
var _id = 15;
function nextID() {
  return _id++;
}
var styleSheetIDMap = /* @__PURE__ */ new Map();
function constructedStyleSheets_default(app) {
  if (app === null) {
    return;
  }
  if (!hasAdoptedSS(document)) {
    return;
  }
  const styleSheetIDMap2 = /* @__PURE__ */ new Map();
  const adoptedStyleSheetsOwnings = /* @__PURE__ */ new Map();
  const sendAdoptedStyleSheetsUpdate = (root) => setTimeout(() => {
    let nodeID = app.nodes.getID(root);
    if (root === document) {
      nodeID = 0;
    }
    if (nodeID === void 0) {
      return;
    }
    let pastOwning = adoptedStyleSheetsOwnings.get(nodeID);
    if (!pastOwning) {
      pastOwning = [];
    }
    const nowOwning = [];
    const styleSheets = root.adoptedStyleSheets;
    if (styleSheets && Symbol.iterator in styleSheets) {
      for (const s of styleSheets) {
        let sheetID = styleSheetIDMap2.get(s);
        const init = !sheetID;
        if (!sheetID) {
          sheetID = nextID();
          styleSheetIDMap2.set(s, sheetID);
        }
        if (!pastOwning.includes(sheetID)) {
          app.send(AdoptedSSAddOwner(sheetID, nodeID));
        }
        if (init) {
          const rules = s.cssRules;
          for (let i = 0; i < rules.length; i++) {
            app.send(AdoptedSSInsertRuleURLBased(sheetID, rules[i].cssText, i, app.getBaseHref()));
          }
        }
        nowOwning.push(sheetID);
      }
    }
    if (Symbol.iterator in pastOwning) {
      for (const sheetID of pastOwning) {
        if (!nowOwning.includes(sheetID)) {
          app.send(AdoptedSSRemoveOwner(sheetID, nodeID));
        }
      }
    }
    adoptedStyleSheetsOwnings.set(nodeID, nowOwning);
  }, 20);
  function patchAdoptedStyleSheets(prototype) {
    const nativeAdoptedStyleSheetsDescriptor = Object.getOwnPropertyDescriptor(prototype, "adoptedStyleSheets");
    if (nativeAdoptedStyleSheetsDescriptor) {
      Object.defineProperty(prototype, "adoptedStyleSheets", {
        ...nativeAdoptedStyleSheetsDescriptor,
        set: function(value) {
          const retVal = nativeAdoptedStyleSheetsDescriptor.set.call(this, value);
          sendAdoptedStyleSheetsUpdate(this);
          return retVal;
        }
      });
    }
  }
  const patchContext = (context) => {
    if (context.__openreplay_adpss_patched__) {
      return;
    } else {
      context.__openreplay_adpss_patched__ = true;
    }
    patchAdoptedStyleSheets(context.Document.prototype);
    patchAdoptedStyleSheets(context.ShadowRoot.prototype);
    const { replace, replaceSync } = context.CSSStyleSheet.prototype;
    context.CSSStyleSheet.prototype.replace = function(text) {
      return replace.call(this, text).then((sheet) => {
        const sheetID = styleSheetIDMap2.get(this);
        if (sheetID) {
          app.send(AdoptedSSReplaceURLBased(sheetID, text, app.getBaseHref()));
        }
        return sheet;
      });
    };
    context.CSSStyleSheet.prototype.replaceSync = function(text) {
      const sheetID = styleSheetIDMap2.get(this);
      if (sheetID) {
        app.send(AdoptedSSReplaceURLBased(sheetID, text, app.getBaseHref()));
      }
      return replaceSync.call(this, text);
    };
  };
  patchContext(window);
  app.observer.attachContextCallback(app.safe(patchContext));
  app.attachStopCallback(() => {
    styleSheetIDMap2.clear();
    adoptedStyleSheetsOwnings.clear();
  });
  app.attachStartCallback(() => {
    sendAdoptedStyleSheetsUpdate(document);
  });
  app.nodes.attachNodeCallback((node) => {
    if (hasAdoptedSS(node)) {
      sendAdoptedStyleSheetsUpdate(node);
    }
  });
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/cssrules.js
function cssrules_default(app) {
  if (app === null) {
    return;
  }
  if (!window.CSSStyleSheet) {
    app.send(TechnicalInfo("no_stylesheet_prototype_in_window", ""));
    return;
  }
  const sendInsertDeleteRule = app.safe((sheet, index2, rule) => {
    const sheetID = styleSheetIDMap.get(sheet);
    if (!sheetID) {
      return;
    }
    if (typeof rule === "string") {
      app.send(AdoptedSSInsertRuleURLBased(sheetID, rule, index2, app.getBaseHref()));
    } else {
      app.send(AdoptedSSDeleteRule(sheetID, index2));
    }
  });
  const sendReplaceGroupingRule = app.safe((rule) => {
    let topmostRule = rule;
    while (topmostRule.parentRule) {
      topmostRule = topmostRule.parentRule;
    }
    const sheet = topmostRule.parentStyleSheet;
    if (!sheet) {
      app.debug.warn("No parent StyleSheet found for", topmostRule, rule);
      return;
    }
    const sheetID = styleSheetIDMap.get(sheet);
    if (!sheetID) {
      app.debug.warn("No sheedID found for", sheet, styleSheetIDMap);
      return;
    }
    const cssText = topmostRule.cssText;
    const ruleList = sheet.cssRules;
    const idx = Array.from(ruleList).indexOf(topmostRule);
    if (idx >= 0) {
      app.send(AdoptedSSInsertRuleURLBased(sheetID, cssText, idx, app.getBaseHref()));
      app.send(AdoptedSSDeleteRule(sheetID, idx + 1));
    } else {
      app.debug.warn("Rule index not found in", sheet, topmostRule);
    }
  });
  const patchContext = app.safe((context) => {
    const { insertRule, deleteRule } = context.CSSStyleSheet.prototype;
    const { insertRule: groupInsertRule, deleteRule: groupDeleteRule } = context.CSSGroupingRule.prototype;
    context.CSSStyleSheet.prototype.insertRule = function(rule, index2 = 0) {
      sendInsertDeleteRule(this, index2, rule);
      return insertRule.call(this, rule, index2);
    };
    context.CSSStyleSheet.prototype.deleteRule = function(index2) {
      sendInsertDeleteRule(this, index2);
      return deleteRule.call(this, index2);
    };
    context.CSSGroupingRule.prototype.insertRule = function(rule, index2 = 0) {
      const result = groupInsertRule.call(this, rule, index2);
      sendReplaceGroupingRule(this);
      return result;
    };
    context.CSSGroupingRule.prototype.deleteRule = function(index2 = 0) {
      const result = groupDeleteRule.call(this, index2);
      sendReplaceGroupingRule(this);
      return result;
    };
  });
  patchContext(window);
  app.observer.attachContextCallback(patchContext);
  app.nodes.attachNodeCallback((node) => {
    if (!hasTag(node, "style") || !node.sheet) {
      return;
    }
    if (node.textContent !== null && node.textContent.trim().length > 0) {
      return;
    }
    const nodeID = app.nodes.getID(node);
    if (!nodeID) {
      return;
    }
    const sheet = node.sheet;
    const sheetID = nextID();
    styleSheetIDMap.set(sheet, sheetID);
    app.send(AdoptedSSAddOwner(sheetID, nodeID));
    const rules = sheet.cssRules;
    for (let i = 0; i < rules.length; i++) {
      sendInsertDeleteRule(sheet, i, rules[i].cssText);
    }
  });
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/focus.js
function focus_default(app) {
  function sendSetNodeFocus(n) {
    const id2 = app.nodes.getID(n);
    if (id2 !== void 0) {
      app.send(SetNodeFocus(id2));
    }
  }
  let blurred = false;
  app.nodes.attachNodeCallback((node) => {
    if (!hasTag(node, "body")) {
      return;
    }
    app.nodes.attachNodeListener(node, "focus", (e) => {
      if (!isNode(e.target)) {
        return;
      }
      sendSetNodeFocus(e.target);
      blurred = false;
    });
    app.nodes.attachNodeListener(node, "blur", (e) => {
      if (e.relatedTarget === null) {
        blurred = true;
        setTimeout(() => {
          if (blurred) {
            app.send(SetNodeFocus(-1));
          }
        }, 0);
      }
    });
  });
  app.attachStartCallback(() => {
    let elem = document.activeElement;
    while (elem && hasTag(elem, "iframe") && elem.contentDocument) {
      elem = elem.contentDocument.activeElement;
    }
    if (elem && elem !== elem.ownerDocument.body) {
      sendSetNodeFocus(elem);
    }
  }, true);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/fonts.js
function fonts_default(app) {
  if (!window.FontFace) {
    return;
  }
  const docFonts = /* @__PURE__ */ new Map();
  const patchWindow = (wnd) => {
    class FontFaceInterceptor extends wnd.FontFace {
      constructor(...args) {
        if (typeof args[1] === "string") {
          let desc = "";
          if (args[2]) {
            app.safe(() => {
              desc = JSON.stringify(args[2]);
            });
          }
          const ffData = [args[0], args[1], desc];
          const ffDataArr = docFonts.get(wnd.document) || [];
          ffDataArr.push(ffData);
          docFonts.set(wnd.document, ffDataArr);
          const parentID = wnd === window ? 0 : app.nodes.getID(wnd.document);
          if (parentID === void 0) {
            return;
          }
          if (app.active()) {
            app.send(LoadFontFace(parentID, ...ffData));
          }
        }
        super(...args);
      }
    }
    wnd.FontFace = FontFaceInterceptor;
  };
  app.observer.attachContextCallback(patchWindow);
  patchWindow(window);
  app.nodes.attachNodeCallback(app.safe((node) => {
    if (!isDocument(node)) {
      return;
    }
    const ffDataArr = docFonts.get(node);
    if (!ffDataArr) {
      return;
    }
    const parentID = node.defaultView === window ? 0 : app.nodes.getID(node);
    if (parentID === void 0) {
      return;
    }
    ffDataArr.forEach((ffData) => {
      app.send(LoadFontFace(parentID, ...ffData));
    });
  }));
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/axiosSpy.js
function axiosSpy_default(app, instance, opts, sanitize, stringify) {
  app.debug.log("Openreplay: attaching axios spy to instance", instance);
  function captureResponseData(axiosResponseObj) {
    app.debug.log("Openreplay: capturing axios response data", axiosResponseObj);
    const { headers: reqHs, data: reqData, method, url, baseURL } = axiosResponseObj.config;
    const { data: rData, headers: rHs, status: globStatus, response } = axiosResponseObj;
    const { data: resData, headers: resHs, status: resStatus } = response || {};
    const ihOpt = opts.ignoreHeaders;
    const isHIgnoring = Array.isArray(ihOpt) ? (name) => ihOpt.includes(name) : () => ihOpt;
    function writeHeader(hsObj, header) {
      if (!isHIgnoring(header[0])) {
        hsObj[header[0]] = header[1];
      }
    }
    let requestHs = {};
    let responseHs = {};
    if (reqHs.toJSON) {
      requestHs = reqHs.toJSON();
    } else if (reqHs instanceof Headers) {
      reqHs.forEach((v, n) => writeHeader(requestHs, [n, v]));
    } else if (Array.isArray(reqHs)) {
      reqHs.forEach((h) => writeHeader(requestHs, h));
    } else if (typeof reqHs === "object") {
      Object.entries(reqHs).forEach((h) => writeHeader(requestHs, h));
    }
    const usedResHeader = resHs ? resHs : rHs;
    if (usedResHeader.toJSON) {
      responseHs = usedResHeader.toJSON();
    } else if (usedResHeader instanceof Headers) {
      usedResHeader.forEach((v, n) => writeHeader(responseHs, [n, v]));
    } else if (Array.isArray(usedResHeader)) {
      usedResHeader.forEach((h) => writeHeader(responseHs, h));
    } else if (typeof usedResHeader === "object") {
      Object.entries(usedResHeader).forEach(([n, v]) => {
        if (!isHIgnoring(n))
          responseHs[n] = v;
      });
    }
    const reqResInfo = sanitize({
      url,
      method: method || "",
      status: globStatus || resStatus || 0,
      request: {
        headers: requestHs,
        body: reqData
      },
      response: {
        headers: responseHs,
        body: resData || rData
      }
    });
    if (!reqResInfo) {
      app.debug.log("Openreplay: empty request/response info, skipping");
      return;
    }
    const requestStart = axiosResponseObj.config.__openreplay_timing;
    const duration = performance.now() - requestStart;
    app.debug.log("Openreplay: final req object", reqResInfo);
    app.send(NetworkRequest("xhr", String(method), String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), reqResInfo.status, requestStart + getTimeOrigin(), duration, 0));
  }
  function getStartTime(config2) {
    app.debug.log("Openreplay: capturing API request", config2);
    config2.__openreplay_timing = performance.now();
    if (opts.sessionTokenHeader) {
      const header = typeof opts.sessionTokenHeader === "string" ? opts.sessionTokenHeader : "X-OpenReplay-Session-Token";
      const headerValue = app.getSessionToken();
      if (headerValue) {
        config2.headers.set(header, headerValue);
      }
    }
    return config2;
  }
  function captureNetworkRequest(response) {
    if (opts.failuresOnly)
      return response;
    captureResponseData(response);
    return response;
  }
  function captureNetworkError(error) {
    app.debug.log("Openreplay: capturing API request error", error);
    if (isAxiosError(error) && Boolean(error.response)) {
      captureResponseData(error.response);
    } else if (error instanceof Error) {
      app.send(getExceptionMessage(error, []));
    }
    return Promise.reject(error);
  }
  function logRequestError(ev) {
    app.debug.log("Openreplay: failed API request, skipping", ev);
  }
  const reqInt = instance.interceptors.request.use(getStartTime, logRequestError, {
    synchronous: true
  });
  const resInt = instance.interceptors.response.use(captureNetworkRequest, captureNetworkError, {
    synchronous: true
  });
  app.attachStopCallback(() => {
    var _a3, _b2, _c, _d;
    (_b2 = (_a3 = instance.interceptors.request).eject) == null ? void 0 : _b2.call(_a3, reqInt);
    (_d = (_c = instance.interceptors.response).eject) == null ? void 0 : _d.call(_c, resInt);
  });
}
function isAxiosError(payload) {
  return isObject(payload) && payload.isAxiosError === true;
}
function isObject(thing) {
  return thing !== null && typeof thing === "object";
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/networkMessage.js
var RequestState;
(function(RequestState2) {
  RequestState2[RequestState2["UNSENT"] = 0] = "UNSENT";
  RequestState2[RequestState2["OPENED"] = 1] = "OPENED";
  RequestState2[RequestState2["HEADERS_RECEIVED"] = 2] = "HEADERS_RECEIVED";
  RequestState2[RequestState2["LOADING"] = 3] = "LOADING";
  RequestState2[RequestState2["DONE"] = 4] = "DONE";
})(RequestState || (RequestState = {}));
var NetworkMessage = class {
  constructor(ignoredHeaders = [], setSessionTokenHeader, sanitize) {
    this.ignoredHeaders = ignoredHeaders;
    this.setSessionTokenHeader = setSessionTokenHeader;
    this.sanitize = sanitize;
    this.id = "";
    this.name = "";
    this.method = "";
    this.url = "";
    this.status = 0;
    this.statusText = "";
    this.cancelState = 0;
    this.readyState = 0;
    this.header = {};
    this.responseType = "";
    this.requestHeader = {};
    this.responseSize = 0;
    this.responseSizeText = "";
    this.startTime = 0;
    this.endTime = 0;
    this.duration = 0;
    this.getData = {};
    this.requestData = null;
  }
  getMessage() {
    const { reqHs, resHs } = this.writeHeaders();
    const request = {
      headers: reqHs,
      body: this.method === "GET" ? JSON.stringify(this.getData) : this.requestData
    };
    const response = { headers: resHs, body: this.response };
    const messageInfo = this.sanitize({
      url: this.url,
      method: this.method,
      status: this.status,
      request,
      response
    });
    if (!messageInfo)
      return;
    return NetworkRequest(this.requestType, messageInfo.method, messageInfo.url, JSON.stringify(messageInfo.request), JSON.stringify(messageInfo.response), messageInfo.status, this.startTime + getTimeOrigin(), this.duration, this.responseSize);
  }
  writeHeaders() {
    const reqHs = {};
    Object.entries(this.requestHeader).forEach(([key, value]) => {
      if (this.isHeaderIgnored(key))
        return;
      reqHs[key] = value;
    });
    this.setSessionTokenHeader((name, value) => {
      reqHs[name] = value;
    });
    const resHs = {};
    Object.entries(this.header).forEach(([key, value]) => {
      if (this.isHeaderIgnored(key))
        return;
      resHs[key] = value;
    });
    return { reqHs, resHs };
  }
  isHeaderIgnored(key) {
    if (Array.isArray(this.ignoredHeaders)) {
      return this.ignoredHeaders.map((k) => k.toLowerCase()).includes(key.toLowerCase());
    } else {
      return this.ignoredHeaders;
    }
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/utils.js
var getStringResponseByType = (responseType, response) => {
  let result = "";
  switch (responseType) {
    case "":
    case "text":
    case "json":
      if (typeof response == "string") {
        result = response;
      } else if (isPureObject(response) || Array.isArray(response)) {
        result = JSON.stringify(response);
      } else if (typeof response !== "undefined") {
        result = Object.prototype.toString.call(response);
      }
      break;
    case "blob":
    case "document":
    case "arraybuffer":
    default:
      if (typeof response !== "undefined") {
        result = Object.prototype.toString.call(response);
      }
      break;
  }
  return result;
};
var genStringBody = (body) => {
  if (!body) {
    return null;
  }
  let result;
  if (typeof body === "string") {
    if (body[0] === "{" || body[0] === "[") {
      result = body;
    }
    const arr = body.split("&");
    if (arr.length === 1) {
      result = body;
    } else {
      result = arr.join(",");
    }
  } else if (isIterable(body)) {
    const arr = [];
    for (const [key, value] of body) {
      arr.push(`${key}=${typeof value === "string" ? value : "[object Object]"}`);
    }
    result = arr.join(",");
  } else if (body instanceof Blob || body instanceof ReadableStream || body instanceof ArrayBuffer) {
    result = "byte data";
  } else if (isPureObject(body)) {
    result = body;
  } else {
    result = `can't parse body ${typeof body}`;
  }
  return result;
};
var genGetDataByUrl = (url, getData = {}) => {
  if (!isPureObject(getData)) {
    getData = {};
  }
  let query = url ? url.split("?") : [];
  query.shift();
  if (query.length > 0) {
    query = query.join("?").split("&");
    for (const q of query) {
      const kv = q.split("=");
      try {
        getData[kv[0]] = decodeURIComponent(kv[1]);
      } catch (e) {
        getData[kv[0]] = kv[1];
      }
    }
  }
  return getData;
};
function isPureObject(input) {
  return null !== input && typeof input === "object";
}
function isIterable(value) {
  if (value === null || value === void 0) {
    return false;
  }
  if (ArrayBuffer.isView(value)) {
    return false;
  }
  return typeof Symbol !== "undefined" && typeof value[Symbol.iterator] === "function";
}
function formatByteSize(bytes) {
  if (bytes <= 0) {
    return "";
  }
  if (bytes >= 1e3 * 1e3) {
    return (bytes / 1e3 / 1e3).toFixed(1) + " MB";
  }
  if (bytes >= 1e3) {
    return (bytes / 1e3).toFixed(1) + " KB";
  }
  return `${bytes}B`;
}
var getURL = (urlString) => {
  if (urlString.startsWith("//")) {
    const baseUrl = new URL(window.location.href);
    urlString = `${baseUrl.protocol}${urlString}`;
  }
  if (urlString.startsWith("http")) {
    return new URL(urlString);
  } else {
    return new URL(urlString, window.location.href);
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/fetchProxy.js
var ResponseProxyHandler = class {
  constructor(resp, item) {
    this.resp = resp;
    this.item = item;
    this.mockReader();
  }
  set(target, key, value) {
    return Reflect.set(target, key, value);
  }
  get(target, key) {
    const value = Reflect.get(target, key);
    switch (key) {
      case "arrayBuffer":
      case "blob":
      case "formData":
      case "json":
      case "text":
        return () => {
          this.item.responseType = key.toLowerCase();
          return value.apply(target).then((resp) => {
            this.item.response = getStringResponseByType(this.item.responseType, resp);
            return resp;
          });
        };
    }
    if (typeof value === "function") {
      return value.bind(target);
    } else {
      return value;
    }
  }
  mockReader() {
    let readerReceivedValue;
    if (!this.resp.body) {
      return;
    }
    if (typeof this.resp.body.getReader !== "function") {
      return;
    }
    const _getReader = this.resp.body.getReader;
    this.resp.body.getReader = () => {
      const reader = _getReader.apply(this.resp.body);
      if (this.item.readyState === RequestState.DONE) {
        return reader;
      }
      const _read = reader.read;
      const _cancel = reader.cancel;
      this.item.responseType = "arraybuffer";
      reader.read = () => {
        return _read.apply(reader).then((result) => {
          if (!readerReceivedValue) {
            readerReceivedValue = new Uint8Array(result.value);
          } else {
            const newValue = new Uint8Array(readerReceivedValue.length + result.value.length);
            newValue.set(readerReceivedValue);
            newValue.set(result.value, readerReceivedValue.length);
            readerReceivedValue = newValue;
          }
          this.item.endTime = performance.now();
          this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);
          this.item.readyState = result.done ? 4 : 3;
          this.item.statusText = result.done ? String(this.item.status) : "Loading";
          this.item.responseSize = readerReceivedValue.length;
          this.item.responseSizeText = formatByteSize(this.item.responseSize);
          if (result.done) {
            this.item.response = getStringResponseByType(this.item.responseType, readerReceivedValue);
          }
          return result;
        });
      };
      reader.cancel = (...args) => {
        this.item.cancelState = 2;
        this.item.statusText = "Cancel";
        this.item.endTime = performance.now();
        this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);
        this.item.response = getStringResponseByType(this.item.responseType, readerReceivedValue);
        return _cancel.apply(reader, args);
      };
      return reader;
    };
  }
};
var FetchProxyHandler = class {
  constructor(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
    this.ignoredHeaders = ignoredHeaders;
    this.setSessionTokenHeader = setSessionTokenHeader;
    this.sanitize = sanitize;
    this.sendMessage = sendMessage;
    this.isServiceUrl = isServiceUrl;
    this.tokenUrlMatcher = tokenUrlMatcher;
  }
  apply(target, _, argsList) {
    const input = argsList[0];
    const init = argsList[1];
    if (!input || // @ts-ignore
    typeof input !== "string" && !(input == null ? void 0 : input.url)) {
      return target.apply(window, argsList);
    }
    const isORUrl = input instanceof URL || typeof input === "string" ? this.isServiceUrl(String(input)) : this.isServiceUrl(String(input.url));
    if (isORUrl) {
      return target.apply(window, argsList);
    }
    const item = new NetworkMessage(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);
    this.beforeFetch(item, input, init);
    this.setSessionTokenHeader((name, value) => {
      if (this.tokenUrlMatcher !== void 0) {
        if (!this.tokenUrlMatcher(item.url)) {
          return;
        }
      }
      if (argsList[1] === void 0 && argsList[0] instanceof Request) {
        return argsList[0].headers.append(name, value);
      } else {
        if (!argsList[1])
          argsList[1] = {};
        if (argsList[1].headers === void 0) {
          argsList[1] = { ...argsList[1], headers: {} };
        }
        if (argsList[1].headers instanceof Headers) {
          argsList[1].headers.append(name, value);
        } else if (Array.isArray(argsList[1].headers)) {
          argsList[1].headers.push([name, value]);
        } else {
          argsList[1].headers[name] = value;
        }
      }
    });
    return target.apply(window, argsList).then(this.afterFetch(item)).catch((e) => {
      item.endTime = performance.now();
      item.duration = item.endTime - (item.startTime || item.endTime);
      throw e;
    });
  }
  beforeFetch(item, input, init) {
    let url, method = "GET", requestHeader = {};
    if (typeof input === "string") {
      method = (init == null ? void 0 : init.method) || "GET";
      url = getURL(input);
      requestHeader = (init == null ? void 0 : init.headers) || {};
    } else {
      method = input.method || "GET";
      url = getURL(input.url);
      requestHeader = input.headers;
    }
    item.method = method;
    item.requestType = "fetch";
    item.requestHeader = requestHeader;
    item.url = url.toString();
    item.name = (url.pathname.split("/").pop() || "") + url.search;
    item.status = 0;
    item.statusText = "Pending";
    item.readyState = 1;
    if (!item.startTime) {
      item.startTime = performance.now();
    }
    if (Object.prototype.toString.call(requestHeader) === "[object Headers]") {
      item.requestHeader = {};
      for (const [key, value] of requestHeader) {
        item.requestHeader[key] = value;
      }
    } else {
      item.requestHeader = requestHeader;
    }
    if (url.search && url.searchParams) {
      item.getData = {};
      for (const [key, value] of url.searchParams) {
        item.getData[key] = value;
      }
    }
    if (init == null ? void 0 : init.body) {
      item.requestData = genStringBody(init.body);
    }
  }
  afterFetch(item) {
    return (resp) => {
      item.endTime = performance.now();
      item.duration = item.endTime - (item.startTime || item.endTime);
      item.status = resp.status;
      item.statusText = String(resp.status);
      let isChunked = false;
      item.header = {};
      for (const [key, value] of resp.headers) {
        item.header[key] = value;
        isChunked = value.toLowerCase().indexOf("chunked") > -1 ? true : isChunked;
      }
      if (isChunked) {
        item.readyState = 3;
      } else {
        item.readyState = 4;
        this.handleResponseBody(resp.clone(), item).then((responseValue) => {
          item.responseSize = typeof responseValue === "string" ? responseValue.length : responseValue.byteLength;
          item.responseSizeText = formatByteSize(item.responseSize);
          item.response = getStringResponseByType(item.responseType, responseValue);
          const msg = item.getMessage();
          if (msg) {
            this.sendMessage(msg);
          }
        }).catch((e) => {
          if (e.name !== "AbortError") {
            throw e;
          } else {
          }
        });
      }
      return new Proxy(resp, new ResponseProxyHandler(resp, item));
    };
  }
  handleResponseBody(resp, item) {
    const contentType = resp.headers.get("content-type");
    if (contentType && contentType.includes("application/json")) {
      item.responseType = "json";
      return resp.text();
    } else if (contentType && (contentType.includes("text/html") || contentType.includes("text/plain"))) {
      item.responseType = "text";
      return resp.text();
    } else {
      item.responseType = "arraybuffer";
      return resp.arrayBuffer();
    }
  }
};
var FetchProxy = class {
  static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
    return new Proxy(fetch, new FetchProxyHandler(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher));
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/xhrProxy.js
var XHRProxyHandler = class {
  constructor(XMLReq, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
    this.ignoredHeaders = ignoredHeaders;
    this.setSessionTokenHeader = setSessionTokenHeader;
    this.sanitize = sanitize;
    this.sendMessage = sendMessage;
    this.isServiceUrl = isServiceUrl;
    this.tokenUrlMatcher = tokenUrlMatcher;
    this.XMLReq = XMLReq;
    this.XMLReq.onreadystatechange = () => {
      this.onReadyStateChange();
    };
    this.XMLReq.onabort = () => {
      this.onAbort();
    };
    this.XMLReq.ontimeout = () => {
      this.onTimeout();
    };
    this.item = new NetworkMessage(ignoredHeaders, setSessionTokenHeader, sanitize);
    this.item.requestType = "xhr";
  }
  get(target, key) {
    switch (key) {
      case "open":
        return this.getOpen(target);
      case "send":
        this.setSessionTokenHeader((name, value2) => {
          if (this.tokenUrlMatcher !== void 0) {
            if (!this.tokenUrlMatcher(this.item.url)) {
              return;
            }
          }
          target.setRequestHeader(name, value2);
        });
        return this.getSend(target);
      case "setRequestHeader":
        return this.getSetRequestHeader(target);
      default:
        const value = Reflect.get(target, key);
        if (typeof value === "function") {
          return value.bind(target);
        } else {
          return value;
        }
    }
  }
  set(target, key, value) {
    switch (key) {
      case "onreadystatechange":
        return this.setOnReadyStateChange(target, key, value);
      case "onabort":
        return this.setOnAbort(target, key, value);
      case "ontimeout":
        return this.setOnTimeout(target, key, value);
      default:
    }
    return Reflect.set(target, key, value);
  }
  onReadyStateChange() {
    if (this.item.url && this.isServiceUrl(this.item.url))
      return;
    this.item.readyState = this.XMLReq.readyState;
    this.item.responseType = this.XMLReq.responseType;
    this.item.endTime = performance.now();
    this.item.duration = this.item.endTime - this.item.startTime;
    this.updateItemByReadyState();
    setTimeout(() => {
      this.item.response = getStringResponseByType(this.item.responseType, this.item.response);
    }, 0);
    if (this.XMLReq.readyState === RequestState.DONE) {
      const msg = this.item.getMessage();
      if (msg) {
        this.sendMessage(msg);
      }
    }
  }
  onAbort() {
    this.item.cancelState = 1;
    this.item.statusText = "Abort";
    const msg = this.item.getMessage();
    if (msg) {
      this.sendMessage(msg);
    }
  }
  onTimeout() {
    this.item.cancelState = 3;
    this.item.statusText = "Timeout";
    const msg = this.item.getMessage();
    if (msg) {
      this.sendMessage(msg);
    }
  }
  getOpen(target) {
    const targetFunction = Reflect.get(target, "open");
    return (...args) => {
      var _a3, _b2;
      const method = args[0];
      const url = args[1];
      this.item.method = method ? method.toUpperCase() : "GET";
      this.item.url = ((_a3 = url.toString) == null ? void 0 : _a3.call(url)) || "";
      this.item.name = ((_b2 = this.item.url) == null ? void 0 : _b2.replace(new RegExp("/*$"), "").split("/").pop()) ?? "";
      this.item.getData = genGetDataByUrl(this.item.url, {});
      return targetFunction.apply(target, args);
    };
  }
  getSend(target) {
    const targetFunction = Reflect.get(target, "send");
    return (...args) => {
      const data = args[0];
      this.item.requestData = genStringBody(data);
      return targetFunction.apply(target, args);
    };
  }
  getSetRequestHeader(target) {
    const targetFunction = Reflect.get(target, "setRequestHeader");
    return (...args) => {
      if (!this.item.requestHeader) {
        this.item.requestHeader = {};
      }
      this.item.requestHeader[args[0]] = args[1];
      return targetFunction.apply(target, args);
    };
  }
  setOnReadyStateChange(target, key, orscFunction) {
    return Reflect.set(target, key, (...args) => {
      this.onReadyStateChange();
      orscFunction == null ? void 0 : orscFunction.apply(target, args);
    });
  }
  setOnAbort(target, key, oaFunction) {
    return Reflect.set(target, key, (...args) => {
      this.onAbort();
      oaFunction.apply(target, args);
    });
  }
  setOnTimeout(target, key, otFunction) {
    return Reflect.set(target, key, (...args) => {
      this.onTimeout();
      otFunction.apply(target, args);
    });
  }
  /**
   * Update item's properties according to readyState.
   */
  updateItemByReadyState() {
    switch (this.XMLReq.readyState) {
      case RequestState.UNSENT:
      case RequestState.OPENED:
        this.item.status = RequestState.UNSENT;
        this.item.statusText = "Pending";
        if (!this.item.startTime) {
          this.item.startTime = performance.now();
        }
        break;
      case RequestState.HEADERS_RECEIVED:
        this.item.status = this.XMLReq.status;
        this.item.statusText = "Loading";
        this.item.header = {};
        const header = this.XMLReq.getAllResponseHeaders() || "", headerArr = header.split("\n");
        for (let i = 0; i < headerArr.length; i++) {
          const line = headerArr[i];
          if (!line) {
            continue;
          }
          const arr = line.split(": ");
          const key = arr[0];
          this.item.header[key] = arr.slice(1).join(": ");
        }
        break;
      case RequestState.LOADING:
        this.item.status = this.XMLReq.status;
        this.item.statusText = "Loading";
        if (!!this.XMLReq.response && this.XMLReq.response.length) {
          this.item.responseSize = this.XMLReq.response.length;
          this.item.responseSizeText = formatByteSize(this.item.responseSize);
        }
        break;
      case RequestState.DONE:
        this.item.status = this.XMLReq.status || this.item.status || 0;
        this.item.statusText = String(this.item.status);
        this.item.endTime = performance.now();
        this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);
        this.item.response = this.XMLReq.response;
        if (!!this.XMLReq.response && this.XMLReq.response.length) {
          this.item.responseSize = this.XMLReq.response.length;
          this.item.responseSizeText = formatByteSize(this.item.responseSize);
        }
        break;
      default:
        this.item.status = this.XMLReq.status;
        this.item.statusText = "Unknown";
        break;
    }
  }
};
var XHRProxy = class {
  static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
    return new Proxy(XMLHttpRequest, {
      construct(original) {
        const XMLReq = new original();
        return new Proxy(XMLReq, new XHRProxyHandler(XMLReq, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher));
      }
    });
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/beaconProxy.js
var getContentType = (data) => {
  if (data instanceof Blob) {
    return data.type;
  }
  if (data instanceof FormData) {
    return "multipart/form-data";
  }
  if (data instanceof URLSearchParams) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  return "text/plain;charset=UTF-8";
};
var BeaconProxyHandler = class {
  constructor(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl) {
    this.ignoredHeaders = ignoredHeaders;
    this.setSessionTokenHeader = setSessionTokenHeader;
    this.sanitize = sanitize;
    this.sendMessage = sendMessage;
    this.isServiceUrl = isServiceUrl;
  }
  apply(target, thisArg, argsList) {
    const urlString = argsList[0];
    const data = argsList[1];
    const item = new NetworkMessage(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);
    if (this.isServiceUrl(urlString)) {
      return target.apply(thisArg, argsList);
    }
    const url = getURL(urlString);
    item.method = "POST";
    item.url = urlString;
    item.name = (url.pathname.split("/").pop() || "") + url.search;
    item.requestType = "beacon";
    item.requestHeader = { "Content-Type": getContentType(data) };
    item.status = 0;
    item.statusText = "Pending";
    if (url.search && url.searchParams) {
      item.getData = {};
      for (const [key, value] of url.searchParams) {
        item.getData[key] = value;
      }
    }
    item.requestData = genStringBody(data);
    if (!item.startTime) {
      item.startTime = performance.now();
    }
    const isSuccess = target.apply(thisArg, argsList);
    if (isSuccess) {
      item.endTime = performance.now();
      item.duration = item.endTime - (item.startTime || item.endTime);
      item.status = 0;
      item.statusText = "Sent";
      item.readyState = 4;
    } else {
      item.status = 500;
      item.statusText = "Unknown";
    }
    const msg = item.getMessage();
    if (msg) {
      this.sendMessage(msg);
    }
    return isSuccess;
  }
};
var BeaconProxy = class _BeaconProxy {
  static hasSendBeacon() {
    return !!_BeaconProxy.origSendBeacon;
  }
  static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl) {
    if (!_BeaconProxy.hasSendBeacon()) {
      return void 0;
    }
    return new Proxy(_BeaconProxy.origSendBeacon, new BeaconProxyHandler(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl));
  }
};
var _a2;
BeaconProxy.origSendBeacon = (_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.sendBeacon;

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/index.js
var getWarning = (api) => console.warn(`Openreplay: Can't find ${api} in global context. 
If you're using serverside rendering in your app, make sure that tracker is loaded dynamically, otherwise ${api} won't be tracked.`);
function setProxy(context, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
  var _a3;
  if (context.XMLHttpRequest) {
    context.XMLHttpRequest = XHRProxy.create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher);
  } else {
    getWarning("XMLHttpRequest");
  }
  if (context.fetch) {
    context.fetch = FetchProxy.create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher);
  } else {
    getWarning("fetch");
  }
  if ((_a3 = context == null ? void 0 : context.navigator) == null ? void 0 : _a3.sendBeacon) {
    context.navigator.sendBeacon = BeaconProxy.create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl);
  }
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/network.js
function getXHRRequestDataObject(xhr) {
  if (!xhr.__or_req_data__) {
    xhr.__or_req_data__ = { body: void 0, headers: {} };
  }
  return xhr.__or_req_data__;
}
function strMethod(method) {
  return typeof method === "string" ? method.toUpperCase() : "GET";
}
function network_default(app, opts = {}) {
  const options = Object.assign({
    failuresOnly: false,
    ignoreHeaders: ["cookie", "set-cookie", "authorization"],
    capturePayload: false,
    sessionTokenHeader: false,
    captureInIframes: true,
    axiosInstances: void 0,
    useProxy: true
  }, opts);
  if (options.useProxy === false) {
    app.debug.warn("Network module is migrating to proxy api, to gradually migrate and test it set useProxy to true");
  }
  const ignoreHeaders = options.ignoreHeaders;
  const isHIgnored = Array.isArray(ignoreHeaders) ? (name) => ignoreHeaders.includes(name) : () => ignoreHeaders;
  const stHeader = options.sessionTokenHeader === true ? "X-OpenReplay-SessionToken" : options.sessionTokenHeader;
  function setSessionTokenHeader(setRequestHeader) {
    if (stHeader) {
      const sessionToken = app.getSessionToken();
      if (sessionToken) {
        app.safe(setRequestHeader)(stHeader, sessionToken);
      }
    }
  }
  function sanitize(reqResInfo) {
    if (!options.capturePayload) {
      delete reqResInfo.request.body;
      delete reqResInfo.response.body;
    }
    if (options.sanitizer) {
      const resBody = reqResInfo.response.body;
      if (typeof resBody === "string") {
        try {
          reqResInfo.response.body = JSON.parse(resBody);
        } catch {
        }
      }
      return options.sanitizer(reqResInfo);
    }
    return reqResInfo;
  }
  function stringify(r) {
    if (r && typeof r.body !== "string") {
      try {
        r.body = JSON.stringify(r.body);
      } catch {
        r.body = "<unable to stringify>";
        app.notify.warn("Openreplay fetch couldn't stringify body:", r.body);
      }
    }
    return JSON.stringify(r);
  }
  const patchWindow = (context) => {
    if (options.useProxy) {
      return setProxy(context, options.ignoreHeaders, setSessionTokenHeader, sanitize, (message) => app.send(message), (url) => app.isServiceURL(url), options.tokenUrlMatcher);
    }
    const origFetch = context.fetch.bind(context);
    const trackFetch = (input, init = {}) => {
      if (!(typeof input === "string" || input instanceof URL) || app.isServiceURL(String(input))) {
        return origFetch(input, init);
      }
      setSessionTokenHeader(function(name, value) {
        if (init.headers === void 0) {
          init.headers = {};
        }
        if (init.headers instanceof Headers) {
          init.headers.append(name, value);
        } else if (Array.isArray(init.headers)) {
          init.headers.push([name, value]);
        } else {
          init.headers[name] = value;
        }
      });
      const startTime = performance.now();
      return origFetch(input, init).then((response) => {
        const duration = performance.now() - startTime;
        if (options.failuresOnly && response.status < 400) {
          return response;
        }
        const r = response.clone();
        r.text().then((text) => {
          const reqHs = {};
          const resHs = {};
          if (ignoreHeaders !== true) {
            const writeReqHeader = ([n, v]) => {
              if (!isHIgnored(n)) {
                reqHs[n] = v;
              }
            };
            if (init.headers instanceof Headers) {
              init.headers.forEach((v, n) => writeReqHeader([n, v]));
            } else if (Array.isArray(init.headers)) {
              init.headers.forEach(writeReqHeader);
            } else if (typeof init.headers === "object") {
              Object.entries(init.headers).forEach(writeReqHeader);
            }
            r.headers.forEach((v, n) => {
              if (!isHIgnored(n))
                resHs[n] = v;
            });
          }
          const method = strMethod(init.method);
          const reqResInfo = sanitize({
            url: String(input),
            method,
            status: r.status,
            request: {
              headers: reqHs,
              // @ts-ignore
              body: init.body || null
            },
            response: {
              headers: resHs,
              body: text
            }
          });
          if (!reqResInfo) {
            return;
          }
          app.send(NetworkRequest("fetch", method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), r.status, startTime + getTimeOrigin(), duration, 0));
        }).catch((e) => app.debug.error("Could not process Fetch response:", e));
        return response;
      });
    };
    context.fetch = trackFetch;
    const nativeOpen = context.XMLHttpRequest.prototype.open;
    const nativeSetRequestHeader = context.XMLHttpRequest.prototype.setRequestHeader;
    const nativeSend = context.XMLHttpRequest.prototype.send;
    function trackXMLHttpReqOpen(initMethod, url) {
      const xhr = this;
      setSessionTokenHeader((name, value) => xhr.setRequestHeader(name, value));
      let startTime = 0;
      xhr.addEventListener("loadstart", (e) => {
        startTime = e.timeStamp;
      });
      xhr.addEventListener("load", app.safe((e) => {
        const { headers: reqHs, body: reqBody } = getXHRRequestDataObject(xhr);
        const duration = startTime > 0 ? e.timeStamp - startTime : 0;
        const hString = xhr.getAllResponseHeaders() || "";
        const headersArr = hString.trim().split(/[\r\n]+/);
        const headerMap = {};
        headersArr.forEach(function(line) {
          const parts = line.split(": ");
          const header = parts.shift();
          if (!isHIgnored(header)) {
            headerMap[header] = parts.join(": ");
          }
        });
        const method = strMethod(initMethod);
        const reqResInfo = sanitize({
          url: String(url),
          method,
          status: xhr.status,
          request: {
            headers: reqHs,
            // @ts-ignore
            body: reqBody || null
          },
          response: {
            headers: headerMap,
            body: xhr.response
          }
        });
        if (!reqResInfo) {
          return;
        }
        app.send(NetworkRequest("xhr", method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), xhr.status, startTime + getTimeOrigin(), duration, 0));
      }));
      return nativeOpen.apply(this, arguments);
    }
    function trackXHRSend(body) {
      const rdo = getXHRRequestDataObject(this);
      rdo.body = body;
      return nativeSend.apply(this, arguments);
    }
    function trackSetReqHeader(name, value) {
      if (!isHIgnored(name)) {
        const rdo = getXHRRequestDataObject(this);
        rdo.headers[name] = value;
      }
      return nativeSetRequestHeader.apply(this, arguments);
    }
    if (!options.axiosInstances) {
      context.XMLHttpRequest.prototype.open = trackXMLHttpReqOpen;
      context.XMLHttpRequest.prototype.send = trackXHRSend;
      context.XMLHttpRequest.prototype.setRequestHeader = trackSetReqHeader;
    }
  };
  patchWindow(window);
  if (options.axiosInstances) {
    options.axiosInstances.forEach((axiosInstance) => {
      axiosSpy_default(app, axiosInstance, options, sanitize, stringify);
    });
  }
  if (options.captureInIframes) {
    app.observer.attachContextCallback(app.safe(patchWindow));
  }
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/selection.js
function selection(app) {
  app.attachEventListener(document, "selectionchange", () => {
    const selection2 = document.getSelection();
    if (selection2 !== null && !selection2.isCollapsed) {
      const selectionStart = app.nodes.getID(selection2.anchorNode);
      const selectionEnd = app.nodes.getID(selection2.focusNode);
      const selectedText = selection2.toString().replace(/\s+/g, " ");
      if (selectionStart && selectionEnd) {
        app.send(SelectionChange(selectionStart, selectionEnd, selectedText));
      }
    } else {
      app.send(SelectionChange(-1, -1, ""));
    }
  });
}
var selection_default = selection;

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/tabs.js
function tabs_default(app) {
  function changeTab() {
    if (!document.hidden) {
      app.debug.log("Openreplay: tab change to" + app.session.getTabId());
      app.send(TabChange(app.session.getTabId()));
    }
  }
  app.attachEventListener(window, "focus", changeTab, false, false);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/index.js
var Messages = messages_gen_exports;
var DOCS_SETUP = "/installation/javascript-sdk";
function processOptions(obj) {
  if (obj == null) {
    console.error(`OpenReplay: invalid options argument type. Please, check documentation on ${DOCS_HOST}${DOCS_SETUP}`);
    return false;
  }
  if (typeof obj.projectKey !== "string") {
    if (typeof obj.projectKey !== "number") {
      if (typeof obj.projectID !== "number") {
        console.error(`OpenReplay: projectKey is missing or wrong type (string is expected). Please, check ${DOCS_HOST}${DOCS_SETUP} for more information.`);
        return false;
      } else {
        obj.projectKey = obj.projectID.toString();
        deprecationWarn("`projectID` option", "`projectKey` option", DOCS_SETUP);
      }
    } else {
      console.warn("OpenReplay: projectKey is expected to have a string type.");
      obj.projectKey = obj.projectKey.toString();
    }
  }
  if (obj.sessionToken != null) {
    deprecationWarn("`sessionToken` option", "`sessionHash` start() option", "/");
  }
  return true;
}
var API = class {
  constructor(options) {
    var _a3;
    this.options = options;
    this.app = null;
    this.crossdomainMode = false;
    this.checkDoNotTrack = () => {
      return this.options.respectDoNotTrack && (navigator.doNotTrack == "1" || // @ts-ignore
      window.doNotTrack == "1");
    };
    this.signalStartIssue = (reason, missingApi) => {
      const doNotTrack2 = this.checkDoNotTrack();
      const req = new XMLHttpRequest();
      const orig = this.options.ingestPoint || DEFAULT_INGEST_POINT;
      req.open("POST", orig + "/v1/web/not-started");
      req.send(JSON.stringify({
        trackerVersion: "14.0.3",
        projectKey: this.options.projectKey,
        doNotTrack: doNotTrack2,
        reason: missingApi.length ? `missing api: ${missingApi.join(",")}` : reason
      }));
    };
    this.restartCanvasTracking = () => {
      if (this.app === null) {
        return;
      }
      this.app.restartCanvasTracking();
    };
    this.handleError = (e, metadata = {}) => {
      if (this.app === null) {
        return;
      }
      if (e instanceof Error) {
        const msg = getExceptionMessage(e, [], metadata);
        this.app.send(msg);
      } else if (e instanceof ErrorEvent || "PromiseRejectionEvent" in window && e instanceof PromiseRejectionEvent) {
        const msg = getExceptionMessageFromEvent(e, void 0, metadata);
        if (msg != null) {
          this.app.send(msg);
        }
      }
    };
    this.crossdomainMode = Boolean(inIframe() && ((_a3 = options.crossdomain) == null ? void 0 : _a3.enabled));
    if (!IN_BROWSER || !processOptions(options)) {
      return;
    }
    if (window.__OPENREPLAY__) {
      console.error("OpenReplay: one tracker instance has been initialised already");
      return;
    }
    if (!options.__DISABLE_SECURE_MODE && location.protocol !== "https:") {
      console.error("OpenReplay: Your website must be publicly accessible and running on SSL in order for OpenReplay to properly capture and replay the user session. You can disable this check by setting `__DISABLE_SECURE_MODE` option to `true` if you are testing in localhost. Keep in mind, that asset files on a local machine are not available to the outside world. This might affect tracking if you use css files.");
      return;
    }
    const doNotTrack = this.checkDoNotTrack();
    const failReason = [];
    const conditions = [
      "Map",
      "Set",
      "MutationObserver",
      "performance",
      "timing",
      "startsWith",
      "Blob",
      "Worker"
    ];
    if (doNotTrack) {
      failReason.push("doNotTrack");
    } else {
      for (const condition of conditions) {
        if (condition === "timing") {
          if ("performance" in window && !(condition in performance)) {
            failReason.push(condition);
            break;
          }
        } else if (condition === "startsWith") {
          if (!(condition in String.prototype)) {
            failReason.push(condition);
            break;
          }
        } else {
          if (!(condition in window)) {
            failReason.push(condition);
            break;
          }
        }
      }
    }
    if (failReason.length > 0) {
      const missingApi = failReason.join(",");
      console.error(`OpenReplay: browser doesn't support API required for tracking or doNotTrack is set to 1. Reason: ${missingApi}`);
      this.signalStartIssue("missing_api", failReason);
      return;
    }
    const app = new App(options.projectKey, options.sessionToken, options, this.signalStartIssue, this.crossdomainMode);
    this.app = app;
    if (!this.crossdomainMode) {
      viewport_default(app);
      connection_default(app);
      performance_default(app, options);
      tabs_default(app);
    }
    mouse_default(app, options.mouse);
    scroll_default(app, this.crossdomainMode);
    cssrules_default(app);
    constructedStyleSheets_default(app);
    console_default(app, options);
    exception_default(app, options);
    img_default(app);
    input_default(app, options);
    timing_default(app, options);
    focus_default(app);
    fonts_default(app);
    network_default(app, options.network);
    selection_default(app);
    window.__OPENREPLAY__ = this;
    if (options.flags && options.flags.onFlagsLoad) {
      this.onFlagsLoad(options.flags.onFlagsLoad);
    }
    const wOpen = window.open;
    if (options.autoResetOnWindowOpen || options.resetTabOnWindowOpen) {
      app.attachStartCallback(() => {
        const tabId = app.getTabId();
        const sessStorage = app.sessionStorage ?? window.sessionStorage;
        window.open = function(...args) {
          if (options.autoResetOnWindowOpen) {
            app.resetNextPageSession(true);
          }
          if (options.resetTabOnWindowOpen) {
            sessStorage.removeItem(options.session_tabid_key || "__openreplay_tabid");
          }
          app.resetNextPageSession(false);
          sessStorage.setItem(options.session_tabid_key || "__openreplay_tabid", tabId);
          return wOpen.call(window, ...args);
        };
      });
      app.attachStopCallback(() => {
        window.open = wOpen;
      });
    }
  }
  isFlagEnabled(flagName) {
    return this.featureFlags.isFlagEnabled(flagName);
  }
  onFlagsLoad(callback) {
    var _a3;
    (_a3 = this.app) == null ? void 0 : _a3.featureFlags.onFlagsLoad(callback);
  }
  clearPersistFlags() {
    var _a3;
    (_a3 = this.app) == null ? void 0 : _a3.featureFlags.clearPersistFlags();
  }
  reloadFlags() {
    var _a3;
    return (_a3 = this.app) == null ? void 0 : _a3.featureFlags.reloadFlags();
  }
  getFeatureFlag(flagName) {
    var _a3;
    return (_a3 = this.app) == null ? void 0 : _a3.featureFlags.getFeatureFlag(flagName);
  }
  getAllFeatureFlags() {
    var _a3;
    return (_a3 = this.app) == null ? void 0 : _a3.featureFlags.flags;
  }
  use(fn) {
    return fn(this.app, this.options);
  }
  isActive() {
    if (this.app === null) {
      return false;
    }
    return this.app.active();
  }
  /**
   * Creates a named hook that expects event name, data string and msg direction (up/down),
   * it will skip any message bigger than 5 mb or event name bigger than 255 symbols
   * msg direction is "down" (incoming) by default
   *
   * @returns {(msgType: string, data: string, dir: 'up' | 'down') => void}
   * */
  trackWs(channelName) {
    if (this.app === null) {
      return;
    }
    return this.app.trackWs(channelName);
  }
  start(startOpts) {
    if (this.browserEnvCheck()) {
      if (this.app === null) {
        return Promise.reject("Browser doesn't support required api, or doNotTrack is active.");
      }
      return this.app.start(startOpts);
    } else {
      return Promise.reject("Trying to start not in browser.");
    }
  }
  browserEnvCheck() {
    if (!IN_BROWSER) {
      console.error(`OpenReplay: you are trying to start Tracker on a node.js environment. If you want to use OpenReplay with SSR, please, use componentDidMount or useEffect API for placing the \`tracker.start()\` line. Check documentation on ${DOCS_HOST}${DOCS_SETUP}`);
      return false;
    }
    return true;
  }
  /**
   * start buffering messages without starting the actual session, which gives user 30 seconds to "activate" and record
   * session by calling start() on conditional trigger and we will then send buffered batch, so it won't get lost
   * */
  coldStart(startOpts, conditional) {
    if (this.browserEnvCheck()) {
      if (this.app === null) {
        return Promise.reject("Tracker not initialized");
      }
      void this.app.coldStart(startOpts, conditional);
    } else {
      return Promise.reject("Trying to start not in browser.");
    }
  }
  /**
   * Starts offline session recording. Keep in mind that only user device time will be used for timestamps.
   * (no backend delay sync)
   *
   * @param {Object} startOpts - options for session start, same as .start()
   * @param {Function} onSessionSent - callback that will be called once session is fully sent
   * @returns methods to manipulate buffer:
   *
   * saveBuffer - to save it in localStorage
   *
   * getBuffer - returns current buffer
   *
   * setBuffer - replaces current buffer with given
   * */
  startOfflineRecording(startOpts, onSessionSent) {
    if (this.browserEnvCheck()) {
      if (this.app === null) {
        return Promise.reject("Tracker not initialized");
      }
      return this.app.offlineRecording(startOpts, onSessionSent);
    } else {
      return Promise.reject("Trying to start not in browser.");
    }
  }
  /**
   * Uploads the stored session buffer to backend
   * @returns promise that resolves once messages are loaded, it has to be awaited
   * so the session can be uploaded properly
   * @resolve - if messages were loaded into service worker successfully
   * @reject {string} - error message
   * */
  uploadOfflineRecording() {
    if (this.app === null) {
      return;
    }
    return this.app.uploadOfflineRecording();
  }
  stop() {
    if (this.app === null) {
      return;
    }
    this.app.stop();
    return this.app.session.getSessionHash();
  }
  forceFlushBatch() {
    if (this.app === null) {
      return;
    }
    this.app.forceFlushBatch();
  }
  getSessionToken() {
    if (this.app === null) {
      return null;
    }
    return this.app.getSessionToken();
  }
  getSessionInfo() {
    if (this.app === null) {
      return null;
    }
    return this.app.session.getInfo();
  }
  getSessionID() {
    if (this.app === null) {
      return null;
    }
    return this.app.getSessionID();
  }
  getTabId() {
    if (this.app === null) {
      return null;
    }
    return this.app.getTabId();
  }
  getUxId() {
    if (this.app === null) {
      return null;
    }
    return this.app.getUxtId();
  }
  sessionID() {
    deprecationWarn("'sessionID' method", "'getSessionID' method", "/");
    return this.getSessionID();
  }
  getSessionURL(options) {
    if (this.app === null) {
      return void 0;
    }
    return this.app.getSessionURL(options);
  }
  setUserID(id2) {
    if (typeof id2 === "string" && this.app !== null) {
      this.app.session.setUserID(id2);
    }
  }
  userID(id2) {
    deprecationWarn("'userID' method", "'setUserID' method", "/");
    this.setUserID(id2);
  }
  setUserAnonymousID(id2) {
    if (typeof id2 === "string" && this.app !== null) {
      this.app.send(UserAnonymousID(id2));
    }
  }
  userAnonymousID(id2) {
    deprecationWarn("'userAnonymousID' method", "'setUserAnonymousID' method", "/");
    this.setUserAnonymousID(id2);
  }
  setMetadata(key, value) {
    if (typeof key === "string" && typeof value === "string" && this.app !== null) {
      this.app.session.setMetadata(key, value);
    }
  }
  metadata(key, value) {
    deprecationWarn("'metadata' method", "'setMetadata' method", "/");
    this.setMetadata(key, value);
  }
  event(key, payload = null, issue = false) {
    if (typeof key === "string" && this.app !== null) {
      if (issue) {
        return this.issue(key, payload);
      } else {
        try {
          payload = JSON.stringify(payload);
        } catch (e) {
          return;
        }
        this.app.send(CustomEvent(key, payload));
      }
    }
  }
  issue(key, payload = null) {
    if (typeof key === "string" && this.app !== null) {
      try {
        payload = JSON.stringify(payload);
      } catch (e) {
        return;
      }
      this.app.send(CustomIssue(key, payload));
    }
  }
};
export {
  App,
  Messages,
  SanitizeLevel,
  API as default
};
//# sourceMappingURL=@openreplay_tracker.js.map
