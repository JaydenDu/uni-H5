import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/.pnpm/stackframe@1.3.4/node_modules/stackframe/stackframe.js
var require_stackframe = __commonJS({
  "node_modules/.pnpm/stackframe@1.3.4/node_modules/stackframe/stackframe.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define("stackframe", [], factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.StackFrame = factory();
      }
    })(exports, function() {
      "use strict";
      function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }
      function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
      }
      function _getter(p) {
        return function() {
          return this[p];
        };
      }
      var booleanProps = ["isConstructor", "isEval", "isNative", "isToplevel"];
      var numericProps = ["columnNumber", "lineNumber"];
      var stringProps = ["fileName", "functionName", "source"];
      var arrayProps = ["args"];
      var objectProps = ["evalOrigin"];
      var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);
      function StackFrame(obj) {
        if (!obj) return;
        for (var i2 = 0; i2 < props.length; i2++) {
          if (obj[props[i2]] !== void 0) {
            this["set" + _capitalize(props[i2])](obj[props[i2]]);
          }
        }
      }
      StackFrame.prototype = {
        getArgs: function() {
          return this.args;
        },
        setArgs: function(v) {
          if (Object.prototype.toString.call(v) !== "[object Array]") {
            throw new TypeError("Args must be an Array");
          }
          this.args = v;
        },
        getEvalOrigin: function() {
          return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
          if (v instanceof StackFrame) {
            this.evalOrigin = v;
          } else if (v instanceof Object) {
            this.evalOrigin = new StackFrame(v);
          } else {
            throw new TypeError("Eval Origin must be an Object or StackFrame");
          }
        },
        toString: function() {
          var fileName = this.getFileName() || "";
          var lineNumber = this.getLineNumber() || "";
          var columnNumber = this.getColumnNumber() || "";
          var functionName = this.getFunctionName() || "";
          if (this.getIsEval()) {
            if (fileName) {
              return "[eval] (" + fileName + ":" + lineNumber + ":" + columnNumber + ")";
            }
            return "[eval]:" + lineNumber + ":" + columnNumber;
          }
          if (functionName) {
            return functionName + " (" + fileName + ":" + lineNumber + ":" + columnNumber + ")";
          }
          return fileName + ":" + lineNumber + ":" + columnNumber;
        }
      };
      StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf("(");
        var argsEndIndex = str.lastIndexOf(")");
        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(",");
        var locationString = str.substring(argsEndIndex + 1);
        if (locationString.indexOf("@") === 0) {
          var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, "");
          var fileName = parts[1];
          var lineNumber = parts[2];
          var columnNumber = parts[3];
        }
        return new StackFrame({
          functionName,
          args: args || void 0,
          fileName,
          lineNumber: lineNumber || void 0,
          columnNumber: columnNumber || void 0
        });
      };
      for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype["get" + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype["set" + _capitalize(booleanProps[i])] = /* @__PURE__ */ function(p) {
          return function(v) {
            this[p] = Boolean(v);
          };
        }(booleanProps[i]);
      }
      for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype["get" + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype["set" + _capitalize(numericProps[j])] = /* @__PURE__ */ function(p) {
          return function(v) {
            if (!_isNumber(v)) {
              throw new TypeError(p + " must be a Number");
            }
            this[p] = Number(v);
          };
        }(numericProps[j]);
      }
      for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype["get" + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype["set" + _capitalize(stringProps[k])] = /* @__PURE__ */ function(p) {
          return function(v) {
            this[p] = String(v);
          };
        }(stringProps[k]);
      }
      return StackFrame;
    });
  }
});

// node_modules/.pnpm/error-stack-parser@2.1.4/node_modules/error-stack-parser/error-stack-parser.js
var require_error_stack_parser = __commonJS({
  "node_modules/.pnpm/error-stack-parser@2.1.4/node_modules/error-stack-parser/error-stack-parser.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define("error-stack-parser", ["stackframe"], factory);
      } else if (typeof exports === "object") {
        module.exports = factory(require_stackframe());
      } else {
        root.ErrorStackParser = factory(root.StackFrame);
      }
    })(exports, function ErrorStackParser2(StackFrame) {
      "use strict";
      var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
      var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
      var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
      return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
          if (typeof error.stacktrace !== "undefined" || typeof error["opera#sourceloc"] !== "undefined") {
            return this.parseOpera(error);
          } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
            return this.parseV8OrIE(error);
          } else if (error.stack) {
            return this.parseFFOrSafari(error);
          } else {
            throw new Error("Cannot parse given Error object");
          }
        },
        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
          if (urlLike.indexOf(":") === -1) {
            return [urlLike];
          }
          var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
          var parts = regExp.exec(urlLike.replace(/[()]/g, ""));
          return [parts[1], parts[2] || void 0, parts[3] || void 0];
        },
        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
          var filtered = error.stack.split("\n").filter(function(line) {
            return !!line.match(CHROME_IE_STACK_REGEXP);
          }, this);
          return filtered.map(function(line) {
            if (line.indexOf("(eval ") > -1) {
              line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
            }
            var sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
            var location2 = sanitizedLine.match(/ (\(.+\)$)/);
            sanitizedLine = location2 ? sanitizedLine.replace(location2[0], "") : sanitizedLine;
            var locationParts = this.extractLocation(location2 ? location2[1] : sanitizedLine);
            var functionName = location2 && sanitizedLine || void 0;
            var fileName = ["eval", "<anonymous>"].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0];
            return new StackFrame({
              functionName,
              fileName,
              lineNumber: locationParts[1],
              columnNumber: locationParts[2],
              source: line
            });
          }, this);
        },
        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
          var filtered = error.stack.split("\n").filter(function(line) {
            return !line.match(SAFARI_NATIVE_CODE_REGEXP);
          }, this);
          return filtered.map(function(line) {
            if (line.indexOf(" > eval") > -1) {
              line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
            }
            if (line.indexOf("@") === -1 && line.indexOf(":") === -1) {
              return new StackFrame({
                functionName: line
              });
            } else {
              var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
              var matches = line.match(functionNameRegex);
              var functionName = matches && matches[1] ? matches[1] : void 0;
              var locationParts = this.extractLocation(line.replace(functionNameRegex, ""));
              return new StackFrame({
                functionName,
                fileName: locationParts[0],
                lineNumber: locationParts[1],
                columnNumber: locationParts[2],
                source: line
              });
            }
          }, this);
        },
        parseOpera: function ErrorStackParser$$parseOpera(e) {
          if (!e.stacktrace || e.message.indexOf("\n") > -1 && e.message.split("\n").length > e.stacktrace.split("\n").length) {
            return this.parseOpera9(e);
          } else if (!e.stack) {
            return this.parseOpera10(e);
          } else {
            return this.parseOpera11(e);
          }
        },
        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
          var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
          var lines = e.message.split("\n");
          var result = [];
          for (var i = 2, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
              result.push(new StackFrame({
                fileName: match[2],
                lineNumber: match[1],
                source: lines[i]
              }));
            }
          }
          return result;
        },
        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
          var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
          var lines = e.stacktrace.split("\n");
          var result = [];
          for (var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
              result.push(
                new StackFrame({
                  functionName: match[3] || void 0,
                  fileName: match[2],
                  lineNumber: match[1],
                  source: lines[i]
                })
              );
            }
          }
          return result;
        },
        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
          var filtered = error.stack.split("\n").filter(function(line) {
            return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
          }, this);
          return filtered.map(function(line) {
            var tokens = line.split("@");
            var locationParts = this.extractLocation(tokens.pop());
            var functionCall = tokens.shift() || "";
            var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
            var argsRaw;
            if (functionCall.match(/\(([^)]*)\)/)) {
              argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
            }
            var args = argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(",");
            return new StackFrame({
              functionName,
              args,
              fileName: locationParts[0],
              lineNumber: locationParts[1],
              columnNumber: locationParts[2],
              source: line
            });
          }, this);
        }
      };
    });
  }
});

// node_modules/.pnpm/fflate@0.8.2/node_modules/fflate/esm/browser.js
var ch2 = {};
var wk = function(c, id2, msg, transfer, cb) {
  var w = new Worker(ch2[id2] || (ch2[id2] = URL.createObjectURL(new Blob([
    c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
  ], { type: "text/javascript" }))));
  w.onmessage = function(e) {
    var d = e.data, ed = d.$e$;
    if (ed) {
      var err2 = new Error(ed[0]);
      err2["code"] = ed[1];
      err2.stack = ed[2];
      cb(err2, null);
    } else
      cb(null, d);
  };
  w.postMessage(msg, transfer);
  return w;
};
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start2) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start2 += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max = function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var wbits = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
};
var wbits16 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
  d[o + 2] |= v >> 16;
};
var hTree = function(d, mb) {
  var t = [];
  for (var i = 0; i < d.length; ++i) {
    if (d[i])
      t.push({ s: i, f: d[i] });
  }
  var s = t.length;
  var t2 = t.slice();
  if (!s)
    return { t: et, l: 0 };
  if (s == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return { t: v, l: 1 };
  }
  t.sort(function(a, b) {
    return a.f - b.f;
  });
  t.push({ s: -1, f: 25001 });
  var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
  t[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t[t[i0].f < t[i2].f ? i0++ : i2++];
    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
    t[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t2[0].s;
  for (var i = 1; i < s; ++i) {
    if (t2[i].s > maxSym)
      maxSym = t2[i].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t2.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (; i < s; ++i) {
      var i2_1 = t2[i].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>= lft;
    while (dt > 0) {
      var i2_2 = t2[i].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i;
    }
    for (; i >= 0 && dt; --i) {
      var i2_3 = t2[i].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function(c) {
  var s = c.length;
  while (s && !c[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i = 1; i <= s; ++i) {
    if (c[i] == cln && i != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c[i];
    }
  }
  return { c: cl.subarray(0, cli), n: s };
};
var clen = function(cf, cl) {
  var l = 0;
  for (var i = 0; i < cl.length; ++i)
    l += cf[i] * cl[i];
  return l;
};
var wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i = 0; i < s; ++i)
    out[o + i + 4] = dat[i];
  return (o + 4 + s) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a3 = hTree(lf, 15), dlt = _a3.t, mlb = _a3.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i = 0; i < lclt.length; ++i)
    ++lcfreq[lclt[i] & 31];
  for (var i = 0; i < lcdt.length; ++i)
    ++lcfreq[lcdt[i] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i = 0; i < nlcc; ++i)
      wbits(out, p + 3 * i, lct[clim[i]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i = 0; i < li; ++i) {
    var sym = syms[i];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, sym >> 23 & 31), p += fleb[len];
      var dst = sym & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[sym]), p += ll[sym];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st) {
  var s = st.z || dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
  var w = o.subarray(pre, o.length - post);
  var lst = st.l;
  var pos = (st.r || 0) & 7;
  if (lvl) {
    if (pos)
      w[0] = st.r >> 3;
    var opt = deo[lvl - 1];
    var n = opt >> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i2) {
      return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
    for (; i + 2 < s; ++i) {
      var hv = hsh(i);
      var imod = i & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i) {
        var rem = s - i;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;
          for (var j = 0; j < 286; ++j)
            lf[j] = 0;
          for (var j = 0; j < 30; ++j)
            df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l] == dat[i + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i - dif + j & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }
    for (i = Math.max(i, wi); i < s; ++i) {
      syms[li++] = dat[i];
      ++lf[dat[i]];
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
    if (!lst) {
      st.r = pos & 7 | w[pos / 8 | 0] << 3;
      pos -= 7;
      st.h = head, st.p = prev, st.i = i, st.w = wi;
    }
  } else {
    for (var i = st.w || 0; i < s + lst; i += 65535) {
      var e = i + 65535;
      if (e >= s) {
        w[pos / 8 | 0] = lst;
        e = s;
      }
      pos = wfblk(w, pos + 1, dat.subarray(i, e));
    }
    st.i = s;
  }
  return slc(o, 0, pre + shft(pos) + post);
};
var crct = function() {
  var t = new Int32Array(256);
  for (var i = 0; i < 256; ++i) {
    var c = i, k = 9;
    while (--k)
      c = (c & 1 && -306674912) ^ c >>> 1;
    t[i] = c;
  }
  return t;
}();
var crc = function() {
  var c = -1;
  return {
    p: function(d) {
      var cr = c;
      for (var i = 0; i < d.length; ++i)
        cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
      c = cr;
    },
    d: function() {
      return ~c;
    }
  };
};
var adler = function() {
  var a = 1, b = 0;
  return {
    p: function(d) {
      var n = a, m = b;
      var l = d.length | 0;
      for (var i = 0; i != l; ) {
        var e = Math.min(i + 2655, l);
        for (; i < e; ++i)
          m += n += d[i];
        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }
      a = n, b = m;
    },
    d: function() {
      a %= 65521, b %= 65521;
      return (a & 255) << 24 | (a & 65280) << 8 | (b & 255) << 8 | b >> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post, st) {
  if (!st) {
    st = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
};
var mrg = function(a, b) {
  var o = {};
  for (var k in a)
    o[k] = a[k];
  for (var k in b)
    o[k] = b[k];
  return o;
};
var wcln = function(fn, fnStr, td2) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
  for (var i = 0; i < dt.length; ++i) {
    var v = dt[i], k = ks[i];
    if (typeof v == "function") {
      fnStr += ";" + k + "=";
      var st_1 = v.toString();
      if (v.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t in v.prototype)
            fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k] = v;
  }
  return fnStr;
};
var ch = [];
var cbfs = function(v) {
  var tl = [];
  for (var k in v) {
    if (v[k].buffer) {
      tl.push((v[k] = new v[k].constructor(v[k])).buffer);
    }
  }
  return tl;
};
var wrkr = function(fns, init, id2, cb) {
  if (!ch[id2]) {
    var fnStr = "", td_1 = {}, m = fns.length - 1;
    for (var i = 0; i < m; ++i)
      fnStr = wcln(fns[i], fnStr, td_1);
    ch[id2] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
  }
  var td2 = mrg({}, ch[id2].e);
  return wk(ch[id2].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id2, td2, cbfs(td2), cb);
};
var bInflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
};
var bDflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
};
var gze = function() {
  return [gzh, gzhl, wbytes, crc, crct];
};
var guze = function() {
  return [gzs, gzl];
};
var zule = function() {
  return [zls];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gopt = function(o) {
  return o && {
    out: o.size && new u8(o.size),
    dictionary: o.dictionary
  };
};
var cbify = function(dat, opts, fns, init, id2, cb) {
  var w = wrkr(fns, init, id2, function(err2, dat2) {
    w.terminate();
    cb(err2, dat2);
  });
  w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
  return function() {
    w.terminate();
  };
};
var astrm = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    if (ev.data.length) {
      strm.push(ev.data[0], ev.data[1]);
      postMessage([ev.data[0].length]);
    } else
      strm.flush();
  };
};
var astrmify = function(fns, strm, opts, init, id2, flush, ext) {
  var t;
  var w = wrkr(fns, init, id2, function(err2, dat) {
    if (err2)
      w.terminate(), strm.ondata.call(strm, err2);
    else if (!Array.isArray(dat))
      ext(dat);
    else if (dat.length == 1) {
      strm.queuedSize -= dat[0];
      if (strm.ondrain)
        strm.ondrain(dat[0]);
    } else {
      if (dat[1])
        w.terminate();
      strm.ondata.call(strm, err2, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);
  strm.queuedSize = 0;
  strm.push = function(d, f) {
    if (!strm.ondata)
      err(5);
    if (t)
      strm.ondata(err(4, 0, 1), null, !!f);
    strm.queuedSize += d.length;
    w.postMessage([d, t = f], [d.buffer]);
  };
  strm.terminate = function() {
    w.terminate();
  };
  if (flush) {
    strm.flush = function() {
      w.postMessage([]);
    };
  }
};
var b2 = function(d, b) {
  return d[b] | d[b + 1] << 8;
};
var b4 = function(d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
};
var wbytes = function(d, b, v) {
  for (; v; ++b)
    d[b] = v, v >>>= 8;
};
var gzh = function(c, o) {
  var fn = o.filename;
  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
  if (o.mtime != 0)
    wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
  if (fn) {
    c[3] = 8;
    for (var i = 0; i <= fn.length; ++i)
      c[i + 10] = fn.charCodeAt(i);
  }
};
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var gzhl = function(o) {
  return 10 + (o.filename ? o.filename.length + 1 : 0);
};
var zlh = function(c, o) {
  var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c[0] = 120, c[1] = fl2 << 6 | (o.dictionary && 32);
  c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
  if (o.dictionary) {
    var h = adler();
    h.p(o.dictionary);
    wbytes(c, 2, h.d());
  }
};
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
function StrmOpt(opts, cb) {
  if (typeof opts == "function")
    cb = opts, opts = {};
  this.ondata = cb;
  return opts;
}
var Deflate = function() {
  function Deflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    this.o = opts || {};
    this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
    this.b = new u8(98304);
    if (this.o.dictionary) {
      var dict = this.o.dictionary.subarray(-32768);
      this.b.set(dict, 32768 - dict.length);
      this.s.i = 32768 - dict.length;
    }
  }
  Deflate2.prototype.p = function(c, f) {
    this.ondata(dopt(c, this.o, 0, 0, this.s), f);
  };
  Deflate2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    var endLen = chunk.length + this.s.z;
    if (endLen > this.b.length) {
      if (endLen > 2 * this.b.length - 32768) {
        var newBuf = new u8(endLen & -32768);
        newBuf.set(this.b.subarray(0, this.s.z));
        this.b = newBuf;
      }
      var split = this.b.length - this.s.z;
      this.b.set(chunk.subarray(0, split), this.s.z);
      this.s.z = this.b.length;
      this.p(this.b, false);
      this.b.set(this.b.subarray(-32768));
      this.b.set(chunk.subarray(split), 32768);
      this.s.z = chunk.length - split + 32768;
      this.s.i = 32766, this.s.w = 32768;
    } else {
      this.b.set(chunk, this.s.z);
      this.s.z += chunk.length;
    }
    this.s.l = final & 1;
    if (this.s.z > this.s.w + 8191 || final) {
      this.p(this.b, final || false);
      this.s.w = this.s.i, this.s.i -= 2;
    }
  };
  Deflate2.prototype.flush = function() {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    this.p(this.b, false);
    this.s.w = this.s.i, this.s.i -= 2;
  };
  return Deflate2;
}();
var AsyncDeflate = /* @__PURE__ */ function() {
  function AsyncDeflate2(opts, cb) {
    astrmify([
      bDflt,
      function() {
        return [astrm, Deflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6, 1);
  }
  return AsyncDeflate2;
}();
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var Inflate = function() {
  function Inflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
    this.s = { i: 0, b: dict ? dict.length : 0 };
    this.o = new u8(32768);
    this.p = new u8(0);
    if (dict)
      this.o.set(dict);
  }
  Inflate2.prototype.e = function(c) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    if (!this.p.length)
      this.p = c;
    else if (c.length) {
      var n = new u8(this.p.length + c.length);
      n.set(this.p), n.set(c, this.p.length), this.p = n;
    }
  };
  Inflate2.prototype.c = function(final) {
    this.s.i = +(this.d = final || false);
    var bts = this.s.b;
    var dt = inflt(this.p, this.s, this.o);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate2;
}();
var AsyncInflate = /* @__PURE__ */ function() {
  function AsyncInflate2(opts, cb) {
    astrmify([
      bInflt,
      function() {
        return [astrm, Inflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Inflate(ev.data);
      onmessage = astrm(strm);
    }, 7, 0);
  }
  return AsyncInflate2;
}();
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Gzip = function() {
  function Gzip2(opts, cb) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Gzip2.prototype.push = function(chunk, final) {
    this.c.p(chunk);
    this.l += chunk.length;
    Deflate.prototype.push.call(this, chunk, final);
  };
  Gzip2.prototype.p = function(c, f) {
    var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);
    if (this.v)
      gzh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f);
  };
  Gzip2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Gzip2;
}();
function gzip(data, opts, cb) {
  if (!cb)
    cb = opts, opts = {};
  if (typeof cb != "function")
    err(7);
  return cbify(data, opts, [
    bDflt,
    gze,
    function() {
      return [gzipSync];
    }
  ], function(ev) {
    return pbf(gzipSync(ev.data[0], ev.data[1]));
  }, 2, cb);
}
function gzipSync(data, opts) {
  if (!opts)
    opts = {};
  var c = crc(), l = data.length;
  c.p(data);
  var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
  return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
var Gunzip = function() {
  function Gunzip2(opts, cb) {
    this.v = 1;
    this.r = 0;
    Inflate.call(this, opts, cb);
  }
  Gunzip2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    this.r += chunk.length;
    if (this.v) {
      var p = this.p.subarray(this.v - 1);
      var s = p.length > 3 ? gzs(p) : 4;
      if (s > p.length) {
        if (!final)
          return;
      } else if (this.v > 1 && this.onmember) {
        this.onmember(this.r - p.length);
      }
      this.p = p.subarray(s), this.v = 0;
    }
    Inflate.prototype.c.call(this, final);
    if (this.s.f && !this.s.l && !final) {
      this.v = shft(this.s.p) + 9;
      this.s = { i: 0 };
      this.o = new u8(0);
      this.push(new u8(0), final);
    }
  };
  return Gunzip2;
}();
var AsyncGunzip = /* @__PURE__ */ function() {
  function AsyncGunzip2(opts, cb) {
    var _this = this;
    astrmify([
      bInflt,
      guze,
      function() {
        return [astrm, Inflate, Gunzip];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Gunzip(ev.data);
      strm.onmember = function(offset) {
        return postMessage(offset);
      };
      onmessage = astrm(strm);
    }, 9, 0, function(offset) {
      return _this.onmember && _this.onmember(offset);
    });
  }
  return AsyncGunzip2;
}();
var Zlib = function() {
  function Zlib2(opts, cb) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Zlib2.prototype.push = function(chunk, final) {
    this.c.p(chunk);
    Deflate.prototype.push.call(this, chunk, final);
  };
  Zlib2.prototype.p = function(c, f) {
    var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);
    if (this.v)
      zlh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f);
  };
  Zlib2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Zlib2;
}();
var Unzlib = function() {
  function Unzlib2(opts, cb) {
    Inflate.call(this, opts, cb);
    this.v = opts && opts.dictionary ? 2 : 1;
  }
  Unzlib2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      if (this.p.length < 6 && !final)
        return;
      this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        err(6, "invalid zlib data");
      this.p = this.p.subarray(0, -4);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Unzlib2;
}();
var AsyncUnzlib = /* @__PURE__ */ function() {
  function AsyncUnzlib2(opts, cb) {
    astrmify([
      bInflt,
      zule,
      function() {
        return [astrm, Inflate, Unzlib];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Unzlib(ev.data);
      onmessage = astrm(strm);
    }, 11, 0);
  }
  return AsyncUnzlib2;
}();
var Decompress = function() {
  function Decompress2(opts, cb) {
    this.o = StrmOpt.call(this, opts, cb) || {};
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
  }
  Decompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(dat, final) {
      _this.ondata(dat, final);
    };
  };
  Decompress2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (!this.s) {
      if (this.p && this.p.length) {
        var n = new u8(this.p.length + chunk.length);
        n.set(this.p), n.set(chunk, this.p.length);
      } else
        this.p = chunk;
      if (this.p.length > 2) {
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
        this.i();
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk, final);
  };
  return Decompress2;
}();
var AsyncDecompress = function() {
  function AsyncDecompress2(opts, cb) {
    Decompress.call(this, opts, cb);
    this.queuedSize = 0;
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
  }
  AsyncDecompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    };
    this.s.ondrain = function(size) {
      _this.queuedSize -= size;
      if (_this.ondrain)
        _this.ondrain(size);
    };
  };
  AsyncDecompress2.prototype.push = function(chunk, final) {
    this.queuedSize += chunk.length;
    Decompress.prototype.push.call(this, chunk, final);
  };
  return AsyncDecompress2;
}();
var te = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var dutf8 = function(d) {
  for (var r = "", i = 0; ; ) {
    var c = d[i++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i + eb > d.length)
      return { s: r, r: slc(d, i - 1) };
    if (!eb)
      r += String.fromCharCode(c);
    else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
    else
      r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
  }
};
var DecodeUTF8 = function() {
  function DecodeUTF82(cb) {
    this.ondata = cb;
    if (tds)
      this.t = new TextDecoder();
    else
      this.p = et;
  }
  DecodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          err(8);
        this.t = null;
      }
      return;
    }
    if (!this.p)
      err(4);
    var dat = new u8(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);
    var _a3 = dutf8(dat), s = _a3.s, r = _a3.r;
    if (final) {
      if (r.length)
        err(8);
      this.p = null;
    } else
      this.p = r;
    this.ondata(s, final);
  };
  return DecodeUTF82;
}();
var EncodeUTF8 = function() {
  function EncodeUTF82(cb) {
    this.ondata = cb;
  }
  EncodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    this.ondata(strToU8(chunk), this.d = final || false);
  };
  return EncodeUTF82;
}();
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i = 0; i < str.length; ++i)
      ar_1[i] = str.charCodeAt(i);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }
    var c = str.charCodeAt(i);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i = 0; i < dat.length; i += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    return r;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a3 = dutf8(dat), s = _a3.s, r = _a3.r;
    if (r.length)
      err(8);
    return s;
  }
}
var dbf = function(l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
var z64e = function(d, b) {
  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
    ;
  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        err(9);
      le += l + 4;
    }
  }
  return le;
};
var wzh = function(d, b, f, fn, u, c, ce, co) {
  var fl2 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
  if (ce != null)
    d[b++] = 20, d[b++] = f.os;
  d[b] = 20, b += 2;
  d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    err(10);
  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
  if (c != -1) {
    wbytes(d, b, f.crc);
    wbytes(d, b + 4, c < 0 ? -c - 2 : c);
    wbytes(d, b + 8, f.size);
  }
  wbytes(d, b + 12, fl2);
  wbytes(d, b + 14, exl), b += 16;
  if (ce != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f.attrs);
    wbytes(d, b + 10, ce), b += 14;
  }
  d.set(fn, b);
  b += fl2;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }
  if (col)
    d.set(co, b), b += col;
  return b;
};
var wzf = function(o, b, c, d, e) {
  wbytes(o, b, 101010256);
  wbytes(o, b + 8, c);
  wbytes(o, b + 10, c);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
var ZipPassThrough = function() {
  function ZipPassThrough2(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough2.prototype.process = function(chunk, final) {
    this.ondata(null, chunk, final);
  };
  ZipPassThrough2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    this.c.p(chunk);
    this.size += chunk.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk, final || false);
  };
  return ZipPassThrough2;
}();
var ZipDeflate = function() {
  function ZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function(dat, final) {
      _this.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }
  ZipDeflate2.prototype.process = function(chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  ZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return ZipDeflate2;
}();
var AsyncZipDeflate = function() {
  function AsyncZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate2.prototype.process = function(chunk, final) {
    this.d.push(chunk, final);
  };
  AsyncZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return AsyncZipDeflate2;
}();
var Zip = function() {
  function Zip2(cb) {
    this.ondata = cb;
    this.u = [];
    this.d = 1;
  }
  Zip2.prototype.add = function(file) {
    var _this = this;
    if (!this.ondata)
      err(5);
    if (this.d & 2)
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
    else {
      var f = strToU8(file.filename), fl_1 = f.length;
      var com = file.comment, o = com && strToU8(com);
      var u = fl_1 != file.filename.length || o && com.length != o.length;
      var hl_1 = fl_1 + exfl(file.extra) + 30;
      if (fl_1 > 65535)
        this.ondata(err(11, 0, 1), null, false);
      var header = new u8(hl_1);
      wzh(header, 0, file, f, u, -1);
      var chks_1 = [header];
      var pAll_1 = function() {
        for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
          var chk = chks_2[_i];
          _this.ondata(null, chk, false);
        }
        chks_1 = [];
      };
      var tr_1 = this.d;
      this.d = 0;
      var ind_1 = this.u.length;
      var uf_1 = mrg(file, {
        f,
        u,
        o,
        t: function() {
          if (file.terminate)
            file.terminate();
        },
        r: function() {
          pAll_1();
          if (tr_1) {
            var nxt = _this.u[ind_1 + 1];
            if (nxt)
              nxt.r();
            else
              _this.d = 1;
          }
          tr_1 = 1;
        }
      });
      var cl_1 = 0;
      file.ondata = function(err2, dat, final) {
        if (err2) {
          _this.ondata(err2, dat, final);
          _this.terminate();
        } else {
          cl_1 += dat.length;
          chks_1.push(dat);
          if (final) {
            var dd = new u8(16);
            wbytes(dd, 0, 134695760);
            wbytes(dd, 4, file.crc);
            wbytes(dd, 8, cl_1);
            wbytes(dd, 12, file.size);
            chks_1.push(dd);
            uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
            if (tr_1)
              uf_1.r();
            tr_1 = 1;
          } else if (tr_1)
            pAll_1();
        }
      };
      this.u.push(uf_1);
    }
  };
  Zip2.prototype.end = function() {
    var _this = this;
    if (this.d & 2) {
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
      return;
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this.d & 1))
            return;
          _this.u.splice(-1, 1);
          _this.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip2.prototype.e = function() {
    var bt = 0, l = 0, tl = 0;
    for (var _i = 0, _a3 = this.u; _i < _a3.length; _i++) {
      var f = _a3[_i];
      tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
    }
    var out = new u8(tl + 22);
    for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
      var f = _c[_b2];
      wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);
      bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
    }
    wzf(out, bt, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip2.prototype.terminate = function() {
    for (var _i = 0, _a3 = this.u; _i < _a3.length; _i++) {
      var f = _a3[_i];
      f.t();
    }
    this.d = 2;
  };
  return Zip2;
}();
var UnzipPassThrough = function() {
  function UnzipPassThrough2() {
  }
  UnzipPassThrough2.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough2.compression = 0;
  return UnzipPassThrough2;
}();
var UnzipInflate = function() {
  function UnzipInflate2() {
    var _this = this;
    this.i = new Inflate(function(dat, final) {
      _this.ondata(null, dat, final);
    });
  }
  UnzipInflate2.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  UnzipInflate2.compression = 8;
  return UnzipInflate2;
}();
var AsyncUnzipInflate = function() {
  function AsyncUnzipInflate2(_, sz) {
    var _this = this;
    if (sz < 32e4) {
      this.i = new Inflate(function(dat, final) {
        _this.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function(err2, dat, final) {
        _this.ondata(err2, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate2.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate2.compression = 8;
  return AsyncUnzipInflate2;
}();
var Unzip = function() {
  function Unzip2(cb) {
    this.onfile = cb;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  Unzip2.prototype.push = function(chunk, final) {
    var _this = this;
    if (!this.onfile)
      err(5);
    if (!this.p)
      err(4);
    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length)
        return this.push(chunk, final);
    } else {
      var f = 0, i = 0, is = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk;
      else if (!chunk.length)
        buf = this.p;
      else {
        buf = new u8(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l = buf.length, oc = this.c, add = oc && this.d;
      var _loop_2 = function() {
        var _a3;
        var sig = b4(buf, i);
        if (sig == 67324752) {
          f = 1, is = i;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
          if (l > i + 30 + fnl + es) {
            var chks_3 = [];
            this_1.k.unshift(chks_3);
            f = 2;
            var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
            var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
            if (sc_1 == 4294967295) {
              _a3 = dd ? [-2] : z64e(buf, i), sc_1 = _a3[0], su_1 = _a3[1];
            } else if (dd)
              sc_1 = -1;
            i += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  err(5);
                if (!sc_1)
                  file_1.ondata(null, et, true);
                else {
                  var ctr = _this.o[cmp_1];
                  if (!ctr)
                    file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                  d_1.ondata = function(err2, dat3, final2) {
                    file_1.ondata(err2, dat3, final2);
                  };
                  for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                    var dat2 = chks_4[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this.k[0] == chks_3 && _this.c)
                    _this.d = d_1;
                  else
                    d_1.push(et, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is = i -= 4, f = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i < l - 4; ++i) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et;
      if (oc < 0) {
        var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i);
        if (add)
          add.push(dat, !!f);
        else
          this.k[+(f == 2)].push(dat);
      }
      if (f & 2)
        return this.push(buf.subarray(i), final);
      this.p = buf.subarray(i);
    }
    if (final) {
      if (this.c)
        err(13);
      this.p = null;
    }
  };
  Unzip2.prototype.register = function(decoder) {
    this.o[decoder.compression] = decoder;
  };
  return Unzip2;
}();

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/attributeSender.js
var StringDictionary = class {
  constructor() {
    this.idx = 1;
    this.backDict = {};
  }
  getKey(str) {
    let isNew = false;
    if (!this.backDict[str]) {
      isNew = true;
      this.backDict[str] = this.idx++;
    }
    return [this.backDict[str], isNew];
  }
};
var AttributeSender = class {
  constructor(app, isDictDisabled) {
    this.app = app;
    this.isDictDisabled = isDictDisabled;
    this.dict = new StringDictionary();
  }
  sendSetAttribute(id2, name, value) {
    if (this.isDictDisabled) {
      const msg = [12, id2, name, value];
      return this.app.send(msg);
    } else {
      const message = [
        51,
        id2,
        this.applyDict(name),
        this.applyDict(value)
      ];
      return this.app.send(message);
    }
  }
  applyDict(str) {
    const [key, isNew] = this.dict.getKey(str);
    if (isNew) {
      this.app.send([50, key, str]);
    }
    return key;
  }
  clear() {
    this.dict = new StringDictionary();
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/conditionsManager.js
var ConditionsManager = class {
  constructor(app, startParams) {
    this.app = app;
    this.startParams = startParams;
    this.conditions = [];
    this.hasStarted = false;
    this.createConditionFromFilter = (filter) => {
      if (filter.value.length) {
        const resultCondition = mapCondition(filter);
        if (resultCondition.type) {
          return resultCondition;
        }
      }
      return void 0;
    };
    this.durationInt = null;
  }
  setConditions(conditions) {
    this.conditions = conditions;
  }
  async fetchConditions(projectId, token) {
    try {
      const r = await fetch(`${this.app.options.ingestPoint}/v1/web/conditions/${projectId}`, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token}`
        }
      });
      const { conditions } = await r.json();
      const mappedConditions = [];
      conditions.forEach((c) => {
        const filters = c.filters;
        filters.forEach((filter) => {
          let cond;
          if (filter.type === "fetch") {
            cond = {
              type: "network_request",
              subConditions: [],
              name: c.name
            };
            filter.filters.forEach((f) => {
              const subCond = this.createConditionFromFilter(f);
              if (subCond) {
                ;
                cond.subConditions.push(subCond);
              }
            });
          } else {
            cond = this.createConditionFromFilter(filter);
          }
          if (cond) {
            if (cond.type === "session_duration") {
              this.processDuration(cond.value[0], c.name);
            }
            mappedConditions.push({ ...cond, name: c.name });
          }
        });
      });
      this.conditions = mappedConditions;
    } catch (e) {
      this.app.debug.error("Critical: cannot fetch start conditions");
    }
  }
  trigger(conditionName) {
    if (this.hasStarted)
      return;
    try {
      this.hasStarted = true;
      void this.app.start(this.startParams, void 0, conditionName);
    } catch (e) {
      this.app.debug.error(e);
    }
  }
  processMessage(message) {
    if (this.hasStarted)
      return;
    switch (message[0]) {
      case 78:
        this.jsExceptionEvent(message);
        break;
      case 27:
        this.customEvent(message);
        break;
      case 68:
        this.clickEvent(message);
        break;
      case 122:
        this.pageLocationEvent(message);
        break;
      case 83:
        this.networkRequest(message);
        break;
      default:
        break;
    }
  }
  processFlags(flag) {
    const flagConds = this.conditions.filter((c) => c.type === "feature_flag");
    if (flagConds.length) {
      flagConds.forEach((flagCond) => {
        const operator = operators[flagCond.operator];
        if (operator && flag.find((f) => operator(f.key, flagCond.value))) {
          this.trigger(flagCond.name);
        }
      });
    }
  }
  processDuration(durationMs, condName) {
    this.durationInt = setInterval(() => {
      const sessionLength = performance.now();
      if (sessionLength > durationMs) {
        this.trigger(condName);
      }
    }, 1e3);
    this.app.attachStopCallback(() => {
      if (this.durationInt) {
        clearInterval(this.durationInt);
      }
    });
  }
  networkRequest(message) {
    const reqConds = this.conditions.filter((c) => c.type === "network_request");
    if (!reqConds.length)
      return;
    reqConds.forEach((reqCond) => {
      const validSubConditions = reqCond.subConditions.filter((c) => c.operator !== "isAny");
      if (validSubConditions.length) {
        const allPass = validSubConditions.every((subCond) => {
          let value;
          switch (subCond.key) {
            case "url":
              value = message[3];
              break;
            case "status":
              value = message[6];
              break;
            case "method":
              value = message[2];
              break;
            case "duration":
              value = message[8];
              break;
            default:
              break;
          }
          const operator = operators[subCond.operator];
          if (operator && operator(value, subCond.value)) {
            return true;
          }
        });
        if (allPass) {
          this.trigger(reqCond.name);
        }
      } else if (validSubConditions.length === 0 && reqCond.subConditions.length) {
        this.trigger(reqCond.name);
      }
    });
  }
  customEvent(message) {
    const evConds = this.conditions.filter((c) => c.type === "custom_event");
    if (evConds.length) {
      evConds.forEach((evCond) => {
        const operator = operators[evCond.operator];
        if (operator && (operator(message[1], evCond.value) || operator(message[2], evCond.value))) {
          this.trigger(evCond.name);
        }
      });
    }
  }
  clickEvent(message) {
    const clickCond = this.conditions.filter((c) => c.type === "click");
    if (clickCond.length) {
      clickCond.forEach((click) => {
        const operator = operators[click.operator];
        if (operator && (operator(message[3], click.value) || operator(message[4], click.value))) {
          this.trigger(click.name);
        }
      });
    }
  }
  pageLocationEvent(message) {
    const urlConds = this.conditions.filter((c) => c.type === "visited_url");
    if (urlConds) {
      urlConds.forEach((urlCond) => {
        const operator = operators[urlCond.operator];
        if (operator && operator(message[1], urlCond.value)) {
          this.trigger(urlCond.name);
        }
      });
    }
  }
  jsExceptionEvent(message) {
    const testedValues = [message[1], message[2], message[3]];
    const exceptionConds = this.conditions.filter((c) => c.type === "exception");
    if (exceptionConds) {
      exceptionConds.forEach((exceptionCond) => {
        const operator = operators[exceptionCond.operator];
        if (operator && testedValues.some((val) => operator(val, exceptionCond.value))) {
          this.trigger(exceptionCond.name);
        }
      });
    }
  }
};
var operators = {
  is: (val, target) => target.some((t) => val.includes(t)),
  isAny: () => true,
  isNot: (val, target) => !target.some((t) => val.includes(t)),
  contains: (val, target) => target.some((t) => val.includes(t)),
  notContains: (val, target) => !target.some((t) => val.includes(t)),
  startsWith: (val, target) => target.some((t) => val.startsWith(t)),
  endsWith: (val, target) => target.some((t) => val.endsWith(t)),
  greaterThan: (val, target) => val > target,
  greaterOrEqual: (val, target) => val >= target,
  lessOrEqual: (val, target) => val <= target,
  lessThan: (val, target) => val < target
};
var mapCondition = (condition) => {
  const opMap = {
    on: "is",
    notOn: "isNot",
    ">": "greaterThan",
    "<": "lessThan",
    "=": "is",
    "<=": "lessOrEqual",
    ">=": "greaterOrEqual"
  };
  const mapOperator = (operator) => {
    const keys = Object.keys(opMap);
    if (keys.includes(operator))
      return opMap[operator];
  };
  let con = {
    type: "",
    operator: "",
    value: condition.value,
    key: ""
  };
  switch (condition.type) {
    case "click":
      con = {
        type: "click",
        operator: mapOperator(condition.operator),
        value: condition.value,
        key: ""
      };
      break;
    case "location":
      con = {
        type: "visited_url",
        // @ts-ignore
        operator: condition.operator,
        value: condition.value,
        key: ""
      };
      break;
    case "custom":
      con = {
        type: "custom_event",
        // @ts-ignore
        operator: condition.operator,
        value: condition.value,
        key: ""
      };
      break;
    case "metadata":
      con = {
        // @ts-ignore
        type: condition.source === "featureFlag" ? "feature_flag" : condition.type,
        // @ts-ignore
        operator: condition.operator,
        value: condition.value,
        key: ""
      };
      break;
    case "error":
      con = {
        type: "exception",
        // @ts-ignore
        operator: condition.operator,
        value: condition.value,
        key: ""
      };
      break;
    case "duration":
      con = {
        type: "session_duration",
        // @ts-ignore
        value: condition.value[0],
        key: ""
      };
      break;
    case "fetchUrl":
      con = {
        type: "network_request",
        key: "url",
        operator: condition.operator,
        value: condition.value
      };
      break;
    case "fetchStatusCode":
      con = {
        type: "network_request",
        key: "status",
        operator: mapOperator(condition.operator),
        value: condition.value
      };
      break;
    case "fetchMethod":
      con = {
        type: "network_request",
        key: "method",
        operator: mapOperator(condition.operator),
        value: condition.value
      };
      break;
    case "fetchDuration":
      con = {
        type: "network_request",
        key: "duration",
        operator: mapOperator(condition.operator),
        value: condition.value
      };
      break;
  }
  return con;
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/featureFlags.js
var FeatureFlags = class {
  constructor(app) {
    this.app = app;
    this.flags = [];
    this.storageKey = "__openreplay_flags";
    const persistFlags = this.app.sessionStorage.getItem(this.storageKey);
    if (persistFlags) {
      const persistFlagsStrArr = persistFlags.split(";").filter(Boolean);
      this.flags = persistFlagsStrArr.map((flag) => JSON.parse(flag));
    }
  }
  getFeatureFlag(flagName) {
    return this.flags.find((flag) => flag.key === flagName);
  }
  isFlagEnabled(flagName) {
    return this.flags.findIndex((flag) => flag.key === flagName) !== -1;
  }
  onFlagsLoad(cb) {
    this.onFlagsCb = cb;
  }
  async reloadFlags(token) {
    const persistFlagsStr = this.app.sessionStorage.getItem(this.storageKey);
    const persistFlags = {};
    if (persistFlagsStr) {
      const persistArray = persistFlagsStr.split(";").filter(Boolean);
      persistArray.forEach((flag) => {
        const flagObj = JSON.parse(flag);
        persistFlags[flagObj.key] = { key: flagObj.key, value: flagObj.value };
      });
    }
    const sessionInfo = this.app.session.getInfo();
    const userInfo = this.app.session.userInfo;
    const requestObject = {
      projectID: sessionInfo.projectID,
      userID: sessionInfo.userID,
      metadata: sessionInfo.metadata,
      referrer: document.referrer,
      os: userInfo.userOS,
      device: userInfo.userDevice,
      country: userInfo.userCountry,
      state: userInfo.userState,
      city: userInfo.userCity,
      browser: userInfo.userBrowser,
      persistFlags
    };
    const authToken = token ?? this.app.session.getSessionToken();
    const resp = await fetch(this.app.options.ingestPoint + "/v1/web/feature-flags", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${authToken}`
      },
      body: JSON.stringify(requestObject)
    });
    if (resp.status === 200) {
      const data = await resp.json();
      return this.handleFlags(data.flags);
    }
  }
  handleFlags(flags) {
    var _a3;
    const persistFlags = [];
    flags.forEach((flag) => {
      if (flag.is_persist)
        persistFlags.push(flag);
    });
    let str = "";
    const uniquePersistFlags = this.diffPersist(persistFlags);
    uniquePersistFlags.forEach((flag) => {
      str += `${JSON.stringify(flag)};`;
    });
    this.app.sessionStorage.setItem(this.storageKey, str);
    this.flags = flags;
    return (_a3 = this.onFlagsCb) == null ? void 0 : _a3.call(this, flags);
  }
  clearPersistFlags() {
    this.app.sessionStorage.removeItem(this.storageKey);
  }
  diffPersist(flags) {
    const persistFlags = this.app.sessionStorage.getItem(this.storageKey);
    if (!persistFlags)
      return flags;
    const persistFlagsStrArr = persistFlags.split(";").filter(Boolean);
    const persistFlagsArr = persistFlagsStrArr.map((flag) => JSON.parse(flag));
    return flags.filter((flag) => persistFlagsArr.findIndex((pf) => pf.key === flag.key) === -1);
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/utils.js
var DEPRECATED_ATTRS = { htmlmasked: "hidden", masked: "obscured" };
var IN_BROWSER = !(typeof window === "undefined");
var IS_FIREFOX = IN_BROWSER && navigator.userAgent.match(/firefox|fxios/i);
var MAX_STR_LEN = 1e5;
var timeOrigin = IN_BROWSER ? Date.now() - performance.now() : 0;
function adjustTimeOrigin() {
  timeOrigin = Date.now() - performance.now();
}
function getTimeOrigin() {
  return timeOrigin;
}
var now = IN_BROWSER && !!performance.now ? () => Math.round(performance.now() + timeOrigin) : () => Date.now();
var stars = "repeat" in String.prototype ? (str) => "*".repeat(str.length) : (str) => str.replace(/./g, "*");
function normSpaces(str) {
  return str.trim().replace(/\s+/g, " ");
}
function isURL(s) {
  return s.startsWith("https://") || s.startsWith("http://");
}
var DOCS_HOST = "https://docs.openreplay.com";
var warnedFeatures = {};
function deprecationWarn(nameOfFeature, useInstead, docsPath = "/") {
  if (warnedFeatures[nameOfFeature]) {
    return;
  }
  console.warn(`OpenReplay: ${nameOfFeature} is deprecated. ${useInstead ? `Please, use ${useInstead} instead.` : ""} Visit ${DOCS_HOST}${docsPath} for more information.`);
  warnedFeatures[nameOfFeature] = true;
}
function getLabelAttribute(e) {
  let value = e.getAttribute("data-openreplay-label");
  if (value !== null) {
    return value;
  }
  value = e.getAttribute("data-asayer-label");
  if (value !== null) {
    deprecationWarn('"data-asayer-label" attribute', '"data-openreplay-label" attribute', "/");
  }
  return value;
}
function hasOpenreplayAttribute(e, attr2) {
  const newName = `data-openreplay-${attr2}`;
  if (e.hasAttribute(newName)) {
    if (DEPRECATED_ATTRS[attr2]) {
      deprecationWarn(
        `"${newName}" attribute`,
        // @ts-ignore
        `"${DEPRECATED_ATTRS[attr2]}" attribute`,
        "/installation/sanitize-data"
      );
    }
    return true;
  }
  return false;
}
function canAccessIframe(iframe) {
  try {
    return Boolean(iframe.contentDocument);
  } catch (e) {
    return false;
  }
}
function dec2hex(dec) {
  return dec.toString(16).padStart(2, "0");
}
function generateRandomId(len) {
  const arr = new Uint8Array((len || 40) / 2);
  const safeCrypto = window.crypto || window.msCrypto;
  if (safeCrypto) {
    safeCrypto.getRandomValues(arr);
    return Array.from(arr, dec2hex).join("");
  } else {
    return Array.from({ length: len || 40 }, () => dec2hex(Math.floor(Math.random() * 16))).join("");
  }
}
function inIframe() {
  try {
    return window.self && window.top && window.self !== window.top;
  } catch (e) {
    return true;
  }
}
function ngSafeBrowserMethod(method) {
  return window.Zone && "__symbol__" in window.Zone ? (
    // @ts-ignore
    window["Zone"]["__symbol__"](method)
  ) : method;
}
function createMutationObserver(cb) {
  const mObserver = ngSafeBrowserMethod("MutationObserver");
  return new window[mObserver](cb);
}
function createEventListener(target, event, cb, capture) {
  const safeAddEventListener = ngSafeBrowserMethod("addEventListener");
  try {
    target[safeAddEventListener](event, cb, capture);
  } catch (e) {
    const msg = e.message;
    console.debug(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Openreplay: ${msg}; if this error is caused by an IframeObserver, ignore it`
    );
  }
}
function deleteEventListener(target, event, cb, capture) {
  const safeRemoveEventListener = ngSafeBrowserMethod("removeEventListener");
  try {
    target[safeRemoveEventListener](event, cb, capture);
  } catch (e) {
    const msg = e.message;
    console.debug(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Openreplay: ${msg}; if this error is caused by an IframeObserver, ignore it`
    );
  }
}
var FIFOTaskScheduler = class {
  constructor() {
    this.taskQueue = [];
    this.isRunning = false;
  }
  // Adds a task to the queue
  addTask(task) {
    this.taskQueue.push(task);
    this.runTasks();
  }
  // Runs tasks from the queue
  runTasks() {
    if (this.isRunning || this.taskQueue.length === 0) {
      return;
    }
    this.isRunning = true;
    const executeNextTask = () => {
      if (this.taskQueue.length === 0) {
        this.isRunning = false;
        return;
      }
      const nextTask = this.taskQueue.shift();
      Promise.resolve(nextTask()).then(() => {
        requestAnimationFrame(() => executeNextTask());
      });
    };
    executeNextTask();
  }
};
var scheduler = new FIFOTaskScheduler();
function requestIdleCb(callback) {
  scheduler.addTask(callback);
}
function simpleMerge(defaultObj, givenObj) {
  const result = { ...defaultObj };
  for (const key in givenObj) {
    if (givenObj.hasOwnProperty(key)) {
      const userOptionValue = givenObj[key];
      const defaultOptionValue = defaultObj[key];
      if (typeof userOptionValue === "object" && !Array.isArray(userOptionValue) && userOptionValue !== null) {
        result[key] = simpleMerge(defaultOptionValue || {}, userOptionValue);
      } else {
        result[key] = userOptionValue;
      }
    }
  }
  return result;
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/messages.gen.js
var messages_gen_exports = {};
__export(messages_gen_exports, {
  AdoptedSSAddOwner: () => AdoptedSSAddOwner,
  AdoptedSSDeleteRule: () => AdoptedSSDeleteRule,
  AdoptedSSInsertRuleURLBased: () => AdoptedSSInsertRuleURLBased,
  AdoptedSSRemoveOwner: () => AdoptedSSRemoveOwner,
  AdoptedSSReplaceURLBased: () => AdoptedSSReplaceURLBased,
  BatchMetadata: () => BatchMetadata,
  CSSDeleteRule: () => CSSDeleteRule,
  CSSInsertRule: () => CSSInsertRule,
  CSSInsertRuleURLBased: () => CSSInsertRuleURLBased,
  CanvasNode: () => CanvasNode,
  ConnectionInformation: () => ConnectionInformation,
  ConsoleLog: () => ConsoleLog,
  CreateDocument: () => CreateDocument,
  CreateElementNode: () => CreateElementNode,
  CreateIFrameDocument: () => CreateIFrameDocument,
  CreateTextNode: () => CreateTextNode,
  CustomEvent: () => CustomEvent,
  CustomIssue: () => CustomIssue,
  Fetch: () => Fetch,
  GraphQL: () => GraphQL,
  GraphQLDeprecated: () => GraphQLDeprecated,
  InputChange: () => InputChange,
  JSException: () => JSException,
  LoadFontFace: () => LoadFontFace,
  LongTask: () => LongTask,
  Metadata: () => Metadata,
  MobX: () => MobX,
  MouseClick: () => MouseClick,
  MouseClickDeprecated: () => MouseClickDeprecated,
  MouseMove: () => MouseMove,
  MouseThrashing: () => MouseThrashing,
  MoveNode: () => MoveNode,
  NetworkRequest: () => NetworkRequest,
  NetworkRequestDeprecated: () => NetworkRequestDeprecated,
  NgRx: () => NgRx,
  OTable: () => OTable,
  PageLoadTiming: () => PageLoadTiming,
  PageRenderTiming: () => PageRenderTiming,
  PartitionedMessage: () => PartitionedMessage,
  PerformanceTrack: () => PerformanceTrack,
  Profiler: () => Profiler,
  Redux: () => Redux,
  ReduxDeprecated: () => ReduxDeprecated,
  RemoveNode: () => RemoveNode,
  RemoveNodeAttribute: () => RemoveNodeAttribute,
  ResourceTiming: () => ResourceTiming,
  ResourceTimingDeprecated: () => ResourceTimingDeprecated,
  SelectionChange: () => SelectionChange,
  SetCSSDataURLBased: () => SetCSSDataURLBased,
  SetInputChecked: () => SetInputChecked,
  SetInputTarget: () => SetInputTarget,
  SetInputValue: () => SetInputValue,
  SetNodeAttribute: () => SetNodeAttribute,
  SetNodeAttributeDict: () => SetNodeAttributeDict,
  SetNodeAttributeURLBased: () => SetNodeAttributeURLBased,
  SetNodeData: () => SetNodeData,
  SetNodeFocus: () => SetNodeFocus,
  SetNodeScroll: () => SetNodeScroll,
  SetPageLocation: () => SetPageLocation,
  SetPageLocationDeprecated: () => SetPageLocationDeprecated,
  SetPageVisibility: () => SetPageVisibility,
  SetViewportScroll: () => SetViewportScroll,
  SetViewportSize: () => SetViewportSize,
  StateAction: () => StateAction,
  StringDict: () => StringDict,
  TabChange: () => TabChange,
  TabData: () => TabData,
  TagTrigger: () => TagTrigger,
  TechnicalInfo: () => TechnicalInfo,
  Timestamp: () => Timestamp,
  UnbindNodes: () => UnbindNodes,
  UserAnonymousID: () => UserAnonymousID,
  UserID: () => UserID,
  Vuex: () => Vuex,
  WSChannel: () => WSChannel,
  Zustand: () => Zustand
});
function Timestamp(timestamp) {
  return [
    0,
    timestamp
  ];
}
function SetPageLocationDeprecated(url, referrer, navigationStart) {
  return [
    4,
    url,
    referrer,
    navigationStart
  ];
}
function SetViewportSize(width, height) {
  return [
    5,
    width,
    height
  ];
}
function SetViewportScroll(x, y) {
  return [
    6,
    x,
    y
  ];
}
function CreateDocument() {
  return [
    7
  ];
}
function CreateElementNode(id2, parentID, index2, tag, svg) {
  return [
    8,
    id2,
    parentID,
    index2,
    tag,
    svg
  ];
}
function CreateTextNode(id2, parentID, index2) {
  return [
    9,
    id2,
    parentID,
    index2
  ];
}
function MoveNode(id2, parentID, index2) {
  return [
    10,
    id2,
    parentID,
    index2
  ];
}
function RemoveNode(id2) {
  return [
    11,
    id2
  ];
}
function SetNodeAttribute(id2, name, value) {
  return [
    12,
    id2,
    name,
    value
  ];
}
function RemoveNodeAttribute(id2, name) {
  return [
    13,
    id2,
    name
  ];
}
function SetNodeData(id2, data) {
  return [
    14,
    id2,
    data
  ];
}
function SetNodeScroll(id2, x, y) {
  return [
    16,
    id2,
    x,
    y
  ];
}
function SetInputTarget(id2, label) {
  return [
    17,
    id2,
    label
  ];
}
function SetInputValue(id2, value, mask) {
  return [
    18,
    id2,
    value,
    mask
  ];
}
function SetInputChecked(id2, checked) {
  return [
    19,
    id2,
    checked
  ];
}
function MouseMove(x, y) {
  return [
    20,
    x,
    y
  ];
}
function NetworkRequestDeprecated(type, method, url, request, response, status, timestamp, duration) {
  return [
    21,
    type,
    method,
    url,
    request,
    response,
    status,
    timestamp,
    duration
  ];
}
function ConsoleLog(level, value) {
  return [
    22,
    level,
    value
  ];
}
function PageLoadTiming(requestStart, responseStart, responseEnd, domContentLoadedEventStart, domContentLoadedEventEnd, loadEventStart, loadEventEnd, firstPaint, firstContentfulPaint) {
  return [
    23,
    requestStart,
    responseStart,
    responseEnd,
    domContentLoadedEventStart,
    domContentLoadedEventEnd,
    loadEventStart,
    loadEventEnd,
    firstPaint,
    firstContentfulPaint
  ];
}
function PageRenderTiming(speedIndex, visuallyComplete, timeToInteractive) {
  return [
    24,
    speedIndex,
    visuallyComplete,
    timeToInteractive
  ];
}
function CustomEvent(name, payload) {
  return [
    27,
    name,
    payload
  ];
}
function UserID(id2) {
  return [
    28,
    id2
  ];
}
function UserAnonymousID(id2) {
  return [
    29,
    id2
  ];
}
function Metadata(key, value) {
  return [
    30,
    key,
    value
  ];
}
function CSSInsertRule(id2, rule, index2) {
  return [
    37,
    id2,
    rule,
    index2
  ];
}
function CSSDeleteRule(id2, index2) {
  return [
    38,
    id2,
    index2
  ];
}
function Fetch(method, url, request, response, status, timestamp, duration) {
  return [
    39,
    method,
    url,
    request,
    response,
    status,
    timestamp,
    duration
  ];
}
function Profiler(name, duration, args, result) {
  return [
    40,
    name,
    duration,
    args,
    result
  ];
}
function OTable(key, value) {
  return [
    41,
    key,
    value
  ];
}
function StateAction(type) {
  return [
    42,
    type
  ];
}
function ReduxDeprecated(action, state, duration) {
  return [
    44,
    action,
    state,
    duration
  ];
}
function Vuex(mutation, state) {
  return [
    45,
    mutation,
    state
  ];
}
function MobX(type, payload) {
  return [
    46,
    type,
    payload
  ];
}
function NgRx(action, state, duration) {
  return [
    47,
    action,
    state,
    duration
  ];
}
function GraphQLDeprecated(operationKind, operationName, variables, response, duration) {
  return [
    48,
    operationKind,
    operationName,
    variables,
    response,
    duration
  ];
}
function PerformanceTrack(frames, ticks, totalJSHeapSize, usedJSHeapSize) {
  return [
    49,
    frames,
    ticks,
    totalJSHeapSize,
    usedJSHeapSize
  ];
}
function StringDict(key, value) {
  return [
    50,
    key,
    value
  ];
}
function SetNodeAttributeDict(id2, nameKey, valueKey) {
  return [
    51,
    id2,
    nameKey,
    valueKey
  ];
}
function ResourceTimingDeprecated(timestamp, duration, ttfb, headerSize, encodedBodySize, decodedBodySize, url, initiator) {
  return [
    53,
    timestamp,
    duration,
    ttfb,
    headerSize,
    encodedBodySize,
    decodedBodySize,
    url,
    initiator
  ];
}
function ConnectionInformation(downlink, type) {
  return [
    54,
    downlink,
    type
  ];
}
function SetPageVisibility(hidden) {
  return [
    55,
    hidden
  ];
}
function LoadFontFace(parentID, family, source, descriptors) {
  return [
    57,
    parentID,
    family,
    source,
    descriptors
  ];
}
function SetNodeFocus(id2) {
  return [
    58,
    id2
  ];
}
function LongTask(timestamp, duration, context, containerType, containerSrc, containerId, containerName) {
  return [
    59,
    timestamp,
    duration,
    context,
    containerType,
    containerSrc,
    containerId,
    containerName
  ];
}
function SetNodeAttributeURLBased(id2, name, value, baseURL) {
  return [
    60,
    id2,
    name,
    value,
    baseURL
  ];
}
function SetCSSDataURLBased(id2, data, baseURL) {
  return [
    61,
    id2,
    data,
    baseURL
  ];
}
function TechnicalInfo(type, value) {
  return [
    63,
    type,
    value
  ];
}
function CustomIssue(name, payload) {
  return [
    64,
    name,
    payload
  ];
}
function CSSInsertRuleURLBased(id2, rule, index2, baseURL) {
  return [
    67,
    id2,
    rule,
    index2,
    baseURL
  ];
}
function MouseClick(id2, hesitationTime, label, selector2, normalizedX, normalizedY) {
  return [
    68,
    id2,
    hesitationTime,
    label,
    selector2,
    normalizedX,
    normalizedY
  ];
}
function MouseClickDeprecated(id2, hesitationTime, label, selector2) {
  return [
    69,
    id2,
    hesitationTime,
    label,
    selector2
  ];
}
function CreateIFrameDocument(frameID, id2) {
  return [
    70,
    frameID,
    id2
  ];
}
function AdoptedSSReplaceURLBased(sheetID, text, baseURL) {
  return [
    71,
    sheetID,
    text,
    baseURL
  ];
}
function AdoptedSSInsertRuleURLBased(sheetID, rule, index2, baseURL) {
  return [
    73,
    sheetID,
    rule,
    index2,
    baseURL
  ];
}
function AdoptedSSDeleteRule(sheetID, index2) {
  return [
    75,
    sheetID,
    index2
  ];
}
function AdoptedSSAddOwner(sheetID, id2) {
  return [
    76,
    sheetID,
    id2
  ];
}
function AdoptedSSRemoveOwner(sheetID, id2) {
  return [
    77,
    sheetID,
    id2
  ];
}
function JSException(name, message, payload, metadata) {
  return [
    78,
    name,
    message,
    payload,
    metadata
  ];
}
function Zustand(mutation, state) {
  return [
    79,
    mutation,
    state
  ];
}
function BatchMetadata(version, pageNo, firstIndex, timestamp, location2) {
  return [
    81,
    version,
    pageNo,
    firstIndex,
    timestamp,
    location2
  ];
}
function PartitionedMessage(partNo, partTotal) {
  return [
    82,
    partNo,
    partTotal
  ];
}
function NetworkRequest(type, method, url, request, response, status, timestamp, duration, transferredBodySize) {
  return [
    83,
    type,
    method,
    url,
    request,
    response,
    status,
    timestamp,
    duration,
    transferredBodySize
  ];
}
function WSChannel(chType, channelName, data, timestamp, dir, messageType) {
  return [
    84,
    chType,
    channelName,
    data,
    timestamp,
    dir,
    messageType
  ];
}
function InputChange(id2, value, valueMasked, label, hesitationTime, inputDuration) {
  return [
    112,
    id2,
    value,
    valueMasked,
    label,
    hesitationTime,
    inputDuration
  ];
}
function SelectionChange(selectionStart, selectionEnd, selection2) {
  return [
    113,
    selectionStart,
    selectionEnd,
    selection2
  ];
}
function MouseThrashing(timestamp) {
  return [
    114,
    timestamp
  ];
}
function UnbindNodes(totalRemovedPercent) {
  return [
    115,
    totalRemovedPercent
  ];
}
function ResourceTiming(timestamp, duration, ttfb, headerSize, encodedBodySize, decodedBodySize, url, initiator, transferredSize, cached) {
  return [
    116,
    timestamp,
    duration,
    ttfb,
    headerSize,
    encodedBodySize,
    decodedBodySize,
    url,
    initiator,
    transferredSize,
    cached
  ];
}
function TabChange(tabId) {
  return [
    117,
    tabId
  ];
}
function TabData(tabId) {
  return [
    118,
    tabId
  ];
}
function CanvasNode(nodeId, timestamp) {
  return [
    119,
    nodeId,
    timestamp
  ];
}
function TagTrigger(tagId) {
  return [
    120,
    tagId
  ];
}
function Redux(action, state, duration, actionTime) {
  return [
    121,
    action,
    state,
    duration,
    actionTime
  ];
}
function SetPageLocation(url, referrer, navigationStart, documentTitle) {
  return [
    122,
    url,
    referrer,
    navigationStart,
    documentTitle
  ];
}
function GraphQL(operationKind, operationName, variables, response, duration) {
  return [
    123,
    operationKind,
    operationName,
    variables,
    response,
    duration
  ];
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/performance.js
var perf = IN_BROWSER && "performance" in window && "memory" in performance ? performance : { memory: {} };
var deviceMemory = IN_BROWSER ? (navigator.deviceMemory || 0) * 1024 : 0;
var jsHeapSizeLimit = perf.memory.jsHeapSizeLimit || 0;
function performance_default(app, opts) {
  const options = Object.assign({
    capturePerformance: true
  }, opts);
  if (!options.capturePerformance) {
    return;
  }
  let frames;
  let ticks;
  const nextFrame = () => {
    if (frames === void 0 || frames === -1) {
      return;
    }
    frames++;
    requestAnimationFrame(nextFrame);
  };
  app.ticker.attach(() => {
    if (ticks === void 0 || ticks === -1) {
      return;
    }
    ticks++;
  }, 0, false);
  const sendPerformanceTrack = () => {
    if (frames === void 0 || ticks === void 0) {
      return;
    }
    app.send(PerformanceTrack(frames, ticks, perf.memory.totalJSHeapSize || 0, perf.memory.usedJSHeapSize || 0));
    ticks = frames = document.hidden ? -1 : 0;
  };
  app.attachStartCallback(() => {
    ticks = frames = -1;
    sendPerformanceTrack();
    nextFrame();
  });
  app.attachStopCallback(() => {
    ticks = frames = void 0;
  });
  app.ticker.attach(sendPerformanceTrack, 40, false);
  if (document.hidden !== void 0) {
    app.attachEventListener(document, "visibilitychange", sendPerformanceTrack, false, false);
  }
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/tagWatcher.js
var WATCHED_TAGS_KEY = "__or__watched_tags__";
var TagWatcher = class {
  constructor(sessionStorage, errLog, onTag) {
    this.sessionStorage = sessionStorage;
    this.errLog = errLog;
    this.onTag = onTag;
    this.intervals = {};
    this.tags = [];
    const tags = JSON.parse(sessionStorage.getItem(WATCHED_TAGS_KEY) ?? "[]");
    this.setTags(tags);
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          if (entry.target) {
            const tag = entry.target.__or_watcher_tagname;
            if (tag) {
              this.onTagRendered(tag);
            }
            this.observer.unobserve(entry.target);
          }
        }
      });
    });
  }
  async fetchTags(ingest, token) {
    return fetch(`${ingest}/v1/web/tags`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`
      }
    }).then((r) => r.json()).then(({ tags }) => {
      if (tags && tags.length) {
        this.setTags(tags);
        const tagString = JSON.stringify(tags);
        this.sessionStorage.setItem(WATCHED_TAGS_KEY, tagString || "");
      }
    }).catch((e) => this.errLog(e));
  }
  setTags(tags) {
    this.tags = tags;
    this.intervals = {};
    tags.forEach((tag) => {
      this.intervals[tag.id] = setInterval(() => {
        const possibleEls = document.querySelectorAll(tag.selector);
        if (possibleEls.length > 0) {
          const el = possibleEls[0];
          el.__or_watcher_tagname = tag.id;
          this.observer.observe(el);
        }
      }, 500);
    });
  }
  onTagRendered(tagId) {
    if (this.intervals[tagId]) {
      clearInterval(this.intervals[tagId]);
    }
    this.onTag(tagId);
  }
  clear() {
    this.tags.forEach((tag) => {
      clearInterval(this.intervals[tag.id]);
    });
    this.tags = [];
    this.intervals = {};
    this.observer.disconnect();
  }
};
var tagWatcher_default = TagWatcher;

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/styles.js
var bgStyle = {
  position: "fixed",
  top: 0,
  left: 0,
  width: "100vw",
  height: "100vh",
  background: "rgba(0, 0, 0, 0.40)",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  zIndex: 999999,
  fontFamily: `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`
};
var containerStyle = {
  display: "flex",
  flexDirection: "column",
  gap: "2rem",
  alignItems: "center",
  padding: "1.5rem",
  borderRadius: "2px",
  border: "1px solid #D9D9D9",
  background: "#FFF",
  width: "22rem"
};
var containerWidgetStyle = {
  display: "flex",
  "flex-direction": "column",
  gap: "unset",
  "align-items": "center",
  padding: "unset",
  fontFamily: `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
  "border-radius": "2px",
  border: "1px solid #D9D9D9",
  background: "rgba(255, 255, 255, 0.75)",
  width: "22rem"
};
var titleStyle = {
  fontFamily: "Verdana, sans-serif",
  fontSize: "1.25rem",
  fontStyle: "normal",
  fontWeight: "500",
  lineHeight: "1.75rem",
  color: "rgba(0, 0, 0, 0.85)"
};
var descriptionStyle = {
  borderTop: "1px solid rgba(0, 0, 0, 0.06)",
  borderBottom: "1px solid rgba(0, 0, 0, 0.06)",
  padding: "1.25rem 0rem",
  color: "rgba(0, 0, 0, 0.85)",
  fontFamily: "Verdana, sans-serif",
  fontSize: "13px",
  fontStyle: "normal",
  fontWeight: "400",
  lineHeight: "auto",
  whiteSpace: "pre-wrap"
};
var buttonStyle = {
  display: "flex",
  padding: "0.4rem 0.9375rem",
  justifyContent: "center",
  alignItems: "center",
  gap: "0.625rem",
  borderRadius: "0.25rem",
  border: "1px solid #394EFF",
  background: "#394EFF",
  boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
  color: "#FFF",
  textAlign: "center",
  fontFamily: "Verdana, sans-serif",
  fontSize: "1rem",
  fontStyle: "normal",
  fontWeight: "500",
  lineHeight: "1.5rem",
  cursor: "pointer"
};
var sectionTitleStyle = {
  fontFamily: "Verdana, sans-serif",
  fontSize: "13px",
  fontWeight: "500",
  lineHeight: "auto",
  display: "flex",
  justifyContent: "space-between",
  width: "100%",
  cursor: "pointer"
};
var contentStyle = {
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start",
  gap: "0.625rem",
  fontSize: "13px",
  lineHeight: "auto"
};
var titleWidgetStyle = {
  padding: "0.5rem",
  gap: "0.5rem",
  fontFamily: "Verdana, sans-serif",
  fontSize: "16px",
  fontStyle: "normal",
  fontWeight: "500",
  lineHeight: "auto",
  color: "white",
  display: "flex",
  alignItems: "center",
  width: "100%",
  borderRadius: "2px",
  background: "rgba(0, 0, 0, 0.75)",
  boxSizing: "border-box"
};
var descriptionWidgetStyle = {
  boxSizing: "border-box",
  display: "block",
  width: "100%",
  borderBottom: "1px solid #D9D9D9",
  background: "#FFF",
  padding: "0.65rem",
  alignSelf: "stretch",
  color: "#000",
  fontFamily: "Verdana, sans-serif",
  // fontSize: '0.875rem',
  fontStyle: "normal",
  fontWeight: "400"
  // lineHeight: '1.375rem',
};
var endSectionStyle = {
  ...descriptionWidgetStyle,
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  gap: "0.625rem"
};
var symbolIcon = {
  fontSize: "1.25rem",
  fontWeight: "500",
  cursor: "pointer",
  color: "#394EFF"
};
var buttonWidgetStyle = {
  display: "flex",
  padding: "0.4rem 0.9375rem",
  justifyContent: "center",
  alignItems: "center",
  gap: "0.625rem",
  borderRadius: "0.25rem",
  border: "1px solid #394EFF",
  background: "#394EFF",
  boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
  color: "#FFF",
  textAlign: "center",
  fontFamily: "Verdana, sans-serif",
  fontSize: "1rem",
  fontStyle: "normal",
  fontWeight: "500",
  lineHeight: "1.5rem",
  width: "100%",
  boxSizing: "border-box",
  cursor: "pointer"
};
var stopWidgetStyle = {
  marginTop: "1rem",
  marginBottom: "1rem",
  cursor: "pointer",
  display: "block",
  fontWeight: "500",
  fontSize: "13px!important",
  lineHeight: "auto"
};
var paginationStyle = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  gap: "1rem",
  padding: "0.5rem",
  width: "100%",
  boxSizing: "border-box"
};
var taskNumberActive = {
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: "6.25em",
  outline: "1px solid #394EFF",
  fontSize: "13px",
  height: "24px",
  width: "24px"
};
var taskNumberDone = {
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: "6.25em",
  outline: "1px solid #D2DFFF",
  boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
  background: "#D2DFFF",
  fontSize: "13px",
  height: "24px",
  width: "24px"
};
var taskDescriptionCard = {
  borderRadius: "0.375rem",
  border: "1px solid rgba(0, 0, 0, 0.06)",
  background: "#F5F7FF",
  boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
  display: "flex",
  flexDirection: "column",
  padding: "0.625rem 0.9375rem",
  gap: "0.5rem",
  alignSelf: "stretch"
};
var taskTextStyle = {
  fontWeight: "bold"
};
var taskDescriptionStyle = {
  fontSize: "13px",
  lineHeight: "auto"
};
var taskButtonStyle = {
  marginRight: "0.5rem",
  cursor: "pointer",
  color: "#394EFF",
  textAlign: "center",
  fontFamily: "Verdana, sans-serif",
  fontSize: "13px",
  fontStyle: "normal",
  fontWeight: "500",
  lineHeight: "auto"
};
var taskButtonBorderedStyle = {
  ...taskButtonStyle,
  display: "flex",
  padding: "0.25rem 0.9375rem",
  justifyContent: "center",
  alignItems: "center",
  gap: "0.5rem",
  borderRadius: "0.25rem",
  border: "1px solid #394EFF"
};
var taskButtonsRow = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  width: "100%",
  boxSizing: "border-box"
};
var spinnerStyles = {
  border: "4px solid rgba(255, 255, 255, 0.4)",
  width: "16px",
  height: "16px",
  borderRadius: "50%",
  borderLeftColor: "#fff",
  animation: "spin 0.5s linear infinite"
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/recorder.js
var Quality = {
  Standard: { width: 1280, height: 720 },
  High: { width: 1920, height: 1080 }
};
var Recorder = class {
  constructor(app) {
    this.app = app;
    this.mediaRecorder = null;
    this.recordedChunks = [];
    this.stream = null;
    this.recStartTs = null;
  }
  async startRecording(fps, quality, micReq, camReq) {
    this.recStartTs = this.app.timestamp();
    const videoConstraints = quality;
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({
        video: camReq ? { ...videoConstraints, frameRate: { ideal: fps } } : false,
        audio: micReq
      });
      this.mediaRecorder = new MediaRecorder(this.stream, {
        mimeType: "video/webm;codecs=vp9"
      });
      this.recordedChunks = [];
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.recordedChunks.push(event.data);
        }
      };
      this.mediaRecorder.start();
    } catch (error) {
      console.error(error);
    }
  }
  async stopRecording() {
    return new Promise((resolve) => {
      if (!this.mediaRecorder)
        return;
      this.mediaRecorder.onstop = () => {
        const blob = new Blob(this.recordedChunks, {
          type: "video/webm"
        });
        resolve(blob);
      };
      this.mediaRecorder.stop();
    });
  }
  async sendToAPI() {
    const blob = await this.stopRecording();
    return fetch(`${this.app.options.ingestPoint}/v1/web/uxt/upload-url`, {
      headers: {
        Authorization: `Bearer ${this.app.session.getSessionToken()}`
      }
    }).then((r) => {
      if (r.ok) {
        return r.json();
      } else {
        throw new Error("Failed to get upload url");
      }
    }).then(({ url }) => {
      return fetch(url, {
        method: "PUT",
        headers: {
          "Content-Type": "video/webm"
        },
        body: blob
      });
    }).catch(console.error).finally(() => {
      this.discard();
    });
  }
  async saveToFile(fileName = "recorded-video.webm") {
    const blob = await this.stopRecording();
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
  }
  discard() {
    var _a3, _b2;
    (_a3 = this.mediaRecorder) == null ? void 0 : _a3.stop();
    (_b2 = this.stream) == null ? void 0 : _b2.getTracks().forEach((track) => track.stop());
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/dnd.js
function attachDND(element, dragTarget) {
  dragTarget.onmousedown = function(event) {
    const clientRect = element.getBoundingClientRect();
    const shiftX = event.clientX - clientRect.left;
    const shiftY = event.clientY - clientRect.top;
    element.style.position = "fixed";
    element.style.zIndex = 99999999999999;
    moveAt(event.pageX, event.pageY);
    function moveAt(pageX, pageY) {
      let leftC = pageX - shiftX;
      let topC = pageY - shiftY;
      if (leftC <= 5)
        leftC = 5;
      if (topC <= 5)
        topC = 5;
      if (leftC >= window.innerWidth - clientRect.width)
        leftC = window.innerWidth - clientRect.width;
      if (topC >= window.innerHeight - clientRect.height)
        topC = window.innerHeight - clientRect.height;
      element.style.left = `${leftC}px`;
      element.style.top = `${topC}px`;
    }
    function onMouseMove(event2) {
      moveAt(event2.pageX, event2.pageY);
    }
    document.addEventListener("mousemove", onMouseMove);
    const clearAll = () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", clearAll);
    };
    document.addEventListener("mouseup", clearAll);
  };
  dragTarget.ondragstart = function() {
    return false;
  };
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/utils.js
function generateGrid() {
  const grid = document.createElement("div");
  grid.className = "grid";
  for (let i = 0; i < 16; i++) {
    const cell = document.createElement("div");
    Object.assign(cell.style, {
      width: "2px",
      height: "2px",
      borderRadius: "10px",
      background: "white"
    });
    cell.className = "cell";
    grid.appendChild(cell);
  }
  Object.assign(grid.style, {
    display: "grid",
    gridTemplateColumns: "repeat(4, 1fr)",
    gridTemplateRows: "repeat(4, 1fr)",
    gap: "2px",
    cursor: "grab"
  });
  return grid;
}
function generateChevron() {
  const triangle = document.createElement("div");
  Object.assign(triangle.style, {
    width: "0",
    height: "0",
    borderLeft: "7px solid transparent",
    borderRight: "7px solid transparent",
    borderBottom: "7px solid white"
  });
  const container = document.createElement("div");
  container.appendChild(triangle);
  Object.assign(container.style, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: "16px",
    height: "16px",
    cursor: "pointer",
    marginLeft: "auto",
    transform: "rotate(180deg)"
  });
  return container;
}
function addKeyframes() {
  const styleSheet = document.createElement("style");
  styleSheet.type = "text/css";
  styleSheet.innerText = `@keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }`;
  document.head.appendChild(styleSheet);
}
function createSpinner() {
  addKeyframes();
  const spinner = document.createElement("div");
  spinner.classList.add("spinner");
  Object.assign(spinner.style, spinnerStyles);
  return spinner;
}
function createElement(tag, className, styles, textContent, id2) {
  const element = document.createElement(tag);
  element.className = className;
  Object.assign(element.style, styles);
  if (textContent) {
    element.textContent = textContent;
  }
  if (id2) {
    element.id = id2;
  }
  return element;
}
var TEST_START = "or_uxt_test_start";
var TASK_IND = "or_uxt_task_index";
var SESSION_ID = "or_uxt_session_id";
var TEST_ID = "or_uxt_test_id";

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/SignalManager.js
var SignalManager = class {
  constructor(ingestPoint, getTimestamp, token, testId, storageKey, setStorageKey, removeStorageKey, getStorageKey, getSessionId) {
    this.ingestPoint = ingestPoint;
    this.getTimestamp = getTimestamp;
    this.token = token;
    this.testId = testId;
    this.storageKey = storageKey;
    this.setStorageKey = setStorageKey;
    this.removeStorageKey = removeStorageKey;
    this.getStorageKey = getStorageKey;
    this.getSessionId = getSessionId;
    this.durations = {
      testStart: 0,
      tasks: []
    };
    this.getDurations = () => {
      return this.durations;
    };
    this.setDurations = (durations) => {
      this.durations.testStart = durations.testStart;
      this.durations.tasks = durations.tasks;
    };
    this.signalTask = (taskId, status, taskAnswer) => {
      if (!taskId)
        return console.error("User Testing: No Task ID Given");
      const taskStart = this.durations.tasks.find((t) => t.taskId === taskId);
      const timestamp = this.getTimestamp();
      const duration = taskStart ? timestamp - taskStart.started : 0;
      return fetch(`${this.ingestPoint}/v1/web/uxt/signals/task`, {
        method: "POST",
        headers: {
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          Authorization: `Bearer ${this.token}`
        },
        body: JSON.stringify({
          testId: this.testId,
          taskId,
          status,
          duration,
          timestamp,
          taskAnswer
        })
      });
    };
    this.signalTest = (status) => {
      const timestamp = this.getTimestamp();
      if (status === "begin" && this.testId) {
        const sessionId = this.getSessionId();
        this.setStorageKey(SESSION_ID, sessionId);
        this.setStorageKey(this.storageKey, this.testId.toString());
        this.setStorageKey(TEST_START, timestamp.toString());
      } else {
        this.removeStorageKey(this.storageKey);
        this.removeStorageKey(TASK_IND);
        this.removeStorageKey(TEST_START);
      }
      const start2 = this.durations.testStart || timestamp;
      const duration = timestamp - start2;
      return fetch(`${this.ingestPoint}/v1/web/uxt/signals/test`, {
        method: "POST",
        headers: {
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          Authorization: `Bearer ${this.token}`
        },
        body: JSON.stringify({
          testId: this.testId,
          status,
          duration,
          timestamp
        })
      });
    };
    const possibleStart = this.getStorageKey(TEST_START);
    if (possibleStart) {
      this.durations.testStart = parseInt(possibleStart, 10);
    }
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/userTesting/index.js
var UserTestManager = class {
  constructor(app, storageKey) {
    this.app = app;
    this.storageKey = storageKey;
    this.bg = createElement("div", "bg", bgStyle, void 0, "__or_ut_bg");
    this.container = createElement("div", "container", containerStyle, void 0, "__or_ut_ct");
    this.widgetGuidelinesVisible = true;
    this.widgetTasksVisible = false;
    this.widgetVisible = true;
    this.isActive = false;
    this.descriptionSection = null;
    this.taskSection = null;
    this.endSection = null;
    this.stopButton = null;
    this.stopButtonContainer = null;
    this.test = null;
    this.testId = null;
    this.signalManager = null;
    this.getTest = (id2, token, inProgress) => {
      this.testId = id2;
      const ingest = this.app.options.ingestPoint;
      return fetch(`${ingest}/v1/web/uxt/test/${id2}`, {
        headers: {
          Authorization: `Bearer ${token}`
        }
      }).then((res) => res.json()).then(({ test }) => {
        this.isActive = true;
        this.test = test;
        this.signalManager = new SignalManager(this.app.options.ingestPoint, () => this.app.timestamp(), token, id2, this.storageKey, (k, v) => this.app.localStorage.setItem(k, v), (k) => this.app.localStorage.removeItem(k), (k) => this.app.localStorage.getItem(k), () => this.app.getSessionID());
        this.createGreeting(test.title, test.reqMic, test.reqCamera);
        if (inProgress) {
          if (test.reqMic || test.reqCamera) {
            void this.userRecorder.startRecording(30, Quality.Standard, test.reqMic, test.reqCamera);
          }
          this.showWidget(test.description, test.tasks, true);
          this.showTaskSection();
        }
      }).then(() => id2).catch((err2) => {
        console.log("OR: Error fetching test", err2);
      });
    };
    this.hideTaskSection = () => false;
    this.showTaskSection = () => true;
    this.collapseWidget = () => false;
    this.removeGreeting = () => false;
    this.toggleDescriptionVisibility = () => {
    };
    this.currentTaskIndex = 0;
    this.userRecorder = new Recorder(app);
    const sessionId = this.app.getSessionID();
    const savedSessionId = this.app.localStorage.getItem(SESSION_ID);
    if (sessionId !== savedSessionId) {
      this.app.localStorage.removeItem(this.storageKey);
      this.app.localStorage.removeItem(SESSION_ID);
      this.app.localStorage.removeItem(TEST_ID);
      this.app.localStorage.removeItem(TASK_IND);
      this.app.localStorage.removeItem(TEST_START);
    }
    const taskIndex = this.app.localStorage.getItem(TASK_IND);
    if (taskIndex) {
      this.currentTaskIndex = parseInt(taskIndex, 10);
    }
  }
  getTestId() {
    return this.testId;
  }
  createGreeting(title, micRequired, cameraRequired) {
    const titleElement = createElement("div", "title", titleStyle, title);
    const descriptionElement = createElement("div", "description", descriptionStyle, `Welcome, you're here to help us improve, not to be judged. Your insights matter!

📹 We're recording this browser tab to learn from your experience.
🎤 Please enable mic and camera if asked, to give us a complete picture.`);
    const buttonElement = createElement("div", "button", buttonStyle, "Read guidelines to begin");
    this.removeGreeting = () => {
      if (micRequired || cameraRequired) {
        void this.userRecorder.startRecording(30, Quality.Standard, micRequired, cameraRequired);
      }
      this.container.removeChild(buttonElement);
      this.container.removeChild(descriptionElement);
      this.container.removeChild(titleElement);
      return false;
    };
    buttonElement.onclick = () => {
      var _a3, _b2, _c, _d;
      this.removeGreeting();
      const durations = (_a3 = this.signalManager) == null ? void 0 : _a3.getDurations();
      if (durations && this.signalManager) {
        durations.testStart = this.app.timestamp();
        this.signalManager.setDurations(durations);
      }
      void ((_b2 = this.signalManager) == null ? void 0 : _b2.signalTest("begin"));
      this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
      Object.assign(this.container.style, containerWidgetStyle);
      this.showWidget(((_c = this.test) == null ? void 0 : _c.guidelines) || "", ((_d = this.test) == null ? void 0 : _d.tasks) || []);
    };
    this.container.append(titleElement, descriptionElement, buttonElement);
    this.bg.appendChild(this.container);
    document.body.appendChild(this.bg);
  }
  showWidget(guidelines, tasks, inProgress) {
    this.container.innerHTML = "";
    Object.assign(this.bg.style, {
      position: "fixed",
      zIndex: 99999999999999,
      right: "8px",
      left: "unset",
      width: "fit-content",
      top: "8px",
      height: "fit-content",
      background: "unset",
      display: "unset",
      alignItems: "unset",
      justifyContent: "unset"
    });
    const titleSection = this.createTitleSection();
    this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
    Object.assign(this.container.style, containerWidgetStyle);
    const descriptionSection = this.createDescriptionSection(guidelines);
    const tasksSection = this.createTasksSection(tasks);
    const stopButton = createElement("div", "stop_bn_or", stopWidgetStyle, "Abort Session");
    const stopContainer = createElement("div", "stop_ct_or", { fontSize: "13px!important" });
    stopContainer.style.fontSize = "13px";
    stopContainer.append(stopButton);
    this.container.append(titleSection, descriptionSection, tasksSection, stopContainer);
    this.taskSection = tasksSection;
    this.descriptionSection = descriptionSection;
    this.stopButton = stopButton;
    this.stopButtonContainer = stopContainer;
    stopButton.onclick = () => {
      var _a3;
      this.userRecorder.discard();
      void ((_a3 = this.signalManager) == null ? void 0 : _a3.signalTest("skipped"));
      document.body.removeChild(this.bg);
      window.close();
    };
    if (!inProgress) {
      this.hideTaskSection();
    } else {
      this.toggleDescriptionVisibility();
    }
  }
  createTitleSection() {
    var _a3;
    const title = createElement("div", "title", titleWidgetStyle);
    const leftIcon = generateGrid();
    const titleText = createElement("div", "title_text", {
      maxWidth: "19rem",
      overflow: "hidden",
      textOverflow: "ellipsis",
      width: "100%",
      fontSize: 16,
      lineHeight: "auto",
      cursor: "pointer"
    }, (_a3 = this.test) == null ? void 0 : _a3.title);
    const rightIcon = generateChevron();
    title.append(leftIcon, titleText, rightIcon);
    const toggleWidget = (isVisible) => {
      this.widgetVisible = isVisible;
      this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
      Object.assign(this.container.style, this.widgetVisible ? containerWidgetStyle : { border: "none", background: "none", padding: 0 });
      if (this.taskSection) {
        Object.assign(this.taskSection.style, this.widgetVisible ? descriptionWidgetStyle : { display: "none" });
      }
      if (this.descriptionSection) {
        Object.assign(this.descriptionSection.style, this.widgetVisible ? descriptionWidgetStyle : { display: "none" });
      }
      if (this.endSection) {
        Object.assign(this.endSection.style, this.widgetVisible ? descriptionWidgetStyle : { display: "none" });
      }
      if (this.stopButton) {
        Object.assign(this.stopButton.style, this.widgetVisible ? stopWidgetStyle : { display: "none" });
      }
      return isVisible;
    };
    const collapseWidget = () => {
      Object.assign(rightIcon.style, {
        transform: this.widgetVisible ? "rotate(0deg)" : "rotate(180deg)"
      });
      toggleWidget(!this.widgetVisible);
    };
    titleText.onclick = collapseWidget;
    rightIcon.onclick = collapseWidget;
    attachDND(this.bg, leftIcon);
    this.collapseWidget = () => toggleWidget(false);
    return title;
  }
  createDescriptionSection(guidelines) {
    const section = createElement("div", "description_section_or", descriptionWidgetStyle);
    const titleContainer = createElement("div", "description_s_title_or", sectionTitleStyle);
    const title = createElement("div", "title", {
      fontSize: 13,
      fontWeight: 500,
      lineHeight: "auto"
    }, "Introduction & Guidelines");
    const icon = createElement("div", "icon", symbolIcon, "-");
    const content = createElement("div", "content", contentStyle);
    const descriptionC = createElement("div", "text_description", {
      maxHeight: "250px",
      overflowY: "auto",
      whiteSpace: "pre-wrap",
      fontSize: 13,
      color: "#454545",
      lineHeight: "auto"
    });
    descriptionC.innerHTML = guidelines;
    const button = createElement("div", "button_begin_or", buttonWidgetStyle, "Begin Test");
    titleContainer.append(title, icon);
    content.append(descriptionC, button);
    section.append(titleContainer, content);
    const toggleDescriptionVisibility = () => {
      this.widgetGuidelinesVisible = !this.widgetGuidelinesVisible;
      icon.textContent = this.widgetGuidelinesVisible ? "-" : "+";
      Object.assign(content.style, this.widgetGuidelinesVisible ? contentStyle : { display: "none" });
    };
    titleContainer.onclick = toggleDescriptionVisibility;
    this.toggleDescriptionVisibility = () => {
      this.widgetGuidelinesVisible = false;
      icon.textContent = this.widgetGuidelinesVisible ? "-" : "+";
      Object.assign(content.style, this.widgetGuidelinesVisible ? contentStyle : { display: "none" });
      content.removeChild(button);
    };
    button.onclick = () => {
      var _a3, _b2, _c;
      toggleDescriptionVisibility();
      if (this.test) {
        const durations = (_a3 = this.signalManager) == null ? void 0 : _a3.getDurations();
        const taskDurationInd = durations ? durations.tasks.findIndex((t) => this.test && t.taskId === this.test.tasks[0].task_id) : null;
        if (durations && taskDurationInd === -1) {
          durations.tasks.push({
            taskId: this.test.tasks[0].task_id,
            started: this.app.timestamp()
          });
          (_b2 = this.signalManager) == null ? void 0 : _b2.setDurations(durations);
        }
        void ((_c = this.signalManager) == null ? void 0 : _c.signalTask(this.test.tasks[0].task_id, "begin"));
      }
      this.showTaskSection();
      content.removeChild(button);
    };
    return section;
  }
  createTasksSection(tasks) {
    this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
    Object.assign(this.container.style, containerWidgetStyle);
    const section = createElement("div", "task_section_or", descriptionWidgetStyle);
    const titleContainer = createElement("div", "description_t_title_or", sectionTitleStyle);
    const title = createElement("div", "title", {
      fontSize: "13px",
      fontWeight: "500",
      lineHeight: "auto"
    }, "Tasks");
    const icon = createElement("div", "icon", symbolIcon, "-");
    const content = createElement("div", "content", contentStyle);
    const pagination = createElement("div", "pagination", paginationStyle);
    const taskCard = createElement("div", "taskCard", taskDescriptionCard);
    const taskText = createElement("div", "taskText", taskTextStyle);
    const taskDescription = createElement("div", "taskDescription", taskDescriptionStyle);
    const taskButtons = createElement("div", "taskButtons", taskButtonsRow);
    const inputTitle = createElement("div", "taskText", taskTextStyle);
    inputTitle.textContent = "Your answer";
    const inputArea = createElement("textarea", "taskDescription", {
      resize: "vertical"
    });
    const inputContainer = createElement("div", "inputArea", taskDescriptionCard);
    inputContainer.append(inputTitle, inputArea);
    const closePanelButton = createElement("div", "closePanelButton", taskButtonStyle, "Collapse Panel");
    const nextButton = createElement("div", "nextButton", taskButtonBorderedStyle, "Done, Next");
    titleContainer.append(title, icon);
    taskCard.append(taskText, taskDescription);
    taskButtons.append(closePanelButton, nextButton);
    content.append(pagination, taskCard, inputContainer, taskButtons);
    section.append(titleContainer, content);
    const updateTaskContent = () => {
      const task = tasks[this.currentTaskIndex];
      taskText.textContent = task.title;
      taskDescription.textContent = task.description;
      if (task.allow_typing) {
        inputContainer.style.display = "flex";
      } else {
        inputContainer.style.display = "none";
      }
    };
    tasks.forEach((_, index2) => {
      const pageNumber = createElement("span", `or_task_${index2}`, {
        outline: "1px solid #efefef",
        fontSize: "13px",
        height: "24px",
        width: "24px",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "6.25em"
      }, (index2 + 1).toString());
      pageNumber.id = `or_task_${index2}`;
      pagination.append(pageNumber);
    });
    const toggleTasksVisibility = () => {
      this.widgetTasksVisible = !this.widgetTasksVisible;
      icon.textContent = this.widgetTasksVisible ? "-" : "+";
      Object.assign(content.style, this.widgetTasksVisible ? contentStyle : { display: "none" });
    };
    this.hideTaskSection = () => {
      icon.textContent = "+";
      Object.assign(content.style, {
        display: "none"
      });
      this.widgetTasksVisible = false;
      return false;
    };
    this.showTaskSection = () => {
      icon.textContent = "-";
      Object.assign(content.style, contentStyle);
      this.widgetTasksVisible = true;
      return true;
    };
    const highlightActive = () => {
      const activeTaskEl = document.getElementById(`or_task_${this.currentTaskIndex}`);
      if (activeTaskEl) {
        Object.assign(activeTaskEl.style, taskNumberActive);
      }
      for (let i = 0; i < this.currentTaskIndex; i++) {
        const taskEl = document.getElementById(`or_task_${i}`);
        if (taskEl) {
          Object.assign(taskEl.style, taskNumberDone);
        }
      }
    };
    titleContainer.onclick = toggleTasksVisibility;
    closePanelButton.onclick = this.collapseWidget;
    nextButton.onclick = () => {
      var _a3, _b2, _c, _d;
      const textAnswer = tasks[this.currentTaskIndex].allow_typing ? inputArea.value : void 0;
      inputArea.value = "";
      void ((_a3 = this.signalManager) == null ? void 0 : _a3.signalTask(tasks[this.currentTaskIndex].task_id, "done", textAnswer));
      if (this.currentTaskIndex < tasks.length - 1) {
        this.currentTaskIndex++;
        updateTaskContent();
        const durations = (_b2 = this.signalManager) == null ? void 0 : _b2.getDurations();
        if (durations && durations.tasks.findIndex((t) => t.taskId === tasks[this.currentTaskIndex].task_id) === -1) {
          durations.tasks.push({
            taskId: tasks[this.currentTaskIndex].task_id,
            started: this.app.timestamp()
          });
          (_c = this.signalManager) == null ? void 0 : _c.setDurations(durations);
        }
        void ((_d = this.signalManager) == null ? void 0 : _d.signalTask(tasks[this.currentTaskIndex].task_id, "begin"));
        highlightActive();
      } else {
        this.showEndSection();
      }
      this.app.localStorage.setItem("or_uxt_task_index", this.currentTaskIndex.toString());
    };
    setTimeout(() => {
      const firstTaskEl = document.getElementById("or_task_0");
      if (firstTaskEl) {
        Object.assign(firstTaskEl.style, taskNumberActive);
      }
      updateTaskContent();
      highlightActive();
    }, 1);
    return section;
  }
  showEndSection() {
    var _a3, _b2, _c, _d;
    let isLoading = true;
    void ((_a3 = this.signalManager) == null ? void 0 : _a3.signalTest("done"));
    const section = createElement("div", "end_section_or", endSectionStyle);
    const title = createElement("div", "end_title_or", {
      fontSize: "1.25rem",
      fontWeight: "500"
    }, "Thank you! 👍");
    const description = createElement("div", "end_description_or", {}, ((_b2 = this.test) == null ? void 0 : _b2.conclusion) ?? "Thank you for participating in our usability test. Your feedback has been captured and will be used to enhance our website. \n\nWe appreciate your time and valuable input.");
    const button = createElement("div", "end_button_or", buttonWidgetStyle, "Submitting Feedback");
    const spinner = createSpinner();
    button.appendChild(spinner);
    if (((_c = this.test) == null ? void 0 : _c.reqMic) || ((_d = this.test) == null ? void 0 : _d.reqCamera)) {
      void this.userRecorder.sendToAPI().then(() => {
        button.removeChild(spinner);
        button.textContent = "End Session";
        isLoading = false;
      }).catch((err2) => {
        console.error(err2);
        button.removeChild(spinner);
        button.textContent = "End Session";
        isLoading = false;
      });
    } else {
      button.removeChild(spinner);
      button.textContent = "End Session";
      isLoading = false;
    }
    if (this.taskSection) {
      this.container.removeChild(this.taskSection);
    }
    if (this.descriptionSection) {
      this.container.removeChild(this.descriptionSection);
    }
    if (this.stopButton && this.stopButtonContainer) {
      this.container.removeChild(this.stopButtonContainer);
    }
    button.onclick = () => {
      if (isLoading)
        return;
      window.close();
      document.body.removeChild(this.bg);
    };
    section.append(title, description, button);
    this.endSection = section;
    this.container.append(section);
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/guards.js
function isNode(sth) {
  return !!sth && sth.nodeType != null;
}
function isSVGElement(node) {
  return node.namespaceURI === "http://www.w3.org/2000/svg";
}
function isElementNode(node) {
  return node.nodeType === Node.ELEMENT_NODE;
}
function isCommentNode(node) {
  return node.nodeType === Node.COMMENT_NODE;
}
function isTextNode(node) {
  return node.nodeType === Node.TEXT_NODE;
}
function isDocument(node) {
  return node.nodeType === Node.DOCUMENT_NODE;
}
function isRootNode(node) {
  return node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
function hasTag(el, tagName2) {
  return el.localName === tagName2;
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/canvas.js
var CanvasRecorder = class {
  constructor(app, options) {
    this.app = app;
    this.options = options;
    this.snapshots = {};
    this.intervals = [];
    this.restartTracking = () => {
      this.clear();
      this.app.nodes.scanTree(this.captureCanvas);
    };
    this.captureCanvas = (node) => {
      const id2 = this.app.nodes.getID(node);
      if (!id2 || !hasTag(node, "canvas")) {
        return;
      }
      const isIgnored2 = this.app.sanitizer.isObscured(id2) || this.app.sanitizer.isHidden(id2);
      if (isIgnored2 || !hasTag(node, "canvas") || this.snapshots[id2]) {
        return;
      }
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            if (entry.target) {
              if (this.snapshots[id2] && this.snapshots[id2].createdAt) {
                this.snapshots[id2].paused = false;
              } else {
                this.recordCanvas(entry.target, id2);
              }
            } else {
              if (this.snapshots[id2]) {
                this.snapshots[id2].paused = true;
              }
            }
          }
        });
      });
      observer.observe(node);
    };
    this.recordCanvas = (node, id2) => {
      const ts = this.app.timestamp();
      this.snapshots[id2] = {
        images: [],
        createdAt: ts,
        paused: false,
        dummy: document.createElement("canvas")
      };
      const canvasMsg = CanvasNode(id2.toString(), ts);
      this.app.send(canvasMsg);
      const captureFn = (canvas) => {
        captureSnapshot(canvas, this.options.quality, this.snapshots[id2].dummy, this.options.fixedScaling, this.fileExt, (blob) => {
          if (!blob)
            return;
          this.snapshots[id2].images.push({ id: this.app.timestamp(), data: blob });
          if (this.snapshots[id2].images.length > 9) {
            this.sendSnaps(this.snapshots[id2].images, id2, this.snapshots[id2].createdAt);
            this.snapshots[id2].images = [];
          }
        });
      };
      const int = setInterval(() => {
        const cid = this.app.nodes.getID(node);
        const canvas = cid ? this.app.nodes.getNode(cid) : void 0;
        if (!canvas || !hasTag(canvas, "canvas") || canvas !== node) {
          this.app.debug.log("Canvas element not in sync");
          clearInterval(int);
        } else {
          if (!this.snapshots[id2].paused) {
            if (this.options.useAnimationFrame) {
              requestAnimationFrame(() => {
                captureFn(canvas);
              });
            } else {
              captureFn(canvas);
            }
          }
        }
      }, this.interval);
      this.intervals.push(int);
    };
    this.fileExt = options.fileExt ?? "webp";
    this.interval = 1e3 / options.fps;
  }
  startTracking() {
    setTimeout(() => {
      this.app.nodes.scanTree(this.captureCanvas);
      this.app.nodes.attachNodeCallback((node) => {
        this.captureCanvas(node);
      });
    }, 500);
  }
  sendSnaps(images, canvasId, createdAt) {
    if (Object.keys(this.snapshots).length === 0) {
      return;
    }
    const formData = new FormData();
    images.forEach((snapshot) => {
      const blob = snapshot.data;
      if (!blob)
        return;
      formData.append("snapshot", blob, `${createdAt}_${canvasId}_${snapshot.id}.${this.fileExt}`);
      if (this.options.isDebug) {
        saveImageData(blob, `${createdAt}_${canvasId}_${snapshot.id}.${this.fileExt}`);
      }
    });
    fetch(this.app.options.ingestPoint + "/v1/web/images", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.app.session.getSessionToken() ?? ""}`
      },
      body: formData
    }).then(() => {
      return true;
    }).catch((e) => {
      this.app.debug.error("error saving canvas", e);
    });
  }
  clear() {
    this.intervals.forEach((int) => clearInterval(int));
    this.snapshots = {};
  }
};
var qualityInt = {
  low: 0.35,
  medium: 0.55,
  high: 0.8
};
function captureSnapshot(canvas, quality = "medium", dummy, fixedScaling = false, fileExt, onBlob) {
  const imageFormat = `image/${fileExt}`;
  if (fixedScaling) {
    const canvasScaleRatio = window.devicePixelRatio || 1;
    dummy.width = canvas.width / canvasScaleRatio;
    dummy.height = canvas.height / canvasScaleRatio;
    const ctx = dummy.getContext("2d");
    if (!ctx) {
      return "";
    }
    ctx.clearRect(0, 0, dummy.width, dummy.height);
    ctx.drawImage(canvas, 0, 0, dummy.width, dummy.height);
    dummy.toBlob(onBlob, imageFormat, qualityInt[quality]);
  } else {
    canvas.toBlob(onBlob, imageFormat, qualityInt[quality]);
  }
}
function saveImageData(imageDataBlob, name) {
  const imageDataUrl = URL.createObjectURL(imageDataBlob);
  const link = document.createElement("a");
  link.href = imageDataUrl;
  link.download = name;
  link.style.display = "none";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
var canvas_default = CanvasRecorder;

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/logger.js
var LogLevel = {
  Verbose: 5,
  Log: 4,
  Warnings: 3,
  Errors: 2,
  Silent: 0
};
var Logger = class {
  constructor(debugLevel = LogLevel.Silent) {
    this.shouldLog = (level) => {
      return this.level >= level;
    };
    this.log = (...args) => {
      if (this.shouldLog(LogLevel.Log)) {
        console.log(...args);
      }
    };
    this.warn = (...args) => {
      if (this.shouldLog(LogLevel.Warnings)) {
        console.warn(...args);
      }
    };
    this.error = (...args) => {
      if (this.shouldLog(LogLevel.Errors)) {
        console.error(...args);
      }
    };
    this.level = debugLevel;
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/nodes.js
var Nodes = class {
  constructor(node_id) {
    this.node_id = node_id;
    this.nodes = [];
    this.totalNodeAmount = 0;
    this.nodeCallbacks = [];
    this.elementListeners = /* @__PURE__ */ new Map();
    this.nextNodeId = 0;
    this.scanTree = (cb) => {
      this.nodes.forEach((node) => cb(node));
    };
  }
  syntheticMode(frameOrder) {
    const maxSafeNumber = 9007199254740900;
    const placeholderSize = 99999999;
    const nextFrameId = placeholderSize * frameOrder;
    if (nextFrameId > maxSafeNumber) {
      throw new Error("Placeholder id overflow");
    }
    this.nextNodeId = nextFrameId;
  }
  // Attached once per Tracker instance
  attachNodeCallback(nodeCallback) {
    this.nodeCallbacks.push(nodeCallback);
  }
  attachNodeListener(node, type, listener, useCapture = true) {
    const id2 = this.getID(node);
    if (id2 === void 0) {
      return;
    }
    createEventListener(node, type, listener, useCapture);
    let listeners = this.elementListeners.get(id2);
    if (listeners === void 0) {
      listeners = [];
      this.elementListeners.set(id2, listeners);
    }
    listeners.push([type, listener, useCapture]);
  }
  registerNode(node) {
    let id2 = node[this.node_id];
    const isNew = id2 === void 0;
    if (isNew) {
      id2 = this.nextNodeId;
      this.totalNodeAmount++;
      this.nextNodeId++;
      this.nodes[id2] = node;
      node[this.node_id] = id2;
    }
    return [id2, isNew];
  }
  unregisterNode(node) {
    const id2 = node[this.node_id];
    if (id2 !== void 0) {
      ;
      node[this.node_id] = void 0;
      delete node[this.node_id];
      delete this.nodes[id2];
      const listeners = this.elementListeners.get(id2);
      if (listeners !== void 0) {
        this.elementListeners.delete(id2);
        listeners.forEach((listener) => deleteEventListener(node, listener[0], listener[1], listener[2]));
      }
      this.totalNodeAmount--;
    }
    return id2;
  }
  cleanTree() {
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      if (node && !document.contains(node)) {
        this.unregisterNode(node);
      }
    }
  }
  callNodeCallbacks(node, isStart) {
    this.nodeCallbacks.forEach((cb) => cb(node, isStart));
  }
  getID(node) {
    if (!node)
      return void 0;
    return node[this.node_id];
  }
  getNode(id2) {
    return this.nodes[id2];
  }
  getNodeCount() {
    return this.totalNodeAmount;
  }
  clear() {
    for (let id2 = 0; id2 < this.nodes.length; id2++) {
      const node = this.nodes[id2];
      if (!node) {
        continue;
      }
      this.unregisterNode(node);
    }
    this.nextNodeId = 0;
    this.nodes.length = 0;
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/observer/observer.js
function isIgnored(node) {
  if (isCommentNode(node)) {
    return true;
  }
  if (isTextNode(node)) {
    return false;
  }
  if (!isElementNode(node)) {
    return true;
  }
  const tag = node.tagName.toUpperCase();
  if (tag === "LINK") {
    const rel = node.getAttribute("rel");
    const as = node.getAttribute("as");
    return !((rel == null ? void 0 : rel.includes("stylesheet")) || as === "style" || as === "font");
  }
  return tag === "SCRIPT" || tag === "NOSCRIPT" || tag === "META" || tag === "TITLE" || tag === "BASE";
}
function isObservable(node) {
  if (isRootNode(node)) {
    return true;
  }
  return !isIgnored(node);
}
var RecentsType;
(function(RecentsType2) {
  RecentsType2[RecentsType2["New"] = 0] = "New";
  RecentsType2[RecentsType2["Removed"] = 1] = "Removed";
  RecentsType2[RecentsType2["Changed"] = 2] = "Changed";
})(RecentsType || (RecentsType = {}));
var Observer = class {
  constructor(app, isTopContext = false) {
    this.app = app;
    this.isTopContext = isTopContext;
    this.commited = [];
    this.recents = /* @__PURE__ */ new Map();
    this.indexes = [];
    this.attributesMap = /* @__PURE__ */ new Map();
    this.textSet = /* @__PURE__ */ new Set();
    this.observer = createMutationObserver(this.app.safe((mutations) => {
      for (const mutation of mutations) {
        const target = mutation.target;
        const type = mutation.type;
        if (!isObservable(target)) {
          continue;
        }
        if (type === "childList") {
          for (let i = 0; i < mutation.removedNodes.length; i++) {
            if (isObservable(mutation.removedNodes[i])) {
              this.bindNode(mutation.removedNodes[i]);
            }
          }
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            this.bindTree(mutation.addedNodes[i]);
          }
          continue;
        }
        const id2 = this.app.nodes.getID(target);
        if (id2 === void 0) {
          continue;
        }
        if (!this.recents.has(id2)) {
          this.recents.set(id2, RecentsType.Changed);
        }
        if (type === "attributes") {
          const name = mutation.attributeName;
          if (name === null) {
            continue;
          }
          let attr2 = this.attributesMap.get(id2);
          if (attr2 === void 0) {
            this.attributesMap.set(id2, attr2 = /* @__PURE__ */ new Set());
          }
          attr2.add(name);
          continue;
        }
        if (type === "characterData") {
          this.textSet.add(id2);
          continue;
        }
      }
      this.commitNodes();
    }));
  }
  clear() {
    this.commited.length = 0;
    this.recents.clear();
    this.indexes.length = 1;
    this.attributesMap.clear();
    this.textSet.clear();
  }
  sendNodeAttribute(id2, node, name, value) {
    if (isSVGElement(node)) {
      if (name.substr(0, 6) === "xlink:") {
        name = name.substr(6);
      }
      if (value === null) {
        this.app.send(RemoveNodeAttribute(id2, name));
      } else if (name === "href") {
        if (value.length > 1e5) {
          value = "";
        }
        this.app.send(SetNodeAttributeURLBased(id2, name, value, this.app.getBaseHref()));
      } else {
        this.app.attributeSender.sendSetAttribute(id2, name, value);
      }
      return;
    }
    if (name === "src" || name === "srcset" || name === "integrity" || name === "crossorigin" || name === "autocomplete" || name.substr(0, 2) === "on") {
      return;
    }
    if (name === "value" && hasTag(node, "input") && node.type !== "button" && node.type !== "reset" && node.type !== "submit") {
      return;
    }
    if (value === null) {
      this.app.send(RemoveNodeAttribute(id2, name));
      return;
    }
    if (name === "style" || name === "href" && hasTag(node, "link")) {
      this.app.send(SetNodeAttributeURLBased(id2, name, value, this.app.getBaseHref()));
      return;
    }
    if (name === "href" || value.length > 1e5) {
      value = "";
    }
    this.app.attributeSender.sendSetAttribute(id2, name, value);
  }
  sendNodeData(id2, parentElement, data) {
    if (hasTag(parentElement, "style")) {
      this.app.send(SetCSSDataURLBased(id2, data, this.app.getBaseHref()));
      return;
    }
    data = this.app.sanitizer.sanitize(id2, data);
    this.app.send(SetNodeData(id2, data));
  }
  bindNode(node) {
    const [id2, isNew] = this.app.nodes.registerNode(node);
    if (isNew) {
      this.recents.set(id2, RecentsType.New);
    } else if (this.recents.get(id2) !== RecentsType.New) {
      this.recents.set(id2, RecentsType.Removed);
    }
  }
  bindTree(node) {
    if (!isObservable(node)) {
      return;
    }
    this.bindNode(node);
    const walker = document.createTreeWalker(
      node,
      NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node2) => {
          if (this.app.nodes.getID(node2) !== void 0) {
            this.app.debug.error("! Node is already bound", node2);
          }
          return isIgnored(node2) || this.app.nodes.getID(node2) !== void 0 ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
        }
      },
      // @ts-ignore
      false
    );
    while (walker.nextNode()) {
      this.bindNode(walker.currentNode);
    }
  }
  unbindTree(node) {
    const id2 = this.app.nodes.unregisterNode(node);
    if (id2 !== void 0 && this.recents.get(id2) === RecentsType.Removed) {
      this.app.send(RemoveNode(id2));
      const walker = document.createTreeWalker(
        node,
        NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT,
        {
          acceptNode: (node2) => isIgnored(node2) || this.app.nodes.getID(node2) === void 0 ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT
        },
        // @ts-ignore
        false
      );
      let removed = 0;
      const totalBeforeRemove = this.app.nodes.getNodeCount();
      while (walker.nextNode()) {
        removed += 1;
        this.app.nodes.unregisterNode(walker.currentNode);
      }
      const removedPercent = Math.floor(removed / totalBeforeRemove * 100);
      if (removedPercent > 30) {
        this.app.send(UnbindNodes(removedPercent));
      }
    }
  }
  // A top-consumption function on the infinite lists test. (~1% of performance resources)
  _commitNode(id2, node) {
    if (isRootNode(node)) {
      return true;
    }
    const parent = node.parentNode;
    let parentID;
    if (!hasTag(node, "html") || !this.isTopContext) {
      if (parent === null) {
        this.unbindTree(node);
        return false;
      }
      parentID = this.app.nodes.getID(parent);
      if (parentID === void 0) {
        this.unbindTree(node);
        return false;
      }
      if (!this.commitNode(parentID)) {
        this.unbindTree(node);
        return false;
      }
      this.app.sanitizer.handleNode(id2, parentID, node);
      if (this.app.sanitizer.isHidden(parentID)) {
        return false;
      }
    }
    let sibling = node.previousSibling;
    while (sibling !== null) {
      const siblingID = this.app.nodes.getID(sibling);
      if (siblingID !== void 0) {
        this.commitNode(siblingID);
        this.indexes[id2] = this.indexes[siblingID] + 1;
        break;
      }
      sibling = sibling.previousSibling;
    }
    if (sibling === null) {
      this.indexes[id2] = 0;
    }
    const recentsType = this.recents.get(id2);
    const isNew = recentsType === RecentsType.New;
    const index2 = this.indexes[id2];
    if (index2 === void 0) {
      throw "commitNode: missing node index";
    }
    if (isNew) {
      if (isElementNode(node)) {
        let el = node;
        if (parentID !== void 0) {
          if (this.app.sanitizer.isHidden(id2)) {
            const width = el.clientWidth;
            const height = el.clientHeight;
            el = node.cloneNode();
            el.style.width = `${width}px`;
            el.style.height = `${height}px`;
          }
          this.app.send(CreateElementNode(id2, parentID, index2, el.tagName, isSVGElement(node)));
        }
        for (let i = 0; i < el.attributes.length; i++) {
          const attr3 = el.attributes[i];
          this.sendNodeAttribute(id2, el, attr3.nodeName, attr3.value);
        }
      } else if (isTextNode(node)) {
        this.app.send(CreateTextNode(id2, parentID, index2));
        this.sendNodeData(id2, parent, node.data);
      }
      return true;
    }
    if (recentsType === RecentsType.Removed && parentID !== void 0) {
      this.app.send(MoveNode(id2, parentID, index2));
    }
    const attr2 = this.attributesMap.get(id2);
    if (attr2 !== void 0) {
      if (!isElementNode(node)) {
        throw "commitNode: node is not an element";
      }
      for (const name of attr2) {
        this.sendNodeAttribute(id2, node, name, node.getAttribute(name));
      }
    }
    if (this.textSet.has(id2)) {
      if (!isTextNode(node)) {
        throw "commitNode: node is not a text";
      }
      this.sendNodeData(id2, parent, node.data);
    }
    return true;
  }
  commitNode(id2) {
    const node = this.app.nodes.getNode(id2);
    if (node === void 0) {
      return false;
    }
    const cmt = this.commited[id2];
    if (cmt !== void 0) {
      return cmt;
    }
    return this.commited[id2] = this._commitNode(id2, node);
  }
  commitNodes(isStart = false) {
    let node;
    this.recents.forEach((type, id2) => {
      this.commitNode(id2);
      if (type === RecentsType.New && (node = this.app.nodes.getNode(id2))) {
        this.app.nodes.callNodeCallbacks(node, isStart);
      }
    });
    this.clear();
  }
  // ISSSUE (nodeToBinde should be the same as node in all cases. Look at the comment about 0-node at the beginning of the file.)
  // TODO: use one observer instance for all iframes/shadowRoots (composition instiad of inheritance)
  observeRoot(node, beforeCommit, nodeToBind = node) {
    this.observer.observe(node, {
      childList: true,
      attributes: true,
      characterData: true,
      subtree: true,
      attributeOldValue: false,
      characterDataOldValue: false
    });
    this.bindTree(nodeToBind);
    beforeCommit(this.app.nodes.getID(node));
    this.commitNodes(true);
  }
  disconnect() {
    this.observer.disconnect();
    this.clear();
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/observer/iframe_observer.js
var IFrameObserver = class extends Observer {
  observe(iframe) {
    const doc = iframe.contentDocument;
    const hostID = this.app.nodes.getID(iframe);
    if (!doc || hostID === void 0) {
      return;
    }
    this.observeRoot(doc, (docID) => {
      if (docID === void 0) {
        this.app.debug.log("OpenReplay: Iframe document not bound");
        return;
      }
      this.app.send(CreateIFrameDocument(hostID, docID));
    });
  }
  syntheticObserve(selfId, doc) {
    this.observeRoot(doc, (docID) => {
      if (docID === void 0) {
        this.app.debug.log("OpenReplay: Iframe document not bound");
        return;
      }
      this.app.send(CreateIFrameDocument(selfId, docID));
    });
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/observer/shadow_root_observer.js
var ShadowRootObserver = class extends Observer {
  observe(el) {
    const shRoot = el.shadowRoot;
    const hostID = this.app.nodes.getID(el);
    if (!shRoot || hostID === void 0) {
      return;
    }
    this.observeRoot(shRoot, (rootID) => {
      if (rootID === void 0) {
        this.app.debug.error("OpenReplay: Shadow Root was not bound");
        return;
      }
      this.app.send(CreateIFrameDocument(hostID, rootID));
    });
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/observer/iframe_offsets.js
var IFrameOffsets = class {
  constructor() {
    this.states = /* @__PURE__ */ new Map();
  }
  calcOffset(state) {
    let parLeft = 0, parTop = 0;
    if (state.parent) {
      ;
      [parLeft, parTop] = this.calcOffset(state.parent);
    }
    if (!state.offset) {
      const { left: left2, top: top2 } = state.iFrame.getBoundingClientRect();
      state.offset = [left2, top2];
    }
    const [left, top] = state.offset;
    return [parLeft + left, parTop + top];
  }
  getDocumentOffset(doc) {
    const state = this.states.get(doc);
    if (!state) {
      return [0, 0];
    }
    return this.calcOffset(state);
  }
  observe(iFrame) {
    var _a3;
    const doc = iFrame.contentDocument;
    if (!doc) {
      return;
    }
    const parentDoc = iFrame.ownerDocument;
    const parentState = this.states.get(parentDoc);
    const state = {
      offset: null,
      iFrame,
      parent: parentState || null,
      clear: () => {
        var _a4;
        parentDoc.removeEventListener("scroll", invalidateOffset);
        (_a4 = parentDoc.defaultView) == null ? void 0 : _a4.removeEventListener("resize", invalidateOffset);
      }
    };
    const invalidateOffset = () => {
      state.offset = null;
    };
    parentDoc.addEventListener("scroll", invalidateOffset);
    (_a3 = parentDoc.defaultView) == null ? void 0 : _a3.addEventListener("resize", invalidateOffset);
    this.states.set(doc, state);
  }
  clear() {
    this.states.forEach((s) => s.clear());
    this.states.clear();
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/observer/top_observer.js
var attachShadowNativeFn = IN_BROWSER ? Element.prototype.attachShadow : () => new ShadowRoot();
var TopObserver = class extends Observer {
  constructor(app, options) {
    super(app, true);
    this.iframeOffsets = new IFrameOffsets();
    this.contextCallbacks = [];
    this.contextsSet = /* @__PURE__ */ new Set();
    this.iframeObservers = [];
    this.shadowRootObservers = [];
    this.options = Object.assign({
      captureIFrames: true
    }, options);
    this.app.nodes.attachNodeCallback((node) => {
      if (hasTag(node, "iframe") && (this.options.captureIFrames && !hasOpenreplayAttribute(node, "obscured") || hasOpenreplayAttribute(node, "capture"))) {
        this.handleIframe(node);
      }
    });
    this.app.nodes.attachNodeCallback((node) => {
      if (isElementNode(node) && node.shadowRoot !== null) {
        this.handleShadowRoot(node.shadowRoot);
      }
    });
  }
  attachContextCallback(cb) {
    this.contextCallbacks.push(cb);
  }
  getDocumentOffset(doc) {
    return this.iframeOffsets.getDocumentOffset(doc);
  }
  handleIframe(iframe) {
    let doc = null;
    const handle = this.app.safe(() => setTimeout(() => {
      const id2 = this.app.nodes.getID(iframe);
      if (id2 === void 0) {
        return;
      }
      if (!canAccessIframe(iframe))
        return;
      const currentWin = iframe.contentWindow;
      const currentDoc = iframe.contentDocument;
      if (currentDoc && currentDoc !== doc) {
        const observer = new IFrameObserver(this.app);
        this.iframeObservers.push(observer);
        observer.observe(iframe);
        doc = currentDoc;
        this.iframeOffsets.observe(iframe);
      }
      if (currentWin && // Sometimes currentWin.window is null (not in specification). Such window object is not functional
      currentWin === currentWin.window && !this.contextsSet.has(currentWin)) {
        this.contextsSet.add(currentWin);
        this.contextCallbacks.forEach((cb) => cb(currentWin));
      }
    }, 100));
    iframe.addEventListener("load", handle);
    handle();
  }
  handleShadowRoot(shRoot) {
    const observer = new ShadowRootObserver(this.app);
    this.shadowRootObservers.push(observer);
    observer.observe(shRoot.host);
  }
  observe() {
    const observer = this;
    Element.prototype.attachShadow = function() {
      const shadow = attachShadowNativeFn.apply(this, arguments);
      observer.handleShadowRoot(shadow);
      return shadow;
    };
    this.app.nodes.clear();
    this.observeRoot(window.document, () => {
      this.app.send(CreateDocument());
      this.app.nodes.callNodeCallbacks(document, true);
    }, window.document.documentElement);
  }
  crossdomainObserve(selfId, frameOder) {
    const observer = this;
    Element.prototype.attachShadow = function() {
      const shadow = attachShadowNativeFn.apply(this, arguments);
      observer.handleShadowRoot(shadow);
      return shadow;
    };
    this.app.nodes.clear();
    this.app.nodes.syntheticMode(frameOder);
    const iframeObserver = new IFrameObserver(this.app);
    this.iframeObservers.push(iframeObserver);
    iframeObserver.syntheticObserve(selfId, window.document);
  }
  disconnect() {
    this.iframeOffsets.clear();
    Element.prototype.attachShadow = attachShadowNativeFn;
    this.iframeObservers.forEach((o) => o.disconnect());
    this.iframeObservers = [];
    this.shadowRootObservers.forEach((o) => o.disconnect());
    this.shadowRootObservers = [];
    super.disconnect();
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/sanitizer.js
var SanitizeLevel;
(function(SanitizeLevel2) {
  SanitizeLevel2[SanitizeLevel2["Plain"] = 0] = "Plain";
  SanitizeLevel2[SanitizeLevel2["Obscured"] = 1] = "Obscured";
  SanitizeLevel2[SanitizeLevel2["Hidden"] = 2] = "Hidden";
})(SanitizeLevel || (SanitizeLevel = {}));
var stringWiper = (input) => input.trim().replace(/[^\f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/g, "█");
var Sanitizer = class {
  constructor(app, options) {
    this.app = app;
    this.obscured = /* @__PURE__ */ new Set();
    this.hidden = /* @__PURE__ */ new Set();
    this.options = Object.assign({
      obscureTextEmails: true,
      obscureTextNumbers: false
    }, options);
  }
  handleNode(id2, parentID, node) {
    if (this.obscured.has(parentID) || isElementNode(node) && (hasOpenreplayAttribute(node, "masked") || hasOpenreplayAttribute(node, "obscured"))) {
      this.obscured.add(id2);
    }
    if (this.hidden.has(parentID) || isElementNode(node) && (hasOpenreplayAttribute(node, "htmlmasked") || hasOpenreplayAttribute(node, "hidden"))) {
      this.hidden.add(id2);
    }
    if (this.options.domSanitizer !== void 0 && isElementNode(node)) {
      const sanitizeLevel = this.options.domSanitizer(node);
      if (sanitizeLevel === SanitizeLevel.Obscured) {
        this.obscured.add(id2);
      }
      if (sanitizeLevel === SanitizeLevel.Hidden) {
        this.hidden.add(id2);
      }
    }
  }
  sanitize(id2, data) {
    if (this.obscured.has(id2)) {
      return stringWiper(data);
    }
    if (this.options.obscureTextNumbers) {
      data = data.replace(/\d/g, "0");
    }
    if (this.options.obscureTextEmails) {
      data = data.replace(/^\w+([+.-]\w+)*@\w+([.-]\w+)*\.\w{2,3}$/g, (email) => {
        const [name, domain] = email.split("@");
        const [domainName, host] = domain.split(".");
        return `${stars(name)}@${stars(domainName)}.${stars(host)}`;
      });
    }
    return data;
  }
  isObscured(id2) {
    return this.obscured.has(id2);
  }
  isHidden(id2) {
    return this.hidden.has(id2);
  }
  getInnerTextSecure(el) {
    const id2 = this.app.nodes.getID(el);
    if (!id2) {
      return "";
    }
    return this.sanitize(id2, el.innerText);
  }
  clear() {
    this.obscured.clear();
    this.hidden.clear();
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/session.js
var Session = class {
  constructor(app, options) {
    this.app = app;
    this.options = options;
    this.metadata = {};
    this.userID = null;
    this.callbacks = [];
    this.timestamp = 0;
    this.createTabId();
  }
  attachUpdateCallback(cb) {
    this.callbacks.push(cb);
  }
  handleUpdate(newInfo) {
    if (newInfo.userID == null) {
      delete newInfo.userID;
    }
    if (newInfo.sessionID == null) {
      delete newInfo.sessionID;
    }
    this.callbacks.forEach((cb) => cb(newInfo));
  }
  assign(newInfo) {
    if (newInfo.userID !== void 0) {
      this.userID = newInfo.userID;
    }
    if (newInfo.metadata !== void 0) {
      Object.entries(newInfo.metadata).forEach(([k, v]) => this.metadata[k] = v);
    }
    if (newInfo.sessionID !== void 0) {
      this.sessionID = newInfo.sessionID;
    }
    if (newInfo.timestamp !== void 0) {
      this.timestamp = newInfo.timestamp;
    }
    if (newInfo.projectID !== void 0) {
      this.projectID = newInfo.projectID;
    }
    this.handleUpdate(newInfo);
  }
  setMetadata(key, value) {
    this.metadata[key] = value;
    this.handleUpdate({ metadata: { [key]: value } });
  }
  setUserID(userID) {
    this.userID = userID;
    this.handleUpdate({ userID });
  }
  setUserInfo(userInfo) {
    this.userInfo = userInfo;
  }
  getPageNumber() {
    const pageNoStr = this.app.sessionStorage.getItem(this.options.session_pageno_key);
    if (pageNoStr == null) {
      return void 0;
    }
    return parseInt(pageNoStr);
  }
  incPageNo() {
    let pageNo = this.getPageNumber();
    if (pageNo === void 0) {
      pageNo = 0;
    } else {
      pageNo++;
    }
    this.app.sessionStorage.setItem(this.options.session_pageno_key, pageNo.toString());
    return pageNo;
  }
  getSessionToken() {
    return this.app.sessionStorage.getItem(this.options.session_token_key) || void 0;
  }
  setSessionToken(token) {
    this.app.sessionStorage.setItem(this.options.session_token_key, token);
  }
  applySessionHash(hash) {
    const hashParts = decodeURI(hash).split("&");
    let token = hash;
    let pageNoStr = "100500";
    if (hashParts.length == 2) {
      ;
      [pageNoStr, token] = hashParts;
    }
    if (!pageNoStr || !token) {
      return;
    }
    this.app.sessionStorage.setItem(this.options.session_token_key, token);
    this.app.sessionStorage.setItem(this.options.session_pageno_key, pageNoStr);
  }
  getSessionHash() {
    const pageNo = this.getPageNumber();
    const token = this.getSessionToken();
    if (pageNo === void 0 || token === void 0) {
      return;
    }
    return encodeURI(String(pageNo) + "&" + token);
  }
  getTabId() {
    if (!this.tabId)
      this.createTabId();
    return this.tabId;
  }
  regenerateTabId() {
    const randomId = generateRandomId(12);
    this.app.sessionStorage.setItem(this.options.session_tabid_key, randomId);
    this.tabId = randomId;
  }
  createTabId() {
    const localId = this.app.sessionStorage.getItem(this.options.session_tabid_key);
    if (localId) {
      this.tabId = localId;
    } else {
      this.regenerateTabId();
    }
  }
  getInfo() {
    return {
      sessionID: this.sessionID,
      metadata: this.metadata,
      userID: this.userID,
      timestamp: this.timestamp,
      projectID: this.projectID
    };
  }
  reset() {
    this.app.sessionStorage.removeItem(this.options.session_token_key);
    this.metadata = {};
    this.userID = null;
    this.sessionID = void 0;
    this.timestamp = 0;
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/ticker.js
function wrap(callback, n) {
  let t = 0;
  return () => {
    if (t++ >= n) {
      t = 0;
      callback();
    }
  };
}
var Ticker = class {
  constructor(app) {
    this.app = app;
    this.timer = null;
    this.callbacks = [];
  }
  /**
   * @param {Callback} callback - repeated cb
   * @param {number} n - number of turn skips; ticker have a 30 ms cycle
   * @param {boolean} useSafe - using safe wrapper to check if app is active
   * @param {object} thisArg - link to <this>
   * */
  attach(callback, n = 0, useSafe = true, thisArg) {
    if (thisArg) {
      callback = callback.bind(thisArg);
    }
    if (useSafe) {
      callback = this.app.safe(callback);
    }
    this.callbacks.unshift(n ? wrap(callback, n) : callback) - 1;
  }
  start() {
    if (this.timer === null) {
      this.timer = setInterval(() => this.callbacks.forEach((cb) => {
        if (cb)
          cb();
      }), 30);
    }
  }
  stop() {
    if (this.timer !== null) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/app/index.js
var CANCELED = "canceled";
var uxtStorageKey = "or_uxt_active";
var bufferStorageKey = "or_buffer_1";
var UnsuccessfulStart = (reason) => ({ reason, success: false });
var SuccessfulStart = (body) => ({ ...body, success: true });
var ActivityState;
(function(ActivityState2) {
  ActivityState2[ActivityState2["NotActive"] = 0] = "NotActive";
  ActivityState2[ActivityState2["Starting"] = 1] = "Starting";
  ActivityState2[ActivityState2["Active"] = 2] = "Active";
  ActivityState2[ActivityState2["ColdStart"] = 3] = "ColdStart";
})(ActivityState || (ActivityState = {}));
var DEFAULT_INGEST_POINT = "https://api.openreplay.com/ingest";
function getTimezone() {
  const offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * -1;
  const sign = offset >= 0 ? "+" : "-";
  const hours = Math.floor(Math.abs(offset) / 60);
  const minutes = Math.abs(offset) % 60;
  return `UTC${sign}${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}`;
}
var delay = (ms) => new Promise((res) => setTimeout(res, ms));
var proto = {
  // ask if there are any tabs alive
  ask: "never-gonna-give-you-up",
  // response from another tab
  resp: "never-gonna-let-you-down",
  // regenerating id (copied other tab)
  reg: "never-gonna-run-around-and-desert-you",
  // tracker inside a child iframe
  iframeSignal: "never-gonna-make-you-cry",
  // getting node id for child iframe
  iframeId: "never-gonna-say-goodbye",
  // batch of messages from an iframe window
  iframeBatch: "never-gonna-tell-a-lie-and-hurt-you"
};
var App = class {
  constructor(projectKey, sessionToken, options, signalError, insideIframe) {
    this.signalError = signalError;
    this.insideIframe = insideIframe;
    this.messages = [];
    this.bufferedMessages1 = [];
    this.bufferedMessages2 = [];
    this.startCallbacks = [];
    this.stopCallbacks = [];
    this.commitCallbacks = [];
    this.activityState = ActivityState.NotActive;
    this.version = "14.0.3";
    this.socketMode = false;
    this.compressionThreshold = 24 * 1e3;
    this.bc = null;
    this.canvasRecorder = null;
    this.conditionsManager = null;
    this.canStart = false;
    this.rootId = null;
    this.pageFrames = [];
    this.frameOderNumber = 0;
    this.initialHostName = location.hostname;
    this.startTimeout = null;
    this.coldStartCommitN = 0;
    this.delay = 0;
    this.coldInterval = null;
    this.orderNumber = 0;
    this.coldStartTs = 0;
    this.singleBuffer = false;
    this.onSessionSent = () => {
      return;
    };
    this.restartCanvasTracking = () => {
      var _a3;
      (_a3 = this.canvasRecorder) == null ? void 0 : _a3.restartTracking();
    };
    this.flushBuffer = async (buffer) => {
      return new Promise((res) => {
        let ended = false;
        const messagesBatch = [buffer.shift()];
        while (!ended) {
          const nextMsg = buffer[0];
          if (!nextMsg || nextMsg[0] === 0) {
            ended = true;
          } else {
            messagesBatch.push(buffer.shift());
          }
        }
        this.postToWorker(messagesBatch);
        res(null);
      });
    };
    this.onUxtCb = [];
    this.contextId = Math.random().toString(36).slice(2);
    this.projectKey = projectKey;
    if (Object.keys(options).findIndex((k) => ["fixedCanvasScaling", "disableCanvas"].includes(k)) !== -1) {
      console.warn('Openreplay: canvas options are moving to separate key "canvas" in next update. Please update your configuration.');
      options = {
        ...options,
        canvas: {
          __save_canvas_locally: options.__save_canvas_locally,
          fixedCanvasScaling: options.fixedCanvasScaling,
          disableCanvas: options.disableCanvas
        }
      };
    }
    this.networkOptions = options.network;
    const defaultOptions = {
      revID: "",
      node_id: "__openreplay_id",
      session_token_key: "__openreplay_token",
      session_pageno_key: "__openreplay_pageno",
      session_reset_key: "__openreplay_reset",
      session_tabid_key: "__openreplay_tabid",
      local_uuid_key: "__openreplay_uuid",
      ingestPoint: DEFAULT_INGEST_POINT,
      resourceBaseHref: null,
      __is_snippet: false,
      __debug_report_edp: null,
      __debug__: LogLevel.Silent,
      __save_canvas_locally: false,
      localStorage: null,
      sessionStorage: null,
      disableStringDict: false,
      forceSingleTab: false,
      assistSocketHost: "",
      fixedCanvasScaling: false,
      disableCanvas: false,
      captureIFrames: true,
      obscureTextEmails: true,
      obscureTextNumbers: false,
      crossdomain: {
        parentDomain: "*"
      },
      canvas: {
        disableCanvas: false,
        fixedCanvasScaling: false,
        __save_canvas_locally: false,
        useAnimationFrame: false
      }
    };
    this.options = simpleMerge(defaultOptions, options);
    if (!this.insideIframe && !this.options.forceSingleTab && globalThis && "BroadcastChannel" in globalThis) {
      const host = location.hostname.split(".").slice(-2).join("_");
      this.bc = new BroadcastChannel(`rick_${host}`);
    }
    this.revID = this.options.revID;
    this.localStorage = this.options.localStorage ?? window.localStorage;
    this.sessionStorage = this.options.sessionStorage ?? window.sessionStorage;
    this.sanitizer = new Sanitizer(this, options);
    this.nodes = new Nodes(this.options.node_id);
    this.observer = new TopObserver(this, options);
    this.ticker = new Ticker(this);
    this.ticker.attach(() => this.commit());
    this.debug = new Logger(this.options.__debug__);
    this.session = new Session(this, this.options);
    this.attributeSender = new AttributeSender(this, Boolean(this.options.disableStringDict));
    this.featureFlags = new FeatureFlags(this);
    this.tagWatcher = new tagWatcher_default(this.sessionStorage, this.debug.error, (tag) => {
      this.send(TagTrigger(tag));
    });
    this.session.attachUpdateCallback(({ userID, metadata }) => {
      if (userID != null) {
        this.send(UserID(userID));
      }
      if (metadata != null) {
        Object.entries(metadata).forEach(([key, value]) => this.send(Metadata(key, value)));
      }
    });
    if (sessionToken != null) {
      this.session.applySessionHash(sessionToken);
    }
    this.initWorker();
    const thisTab = this.session.getTabId();
    if (!this.insideIframe) {
      let crossdomainFrameCount = 0;
      const catchIframeMessage = (event) => {
        const { data } = event;
        if (data.line === proto.iframeSignal) {
          const childIframeDomain = data.domain;
          const pageIframes = Array.from(document.querySelectorAll("iframe"));
          this.pageFrames = pageIframes;
          const signalId = async () => {
            let tries = 0;
            while (tries < 10) {
              const id2 = this.checkNodeId(pageIframes, childIframeDomain);
              if (id2) {
                this.waitStarted().then(() => {
                  var _a3;
                  crossdomainFrameCount++;
                  const token = this.session.getSessionToken();
                  const iframeData = {
                    line: proto.iframeId,
                    context: this.contextId,
                    domain: childIframeDomain,
                    id: id2,
                    token,
                    frameOrderNumber: crossdomainFrameCount
                  };
                  this.debug.log("iframe_data", iframeData);
                  (_a3 = event.source) == null ? void 0 : _a3.postMessage(iframeData, "*");
                }).catch(console.error);
                tries = 10;
                break;
              }
              tries++;
              await delay(100);
            }
          };
          void signalId();
        }
        if (data.line === proto.iframeBatch) {
          const msgBatch = data.messages;
          const mappedMessages = msgBatch.map((msg) => {
            if (msg[0] === 20) {
              let fixedMessage = msg;
              this.pageFrames.forEach((frame) => {
                if (frame.dataset.domain === event.data.domain) {
                  const [type, x, y] = msg;
                  const { left, top } = frame.getBoundingClientRect();
                  fixedMessage = [type, x + left, y + top];
                }
              });
              return fixedMessage;
            }
            if (msg[0] === 68) {
              let fixedMessage = msg;
              this.pageFrames.forEach((frame) => {
                if (frame.dataset.domain === event.data.domain) {
                  const [type, id2, hesitationTime, label, selector2, normX, normY] = msg;
                  const { left, top, width, height } = frame.getBoundingClientRect();
                  const contentWidth = document.documentElement.scrollWidth;
                  const contentHeight = document.documentElement.scrollHeight;
                  const fullX = normX / 100 * width + left;
                  const fullY = normY / 100 * height + top;
                  const fixedX = fullX / contentWidth;
                  const fixedY = fullY / contentHeight;
                  fixedMessage = [
                    type,
                    id2,
                    hesitationTime,
                    label,
                    selector2,
                    Math.round(fixedX * 1e3) / 10,
                    Math.round(fixedY * 1e3) / 10
                  ];
                }
              });
              return fixedMessage;
            }
            return msg;
          });
          this.messages.push(...mappedMessages);
        }
      };
      window.addEventListener("message", catchIframeMessage);
      this.attachStopCallback(() => {
        window.removeEventListener("message", catchIframeMessage);
      });
    } else {
      const catchParentMessage = (event) => {
        const { data } = event;
        if (data.line !== proto.iframeId) {
          return;
        }
        this.rootId = data.id;
        this.session.setSessionToken(data.token);
        this.frameOderNumber = data.frameOrderNumber;
        this.debug.log("starting iframe tracking", data);
        this.allowAppStart();
      };
      window.addEventListener("message", catchParentMessage);
      this.attachStopCallback(() => {
        window.removeEventListener("message", catchParentMessage);
      });
      const domain = this.initialHostName;
      window.parent.postMessage({
        line: proto.iframeSignal,
        source: thisTab,
        context: this.contextId,
        domain
      }, "*");
    }
    if (this.bc !== null) {
      this.bc.postMessage({
        line: proto.ask,
        source: thisTab,
        context: this.contextId
      });
      this.startTimeout = setTimeout(() => {
        this.allowAppStart();
      }, 500);
      this.bc.onmessage = (ev) => {
        if (ev.data.context === this.contextId) {
          return;
        }
        if (ev.data.line === proto.resp) {
          const sessionToken2 = ev.data.token;
          this.session.setSessionToken(sessionToken2);
          this.allowAppStart();
        }
        if (ev.data.line === proto.reg) {
          const sessionToken2 = ev.data.token;
          this.session.regenerateTabId();
          this.session.setSessionToken(sessionToken2);
          this.allowAppStart();
        }
        if (ev.data.line === proto.ask) {
          const token = this.session.getSessionToken();
          if (token && this.bc) {
            this.bc.postMessage({
              line: ev.data.source === thisTab ? proto.reg : proto.resp,
              token,
              source: thisTab,
              context: this.contextId
            });
          }
        }
      };
    }
  }
  allowAppStart() {
    this.canStart = true;
    if (this.startTimeout) {
      clearTimeout(this.startTimeout);
      this.startTimeout = null;
    }
  }
  checkNodeId(iframes, domain) {
    for (const iframe of iframes) {
      if (iframe.dataset.domain === domain) {
        return iframe[this.options.node_id];
      }
    }
    return null;
  }
  initWorker() {
    try {
      this.worker = new Worker(URL.createObjectURL(new Blob(['"use strict";class t{constructor(t,s,i,e=10,n=250,h,r){this.onUnauthorised=s,this.onFailure=i,this.MAX_ATTEMPTS_COUNT=e,this.ATTEMPT_TIMEOUT=n,this.onCompress=h,this.pageNo=r,this.attemptsCount=0,this.busy=!1,this.queue=[],this.token=null,this.lastBatchNum=0,this.ingestURL=t+"/v1/web/i",this.isCompressing=void 0!==h}getQueueStatus(){return 0===this.queue.length&&!this.busy}authorise(t){this.token=t,this.busy||this.sendNext()}push(t){if(this.busy||!this.token)this.queue.push(t);else if(this.busy=!0,this.isCompressing&&this.onCompress)this.onCompress(t);else{const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}}sendNext(){const t=this.queue.shift();if(t)if(this.busy=!0,this.isCompressing&&this.onCompress)this.onCompress(t);else{const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}else this.busy=!1}retry(t,s,i){this.attemptsCount>=this.MAX_ATTEMPTS_COUNT?this.onFailure(`Failed to send batch after ${this.attemptsCount} attempts.`):(this.attemptsCount++,setTimeout((()=>this.sendBatch(t,s,i)),this.ATTEMPT_TIMEOUT*this.attemptsCount))}sendBatch(t,s,i){const e=i?.toString().replace(/^([^_]+)_([^_]+).*/,"$1_$2_$3");this.busy=!0;const n={Authorization:`Bearer ${this.token}`};s&&(n["Content-Encoding"]="gzip"),null!==this.token?fetch(`${this.ingestURL}?batch=${this.pageNo??"noPageNum"}_${e??"noBatchNum"}`,{body:t,method:"POST",headers:n,keepalive:t.length<65536}).then((e=>{if(401===e.status)return this.busy=!1,void this.onUnauthorised();e.status>=400?this.retry(t,s,`${i??"noBatchNum"}_network:${e.status}`):(this.attemptsCount=0,this.sendNext())})).catch((e=>{console.warn("OpenReplay:",e),this.retry(t,s,`${i??"noBatchNum"}_reject:${e.message}`)})):setTimeout((()=>{this.sendBatch(t,s,`${i??"noBatchNum"}_newToken`)}),500)}sendCompressed(t){const s=++this.lastBatchNum;this.sendBatch(t,!0,s)}sendUncompressed(t){const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}clean(){this.sendNext(),setTimeout((()=>{this.token=null,this.queue.length=0}),10)}}const s="function"==typeof TextEncoder?new TextEncoder:{encode(t){const s=t.length,i=new Uint8Array(3*s);let e=-1;for(let n=0,h=0,r=0;r!==s;){if(n=t.charCodeAt(r),r+=1,n>=55296&&n<=56319){if(r===s){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;break}if(h=t.charCodeAt(r),!(h>=56320&&h<=57343)){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;continue}if(n=1024*(n-55296)+h-56320+65536,r+=1,n>65535){i[e+=1]=240|n>>>18,i[e+=1]=128|n>>>12&63,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n;continue}}n<=127?i[e+=1]=0|n:n<=2047?(i[e+=1]=192|n>>>6,i[e+=1]=128|63&n):(i[e+=1]=224|n>>>12,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n)}return i.subarray(0,e+1)}};class i{constructor(t){this.size=t,this.offset=0,this.checkpointOffset=0,this.data=new Uint8Array(t)}getCurrentOffset(){return this.offset}checkpoint(){this.checkpointOffset=this.offset}get isEmpty(){return 0===this.offset}skip(t){return this.offset+=t,this.offset<=this.size}set(t,s){this.data.set(t,s)}boolean(t){return this.data[this.offset++]=+t,this.offset<=this.size}uint(t){for((t<0||t>Number.MAX_SAFE_INTEGER)&&(t=0);t>=128;)this.data[this.offset++]=t%256|128,t=Math.floor(t/128);return this.data[this.offset++]=t,this.offset<=this.size}int(t){return t=Math.round(t),this.uint(t>=0?2*t:-2*t-1)}string(t){const i=s.encode(t),e=i.byteLength;return!(!this.uint(e)||this.offset+e>this.size)&&(this.data.set(i,this.offset),this.offset+=e,!0)}reset(){this.offset=0,this.checkpointOffset=0}flush(){const t=this.data.slice(0,this.checkpointOffset);return this.reset(),t}}class e extends i{encode(t){switch(t[0]){case 0:case 11:case 114:case 115:return this.uint(t[1]);case 4:case 44:case 47:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3]);case 5:case 20:case 38:case 70:case 75:case 76:case 77:case 82:return this.uint(t[1])&&this.uint(t[2]);case 6:return this.int(t[1])&&this.int(t[2]);case 7:return!0;case 8:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.string(t[4])&&this.boolean(t[5]);case 9:case 10:case 24:case 51:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3]);case 12:case 61:case 71:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3]);case 13:case 14:case 17:case 50:case 54:return this.uint(t[1])&&this.string(t[2]);case 16:return this.uint(t[1])&&this.int(t[2])&&this.int(t[3]);case 18:return this.uint(t[1])&&this.string(t[2])&&this.int(t[3]);case 19:return this.uint(t[1])&&this.boolean(t[2]);case 21:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8]);case 22:case 27:case 30:case 41:case 45:case 46:case 63:case 64:case 79:return this.string(t[1])&&this.string(t[2]);case 23:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 28:case 29:case 42:case 117:case 118:return this.string(t[1]);case 37:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3]);case 39:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7]);case 40:return this.string(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 48:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.int(t[5]);case 49:return this.int(t[1])&&this.int(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 53:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8]);case 55:return this.boolean(t[1]);case 57:case 60:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 58:case 120:return this.int(t[1]);case 59:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6])&&this.string(t[7]);case 67:case 73:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 68:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6]);case 69:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 78:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 81:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.int(t[4])&&this.string(t[5]);case 83:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 84:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6]);case 112:return this.uint(t[1])&&this.string(t[2])&&this.boolean(t[3])&&this.string(t[4])&&this.int(t[5])&&this.int(t[6]);case 113:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3]);case 116:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8])&&this.uint(t[9])&&this.boolean(t[10]);case 119:return this.string(t[1])&&this.uint(t[2]);case 121:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 122:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 123:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])}}}class n{constructor(t,s,i,n,h,r){this.pageNo=t,this.timestamp=s,this.url=i,this.onBatch=n,this.tabId=h,this.onOfflineEnd=r,this.nextIndex=0,this.beaconSize=2e5,this.encoder=new e(this.beaconSize),this.sizeBuffer=new Uint8Array(3),this.isEmpty=!0,this.beaconSizeLimit=1e6,this.prepare()}writeType(t){return this.encoder.uint(t[0])}writeFields(t){return this.encoder.encode(t)}writeSizeAt(t,s){for(let s=0;s<3;s++)this.sizeBuffer[s]=t>>8*s;this.encoder.set(this.sizeBuffer,s)}prepare(){if(!this.encoder.isEmpty)return;const t=[81,1,this.pageNo,this.nextIndex,this.timestamp,this.url],s=[118,this.tabId];this.writeType(t),this.writeFields(t),this.writeWithSize(s),this.isEmpty=!0}writeWithSize(t){const s=this.encoder;if(!this.writeType(t)||!s.skip(3))return!1;const i=s.getCurrentOffset(),e=this.writeFields(t);if(e){const e=s.getCurrentOffset()-i;if(e>16777215)return console.warn("OpenReplay: max message size overflow."),!1;this.writeSizeAt(e,i-3),s.checkpoint(),this.isEmpty=this.isEmpty&&0===t[0],this.nextIndex++}return e}setBeaconSizeLimit(t){this.beaconSizeLimit=t}writeMessage(t){if("q_end"===t[0])return this.finaliseBatch(),this.onOfflineEnd();0===t[0]&&(this.timestamp=t[1]),122===t[0]&&(this.url=t[1]),this.writeWithSize(t)||(this.finaliseBatch(),this.writeWithSize(t)||(this.encoder=new e(this.beaconSizeLimit),this.prepare(),this.writeWithSize(t)?this.finaliseBatch():console.warn("OpenReplay: beacon size overflow. Skipping large message.",t,this),this.encoder=new e(this.beaconSize),this.prepare()))}finaliseBatch(){if(this.isEmpty)return;const t=this.encoder.flush();this.onBatch(t),this.prepare()}clean(){this.encoder.reset()}}var h;!function(t){t[t.NotActive=0]="NotActive",t[t.Starting=1]="Starting",t[t.Stopping=2]="Stopping",t[t.Active=3]="Active",t[t.Stopped=4]="Stopped"}(h||(h={}));let r=null,a=null,u=h.NotActive;function o(){a&&a.finaliseBatch()}function c(){return new Promise((t=>{u=h.Stopping,null!==l&&(clearInterval(l),l=null),a&&(a.clean(),a=null),r&&(r.clean(),setTimeout((()=>{r=null}),20)),setTimeout((()=>{u=h.NotActive,t(null)}),100)}))}function g(){u!==h.Stopped&&(postMessage("a_stop"),c().then((()=>{postMessage("a_start")})))}let p,l=null;self.onmessage=({data:s})=>{if(null!=s){if("stop"===s)return o(),void c().then((()=>{u=h.Stopped}));if("forceFlushBatch"!==s){if(!Array.isArray(s)){if("compressed"===s.type){if(!r)return console.debug("OR WebWorker: sender not initialised. Compressed batch."),void g();s.batch&&r.sendCompressed(s.batch)}if("uncompressed"===s.type){if(!r)return console.debug("OR WebWorker: sender not initialised. Uncompressed batch."),void g();s.batch&&r.sendUncompressed(s.batch)}return"start"===s.type?(u=h.Starting,r=new t(s.ingestPoint,(()=>{g()}),(t=>{!function(t){postMessage({type:"failure",reason:t}),c()}(t)}),s.connAttemptCount,s.connAttemptGap,(t=>{postMessage({type:"compress",batch:t},[t.buffer])}),s.pageNo),a=new n(s.pageNo,s.timestamp,s.url,(t=>{r&&r.push(t)}),s.tabId,(()=>postMessage({type:"queue_empty"}))),null===l&&(l=setInterval(o,1e4)),u=h.Active):"auth"===s.type?r?a?(r.authorise(s.token),void(s.beaconSizeLimit&&a.setBeaconSizeLimit(s.beaconSizeLimit))):(console.debug("OR WebWorker: writer not initialised. Received auth."),void g()):(console.debug("OR WebWorker: sender not initialised. Received auth."),void g()):void 0}if(a){const t=a;s.forEach((s=>{55===s[0]&&(s[1]?p=setTimeout((()=>g()),18e5):clearTimeout(p)),t.writeMessage(s)}))}else postMessage("not_init"),g()}else o()}else o()};'], { type: "text/javascript" })));
      this.worker.onerror = (e) => {
        this._debug("webworker_error", e);
      };
      this.worker.onmessage = ({ data }) => {
        this.handleWorkerMsg(data);
      };
      const alertWorker = () => {
        if (this.worker) {
          this.worker.postMessage(null);
        }
      };
      this.attachEventListener(window, "beforeunload", alertWorker, false);
      this.attachEventListener(document.body, "mouseleave", alertWorker, false, false);
      this.attachEventListener(document, "visibilitychange", alertWorker, false);
    } catch (e) {
      this._debug("worker_start", e);
    }
  }
  handleWorkerMsg(data) {
    var _a3;
    if (data === "a_stop") {
      this.stop(false);
    } else if (data === "a_start") {
      void this.start({}, true);
    } else if (data === "not_init") {
      this.debug.warn("OR WebWorker: writer not initialised. Restarting tracker");
    } else if (data.type === "failure") {
      this.stop(false);
      this.debug.error("worker_failed", data.reason);
      this._debug("worker_failed", data.reason);
    } else if (data.type === "compress") {
      const batch = data.batch;
      const batchSize = batch.byteLength;
      if (batchSize > this.compressionThreshold) {
        gzip(data.batch, { mtime: 0 }, (err2, result) => {
          var _a4, _b2;
          if (err2) {
            this.debug.error("Openreplay compression error:", err2);
            (_a4 = this.worker) == null ? void 0 : _a4.postMessage({ type: "uncompressed", batch });
          } else {
            (_b2 = this.worker) == null ? void 0 : _b2.postMessage({ type: "compressed", batch: result });
          }
        });
      } else {
        (_a3 = this.worker) == null ? void 0 : _a3.postMessage({ type: "uncompressed", batch });
      }
    } else if (data.type === "queue_empty") {
      this.onSessionSent();
    }
  }
  _debug(context, e) {
    if (this.options.__debug_report_edp !== null) {
      void fetch(this.options.__debug_report_edp, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          context,
          // @ts-ignore
          error: `${e}`
        })
      });
    }
    this.debug.error("OpenReplay error: ", context, e);
  }
  send(message, urgent = false) {
    var _a3;
    if (this.activityState === ActivityState.NotActive) {
      return;
    }
    if (this.activityState === ActivityState.ColdStart) {
      this.bufferedMessages1.push(message);
      if (!this.singleBuffer) {
        this.bufferedMessages2.push(message);
      }
      (_a3 = this.conditionsManager) == null ? void 0 : _a3.processMessage(message);
    } else {
      this.messages.push(message);
    }
    if (this.activityState === ActivityState.Active && urgent) {
      this.commit();
    }
  }
  /**
   * Normal workflow: add timestamp and tab data to batch, then commit it
   * every ~30ms
   * */
  _nCommit() {
    if (this.socketMode) {
      this.messages.unshift(TabData(this.session.getTabId()));
      this.messages.unshift(Timestamp(this.timestamp()));
      this.commitCallbacks.forEach((cb) => cb(this.messages));
      this.messages.length = 0;
      return;
    }
    if (this.worker === void 0 || !this.messages.length) {
      return;
    }
    if (this.insideIframe) {
      window.parent.postMessage({
        line: proto.iframeBatch,
        messages: this.messages,
        domain: this.initialHostName
      }, "*");
      this.commitCallbacks.forEach((cb) => cb(this.messages));
      this.messages.length = 0;
      return;
    }
    try {
      requestIdleCb(() => {
        var _a3;
        this.messages.unshift(TabData(this.session.getTabId()));
        this.messages.unshift(Timestamp(this.timestamp()));
        (_a3 = this.worker) == null ? void 0 : _a3.postMessage(this.messages);
        this.commitCallbacks.forEach((cb) => cb(this.messages));
        this.messages.length = 0;
      });
    } catch (e) {
      this._debug("worker_commit", e);
      this.stop(true);
      setTimeout(() => {
        void this.start();
      }, 500);
    }
  }
  /**
   * Cold start: add timestamp and tab data to both batches
   * every 2nd tick, ~60ms
   * this will make batches a bit larger and replay will work with bigger jumps every frame
   * but in turn we don't overload batch writer on session start with 1000 batches
   * */
  _cStartCommit() {
    this.coldStartCommitN += 1;
    if (this.coldStartCommitN === 2) {
      this.bufferedMessages1.push(Timestamp(this.timestamp()));
      this.bufferedMessages1.push(TabData(this.session.getTabId()));
      this.bufferedMessages2.push(Timestamp(this.timestamp()));
      this.bufferedMessages2.push(TabData(this.session.getTabId()));
      this.coldStartCommitN = 0;
    }
  }
  commit() {
    if (this.activityState === ActivityState.ColdStart) {
      this._cStartCommit();
    } else {
      this._nCommit();
    }
  }
  postToWorker(messages) {
    var _a3;
    (_a3 = this.worker) == null ? void 0 : _a3.postMessage(messages);
    this.commitCallbacks.forEach((cb) => cb(messages));
    messages.length = 0;
  }
  timestamp() {
    return now() + this.delay;
  }
  safe(fn) {
    const app = this;
    return function(...args) {
      try {
        fn.apply(this, args);
      } catch (e) {
        app._debug("safe_fn_call", e);
      }
    };
  }
  attachCommitCallback(cb) {
    this.commitCallbacks.push(cb);
  }
  attachStartCallback(cb, useSafe = false) {
    if (useSafe) {
      cb = this.safe(cb);
    }
    this.startCallbacks.push(cb);
  }
  attachStopCallback(cb, useSafe = false) {
    if (useSafe) {
      cb = this.safe(cb);
    }
    this.stopCallbacks.push(cb);
  }
  // Use  app.nodes.attachNodeListener for registered nodes instead
  attachEventListener(target, type, listener, useSafe = true, useCapture = true) {
    if (useSafe) {
      listener = this.safe(listener);
    }
    const createListener = () => target ? createEventListener(target, type, listener, useCapture) : null;
    const deleteListener = () => target ? deleteEventListener(target, type, listener, useCapture) : null;
    this.attachStartCallback(createListener, useSafe);
    this.attachStopCallback(deleteListener, useSafe);
  }
  // TODO: full correct semantic
  checkRequiredVersion(version) {
    const reqVer = version.split(/[.-]/);
    const ver = this.version.split(/[.-]/);
    for (let i = 0; i < 3; i++) {
      if (isNaN(Number(ver[i])) || isNaN(Number(reqVer[i]))) {
        return false;
      }
      if (Number(ver[i]) > Number(reqVer[i])) {
        return true;
      }
      if (Number(ver[i]) < Number(reqVer[i])) {
        return false;
      }
    }
    return true;
  }
  getTrackerInfo() {
    return {
      userUUID: this.localStorage.getItem(this.options.local_uuid_key),
      projectKey: this.projectKey,
      revID: this.revID,
      trackerVersion: this.version,
      isSnippet: this.options.__is_snippet
    };
  }
  getSessionInfo() {
    return {
      ...this.session.getInfo(),
      ...this.getTrackerInfo()
    };
  }
  getSessionToken() {
    return this.session.getSessionToken();
  }
  getSessionID() {
    return this.session.getInfo().sessionID || void 0;
  }
  getSessionURL(options) {
    const { projectID, sessionID, timestamp } = this.session.getInfo();
    if (!projectID || !sessionID) {
      this.debug.error("OpenReplay error: Unable to build session URL");
      return void 0;
    }
    const ingest = this.options.ingestPoint;
    const isSaas = /api\.openreplay\.com/.test(ingest);
    const projectPath = isSaas ? "https://app.openreplay.com/ingest" : ingest;
    const url = projectPath.replace(/ingest$/, `${projectID}/session/${sessionID}`);
    if (options == null ? void 0 : options.withCurrentTime) {
      const jumpTo = now() - timestamp;
      return `${url}?jumpto=${jumpTo}`;
    }
    return url;
  }
  getHost() {
    return new URL(this.options.ingestPoint).host;
  }
  getProjectKey() {
    return this.projectKey;
  }
  getBaseHref() {
    var _a3, _b2;
    if (typeof this.options.resourceBaseHref === "string") {
      return this.options.resourceBaseHref;
    } else if (typeof this.options.resourceBaseHref === "object") {
    }
    if (document.baseURI) {
      return document.baseURI;
    }
    return ((_b2 = (_a3 = document.head) == null ? void 0 : _a3.getElementsByTagName("base")[0]) == null ? void 0 : _b2.getAttribute("href")) || location.origin + location.pathname;
  }
  resolveResourceURL(resourceURL) {
    const base = new URL(this.getBaseHref());
    base.pathname += "/" + new URL(resourceURL).pathname;
    base.pathname.replace(/\/+/g, "/");
    return base.toString();
  }
  isServiceURL(url) {
    return url.startsWith(this.options.ingestPoint);
  }
  active() {
    return this.activityState === ActivityState.Active;
  }
  resetNextPageSession(flag) {
    if (flag) {
      this.sessionStorage.setItem(this.options.session_reset_key, "t");
    } else {
      this.sessionStorage.removeItem(this.options.session_reset_key);
    }
  }
  checkSessionToken(forceNew) {
    const lsReset = this.sessionStorage.getItem(this.options.session_reset_key) !== null;
    const needNewSessionID = forceNew || lsReset;
    const sessionToken = this.session.getSessionToken();
    return needNewSessionID || !sessionToken;
  }
  /**
   * start buffering messages without starting the actual session, which gives
   * user 30 seconds to "activate" and record session by calling `start()` on conditional trigger,
   * and we will then send buffered batch, so it won't get lost
   * */
  async coldStart(startOpts = {}, conditional) {
    this.singleBuffer = false;
    const second = 1e3;
    const isNewSession = this.checkSessionToken(startOpts.forceNew);
    if (conditional) {
      await this.setupConditionalStart(startOpts);
    }
    const cycle = () => {
      this.orderNumber += 1;
      adjustTimeOrigin();
      this.coldStartTs = now();
      if (this.orderNumber % 2 === 0) {
        this.bufferedMessages1.length = 0;
        this.bufferedMessages1.push(Timestamp(this.timestamp()));
        this.bufferedMessages1.push(TabData(this.session.getTabId()));
      } else {
        this.bufferedMessages2.length = 0;
        this.bufferedMessages2.push(Timestamp(this.timestamp()));
        this.bufferedMessages2.push(TabData(this.session.getTabId()));
      }
      this.stop(false);
      this.activityState = ActivityState.ColdStart;
      if (startOpts.sessionHash) {
        this.session.applySessionHash(startOpts.sessionHash);
      }
      if (startOpts.forceNew) {
        this.session.reset();
      }
      this.session.assign({
        userID: startOpts.userID,
        metadata: startOpts.metadata
      });
      if (!isNewSession) {
        this.debug.log("continuing session on new tab", this.session.getTabId());
        this.send(TabChange(this.session.getTabId()));
      }
      this.observer.observe();
      this.ticker.start();
    };
    this.coldInterval = setInterval(() => {
      cycle();
    }, 30 * second);
    cycle();
  }
  async setupConditionalStart(startOpts) {
    var _a3, _b2;
    this.conditionsManager = new ConditionsManager(this, startOpts);
    const r = await fetch(this.options.ingestPoint + "/v1/web/start", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        ...this.getTrackerInfo(),
        timestamp: now(),
        doNotRecord: true,
        bufferDiff: 0,
        userID: this.session.getInfo().userID,
        token: void 0,
        deviceMemory,
        jsHeapSizeLimit,
        timezone: getTimezone(),
        width: window.innerWidth,
        height: window.innerHeight
      })
    });
    const {
      // this token is needed to fetch conditions and flags,
      // but it can't be used to record a session
      token,
      userBrowser,
      userCity,
      userCountry,
      userDevice,
      userOS,
      userState,
      projectID
    } = await r.json();
    this.session.assign({ projectID });
    this.session.setUserInfo({
      userBrowser,
      userCity,
      userCountry,
      userDevice,
      userOS,
      userState
    });
    const onStartInfo = { sessionToken: token, userUUID: "", sessionID: "" };
    this.startCallbacks.forEach((cb) => cb(onStartInfo));
    await ((_a3 = this.conditionsManager) == null ? void 0 : _a3.fetchConditions(projectID, token));
    await this.featureFlags.reloadFlags(token);
    await this.tagWatcher.fetchTags(this.options.ingestPoint, token);
    (_b2 = this.conditionsManager) == null ? void 0 : _b2.processFlags(this.featureFlags.flags);
  }
  /**
   * Starts offline session recording
   * @param {Object} startOpts - options for session start, same as .start()
   * @param {Function} onSessionSent - callback that will be called once session is fully sent
   * */
  offlineRecording(startOpts = {}, onSessionSent) {
    this.onSessionSent = onSessionSent;
    this.singleBuffer = true;
    const isNewSession = this.checkSessionToken(startOpts.forceNew);
    adjustTimeOrigin();
    this.coldStartTs = now();
    const saverBuffer = this.localStorage.getItem(bufferStorageKey);
    if (saverBuffer) {
      const data = JSON.parse(saverBuffer);
      this.bufferedMessages1 = Array.isArray(data) ? data : this.bufferedMessages1;
      this.localStorage.removeItem(bufferStorageKey);
    }
    this.bufferedMessages1.push(Timestamp(this.timestamp()));
    this.bufferedMessages1.push(TabData(this.session.getTabId()));
    this.activityState = ActivityState.ColdStart;
    if (startOpts.sessionHash) {
      this.session.applySessionHash(startOpts.sessionHash);
    }
    if (startOpts.forceNew) {
      this.session.reset();
    }
    this.session.assign({
      userID: startOpts.userID,
      metadata: startOpts.metadata
    });
    const onStartInfo = { sessionToken: "", userUUID: "", sessionID: "" };
    this.startCallbacks.forEach((cb) => cb(onStartInfo));
    if (!isNewSession) {
      this.send(TabChange(this.session.getTabId()));
    }
    this.observer.observe();
    this.ticker.start();
    return {
      saveBuffer: this.saveBuffer,
      getBuffer: this.getBuffer,
      setBuffer: this.setBuffer
    };
  }
  /**
   * Saves the captured messages in localStorage (or whatever is used in its place)
   *
   * Then, when this.offlineRecording is called, it will preload this messages and clear the storage item
   *
   * Keeping the size of local storage reasonable is up to the end users of this library
   * */
  saveBuffer() {
    this.localStorage.setItem(bufferStorageKey, JSON.stringify(this.bufferedMessages1));
  }
  /**
   * @returns buffer with stored messages for offline recording
   * */
  getBuffer() {
    return this.bufferedMessages1;
  }
  /**
   * Used to set a buffer with messages array
   * */
  setBuffer(buffer) {
    this.bufferedMessages1 = buffer;
  }
  /**
   * Uploads the stored session buffer to backend
   * @returns promise that resolves once messages are loaded, it has to be awaited
   * so the session can be uploaded properly
   * @resolve - if messages were loaded in service worker successfully
   * @reject {string} - error message
   * */
  async uploadOfflineRecording() {
    var _a3, _b2;
    this.stop(false);
    const timestamp = now();
    (_a3 = this.worker) == null ? void 0 : _a3.postMessage({
      type: "start",
      pageNo: this.session.incPageNo(),
      ingestPoint: this.options.ingestPoint,
      timestamp: this.coldStartTs,
      url: document.URL,
      connAttemptCount: this.options.connAttemptCount,
      connAttemptGap: this.options.connAttemptGap,
      tabId: this.session.getTabId()
    });
    const r = await fetch(this.options.ingestPoint + "/v1/web/start", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        ...this.getTrackerInfo(),
        timestamp,
        doNotRecord: false,
        bufferDiff: timestamp - this.coldStartTs,
        userID: this.session.getInfo().userID,
        token: void 0,
        deviceMemory,
        jsHeapSizeLimit,
        timezone: getTimezone()
      })
    });
    const { token, userBrowser, userCity, userCountry, userDevice, userOS, userState, beaconSizeLimit, projectID } = await r.json();
    (_b2 = this.worker) == null ? void 0 : _b2.postMessage({
      type: "auth",
      token,
      beaconSizeLimit
    });
    this.session.assign({ projectID });
    this.session.setUserInfo({
      userBrowser,
      userCity,
      userCountry,
      userDevice,
      userOS,
      userState
    });
    while (this.bufferedMessages1.length > 0) {
      await this.flushBuffer(this.bufferedMessages1);
    }
    this.postToWorker([["q_end"]]);
    this.clearBuffers();
  }
  async _start(startOpts = {}, resetByWorker = false, conditionName) {
    const isColdStart = this.activityState === ActivityState.ColdStart;
    if (isColdStart && this.coldInterval) {
      clearInterval(this.coldInterval);
    }
    if (!this.worker) {
      const reason = "No worker found: perhaps, CSP is not set.";
      this.signalError(reason, []);
      return Promise.resolve(UnsuccessfulStart(reason));
    }
    if (this.activityState === ActivityState.Active || this.activityState === ActivityState.Starting) {
      const reason = "OpenReplay: trying to call `start()` on the instance that has been started already.";
      return Promise.resolve(UnsuccessfulStart(reason));
    }
    this.activityState = ActivityState.Starting;
    if (!isColdStart) {
      adjustTimeOrigin();
    }
    if (startOpts.sessionHash) {
      this.session.applySessionHash(startOpts.sessionHash);
    }
    if (startOpts.forceNew) {
      this.session.reset();
    }
    this.session.assign({
      // MBTODO: maybe it would make sense to `forceNew` if the `userID` was changed
      userID: startOpts.userID,
      metadata: startOpts.metadata
    });
    const timestamp = now();
    this.worker.postMessage({
      type: "start",
      pageNo: this.session.incPageNo(),
      ingestPoint: this.options.ingestPoint,
      timestamp: isColdStart ? this.coldStartTs : timestamp,
      url: document.URL,
      connAttemptCount: this.options.connAttemptCount,
      connAttemptGap: this.options.connAttemptGap,
      tabId: this.session.getTabId()
    });
    const sessionToken = this.session.getSessionToken();
    const isNewSession = this.checkSessionToken(startOpts.forceNew);
    this.sessionStorage.removeItem(this.options.session_reset_key);
    this.debug.log("OpenReplay: starting session; need new session id?", isNewSession, "session token: ", sessionToken);
    try {
      const r = await window.fetch(this.options.ingestPoint + "/v1/web/start", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          ...this.getTrackerInfo(),
          timestamp,
          doNotRecord: false,
          bufferDiff: timestamp - this.coldStartTs,
          userID: this.session.getInfo().userID,
          token: isNewSession ? void 0 : sessionToken,
          deviceMemory,
          jsHeapSizeLimit,
          timezone: getTimezone(),
          condition: conditionName,
          assistOnly: startOpts.assistOnly ?? this.socketMode
        })
      });
      if (r.status !== 200) {
        const error = await r.text();
        const reason = error === CANCELED ? CANCELED : `Server error: ${r.status}. ${error}`;
        return Promise.reject(reason);
      }
      if (!this.worker) {
        const reason = "no worker found after start request (this might not happen)";
        this.signalError(reason, []);
        return Promise.reject(reason);
      }
      const {
        token,
        userUUID,
        projectID,
        beaconSizeLimit,
        compressionThreshold,
        // how big the batch should be before we decide to compress it
        delay: delay2,
        //  derived from token
        sessionID,
        //  derived from token
        startTimestamp,
        // real startTS (server time), derived from sessionID
        userBrowser,
        userCity,
        userCountry,
        userDevice,
        userOS,
        userState,
        canvasEnabled,
        canvasQuality,
        canvasFPS,
        assistOnly: socketOnly
      } = await r.json();
      if (typeof token !== "string" || typeof userUUID !== "string" || typeof startTimestamp !== "number" && typeof startTimestamp !== "undefined" || typeof sessionID !== "string" || typeof delay2 !== "number" || typeof beaconSizeLimit !== "number" && typeof beaconSizeLimit !== "undefined") {
        const reason = `Incorrect server response: ${JSON.stringify(r)}`;
        this.signalError(reason, []);
        return Promise.reject(reason);
      }
      this.delay = delay2;
      this.session.setSessionToken(token);
      this.session.setUserInfo({
        userBrowser,
        userCity,
        userCountry,
        userDevice,
        userOS,
        userState
      });
      this.session.assign({
        sessionID,
        timestamp: startTimestamp || timestamp,
        projectID
      });
      if (socketOnly) {
        this.socketMode = true;
        this.worker.postMessage("stop");
      } else {
        this.worker.postMessage({
          type: "auth",
          token,
          beaconSizeLimit
        });
      }
      if (!isNewSession && token === sessionToken) {
        this.debug.log("continuing session on new tab", this.session.getTabId());
        this.send(TabChange(this.session.getTabId()));
      }
      Object.entries(this.session.getInfo().metadata).forEach(([key, value]) => this.send(Metadata(key, value)));
      this.localStorage.setItem(this.options.local_uuid_key, userUUID);
      this.compressionThreshold = compressionThreshold;
      const onStartInfo = { sessionToken: token, userUUID, sessionID };
      this.startCallbacks.forEach((cb) => cb(onStartInfo));
      void this.featureFlags.reloadFlags();
      await this.tagWatcher.fetchTags(this.options.ingestPoint, token);
      this.activityState = ActivityState.Active;
      if (canvasEnabled && !this.options.canvas.disableCanvas) {
        this.canvasRecorder = this.canvasRecorder ?? new canvas_default(this, {
          fps: canvasFPS,
          quality: canvasQuality,
          isDebug: this.options.canvas.__save_canvas_locally,
          fixedScaling: this.options.canvas.fixedCanvasScaling,
          useAnimationFrame: this.options.canvas.useAnimationFrame
        });
        this.canvasRecorder.startTracking();
      }
      if (isColdStart) {
        const biggestBuffer = this.bufferedMessages1.length > this.bufferedMessages2.length ? this.bufferedMessages1 : this.bufferedMessages2;
        while (biggestBuffer.length > 0) {
          await this.flushBuffer(biggestBuffer);
        }
        this.clearBuffers();
        this.commit();
      } else {
        if (this.insideIframe && this.rootId) {
          this.observer.crossdomainObserve(this.rootId, this.frameOderNumber);
        } else {
          this.observer.observe();
        }
        this.ticker.start();
      }
      this.uxtManager = this.uxtManager ? this.uxtManager : new UserTestManager(this, uxtStorageKey);
      let uxtId;
      const savedUxtTag = this.localStorage.getItem(uxtStorageKey);
      if (savedUxtTag) {
        uxtId = parseInt(savedUxtTag, 10);
      }
      if (location == null ? void 0 : location.search) {
        const query = new URLSearchParams(location.search);
        if (query.has("oruxt")) {
          const qId = query.get("oruxt");
          uxtId = qId ? parseInt(qId, 10) : void 0;
        }
      }
      if (uxtId) {
        if (!this.uxtManager.isActive) {
          this.uxtManager.getTest(uxtId, token, Boolean(savedUxtTag)).then((id2) => {
            if (id2) {
              this.onUxtCb.forEach((cb) => cb(id2));
            }
          });
        } else {
          this.onUxtCb.forEach((cb) => cb(uxtId));
        }
      }
      return SuccessfulStart(onStartInfo);
    } catch (reason) {
      this.stop();
      this.session.reset();
      if (reason === CANCELED) {
        this.signalError(CANCELED, []);
        return UnsuccessfulStart(CANCELED);
      }
      this._debug("session_start", reason);
      const errorMessage = reason instanceof Error ? reason.message : reason.toString();
      this.signalError(errorMessage, []);
      return UnsuccessfulStart(errorMessage);
    }
  }
  addOnUxtCb(cb) {
    this.onUxtCb.push(cb);
  }
  getUxtId() {
    var _a3;
    return (_a3 = this.uxtManager) == null ? void 0 : _a3.getTestId();
  }
  async waitStart() {
    return new Promise((resolve) => {
      const check = () => {
        if (this.canStart) {
          resolve(true);
        } else {
          setTimeout(check, 25);
        }
      };
      check();
    });
  }
  async waitStarted() {
    return new Promise((resolve) => {
      const check = () => {
        if (this.activityState === ActivityState.Active) {
          resolve(true);
        } else {
          setTimeout(check, 25);
        }
      };
      check();
    });
  }
  /**
   * basically we ask other tabs during constructor
   * and here we just apply 10ms delay just in case
   * */
  async start(...args) {
    if (this.activityState === ActivityState.Active || this.activityState === ActivityState.Starting) {
      const reason = "OpenReplay: trying to call `start()` on the instance that has been started already.";
      return Promise.resolve(UnsuccessfulStart(reason));
    }
    if (!document.hidden) {
      await this.waitStart();
      return this._start(...args);
    } else {
      return new Promise((resolve) => {
        const onVisibilityChange = async () => {
          if (!document.hidden) {
            await this.waitStart();
            document.removeEventListener("visibilitychange", onVisibilityChange);
            resolve(this._start(...args));
          }
        };
        document.addEventListener("visibilitychange", onVisibilityChange);
      });
    }
  }
  forceFlushBatch() {
    var _a3;
    (_a3 = this.worker) == null ? void 0 : _a3.postMessage("forceFlushBatch");
  }
  getTabId() {
    return this.session.getTabId();
  }
  clearBuffers() {
    this.bufferedMessages1.length = 0;
    this.bufferedMessages2.length = 0;
  }
  /**
   * Creates a named hook that expects event name, data string and msg direction (up/down),
   * it will skip any message bigger than 5 mb or event name bigger than 255 symbols
   * @returns {(msgType: string, data: string, dir: "up" | "down") => void}
   * */
  trackWs(channelName) {
    const channel = channelName;
    return (msgType, data, dir = "down") => {
      if (typeof msgType !== "string" || typeof data !== "string" || data.length > 5 * 1024 * 1024 || msgType.length > 255) {
        return;
      }
      this.send(WSChannel("websocket", channel, data, this.timestamp(), dir, msgType));
    };
  }
  stop(stopWorker = true) {
    var _a3;
    if (this.activityState !== ActivityState.NotActive) {
      try {
        this.attributeSender.clear();
        this.sanitizer.clear();
        this.observer.disconnect();
        this.nodes.clear();
        this.ticker.stop();
        this.stopCallbacks.forEach((cb) => cb());
        this.debug.log("OpenReplay tracking stopped.");
        this.tagWatcher.clear();
        if (this.worker && stopWorker) {
          this.worker.postMessage("stop");
        }
        (_a3 = this.canvasRecorder) == null ? void 0 : _a3.clear();
      } finally {
        this.activityState = ActivityState.NotActive;
      }
    }
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/connection.js
function connection_default(app) {
  const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
  if (connection === void 0) {
    return;
  }
  const sendConnectionInformation = () => app.send(ConnectionInformation(Math.round(connection.downlink * 1e3), connection.type || "unknown"));
  sendConnectionInformation();
  connection.addEventListener("change", sendConnectionInformation);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/console.js
var printError = IN_BROWSER && "InstallTrigger" in window ? (e) => e.message + "\n" + e.stack : (e) => e.stack || e.message;
function printString(arg) {
  if (arg === void 0) {
    return "undefined";
  }
  if (arg === null) {
    return "null";
  }
  if (arg instanceof Error) {
    return printError(arg);
  }
  if (Array.isArray(arg)) {
    return `Array(${arg.length})`;
  }
  return String(arg);
}
function printFloat(arg) {
  if (typeof arg !== "number")
    return "NaN";
  return arg.toString();
}
function printInt(arg) {
  if (typeof arg !== "number")
    return "NaN";
  return Math.floor(arg).toString();
}
function printObject(arg) {
  if (arg === void 0) {
    return "undefined";
  }
  if (arg === null) {
    return "null";
  }
  if (arg instanceof Error) {
    return printError(arg);
  }
  if (Array.isArray(arg)) {
    const length = arg.length;
    const values = arg.slice(0, 10).map(printString).join(", ");
    return `Array(${length})[${values}]`;
  }
  if (typeof arg === "object") {
    const res = [];
    let i = 0;
    for (const k in arg) {
      if (++i === 10) {
        break;
      }
      const v = arg[k];
      res.push(k + ": " + printString(v));
    }
    return "{" + res.join(", ") + "}";
  }
  return arg.toString();
}
function printf(args) {
  if (typeof args[0] === "string") {
    args.unshift(args.shift().replace(/%(o|s|f|d|i)/g, (s, t) => {
      const arg = args.shift();
      if (arg === void 0)
        return s;
      switch (t) {
        case "o":
          return printObject(arg);
        case "s":
          return printString(arg);
        case "f":
          return printFloat(arg);
        case "d":
        case "i":
          return printInt(arg);
        default:
          return s;
      }
    }));
  }
  return args.map(printObject).join(" ");
}
var consoleMethods = ["log", "info", "warn", "error", "debug", "assert"];
function console_default(app, opts) {
  const options = Object.assign({
    consoleMethods,
    consoleThrottling: 30
  }, opts);
  if (!Array.isArray(options.consoleMethods) || options.consoleMethods.length === 0) {
    return;
  }
  const sendConsoleLog = app.safe((level, args) => app.send(ConsoleLog(level, printf(args))));
  let n = 0;
  const reset = () => {
    n = 0;
  };
  app.attachStartCallback(reset);
  app.ticker.attach(reset, 33, false);
  const patchConsole = (console2, ctx) => {
    const handler = {
      apply: function(target, thisArg, argumentsList) {
        Reflect.apply(target, ctx, argumentsList);
        n = n + 1;
        if (n > options.consoleThrottling) {
          return;
        } else {
          sendConsoleLog(target.name, argumentsList);
        }
      }
    };
    options.consoleMethods.forEach((method) => {
      if (consoleMethods.indexOf(method) === -1) {
        app.debug.error(`OpenReplay: unsupported console method "${method}"`);
        return;
      }
      const fn = ctx.console[method];
      console2[method] = new Proxy(fn, handler);
    });
  };
  const patchContext = app.safe((context) => patchConsole(context.console, context));
  patchContext(window);
  app.observer.attachContextCallback(patchContext);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/exception.js
var import_error_stack_parser = __toESM(require_error_stack_parser(), 1);
function getDefaultStack(e) {
  return [
    {
      columnNumber: e.colno,
      lineNumber: e.lineno,
      fileName: e.filename,
      functionName: "",
      source: ""
    }
  ];
}
function getExceptionMessage(error, fallbackStack, metadata = {}) {
  let stack = fallbackStack;
  try {
    stack = import_error_stack_parser.default.parse(error);
  } catch (e) {
  }
  return JSException(error.name, error.message, JSON.stringify(stack), JSON.stringify(metadata));
}
function getExceptionMessageFromEvent(e, context = window, metadata = {}) {
  if (e instanceof ErrorEvent) {
    if (e.error instanceof Error) {
      return getExceptionMessage(e.error, getDefaultStack(e), metadata);
    } else {
      let [name, message] = e.message.split(":");
      if (!message) {
        name = "Error";
        message = e.message;
      }
      return JSException(name, message, JSON.stringify(getDefaultStack(e)), JSON.stringify(metadata));
    }
  } else if ("PromiseRejectionEvent" in context && e instanceof context.PromiseRejectionEvent) {
    if (e.reason instanceof Error) {
      return getExceptionMessage(e.reason, [], metadata);
    } else {
      let message;
      try {
        message = JSON.stringify(e.reason);
      } catch (_) {
        message = String(e.reason);
      }
      return JSException("Unhandled Promise Rejection", message, "[]", JSON.stringify(metadata));
    }
  }
  return null;
}
function exception_default(app, opts) {
  const options = Object.assign({
    captureExceptions: true
  }, opts);
  function patchContext(context) {
    function handler(e) {
      const msg = getExceptionMessageFromEvent(e, context);
      if (msg != null) {
        app.send(msg);
      }
    }
    app.attachEventListener(context, "unhandledrejection", handler);
    app.attachEventListener(context, "error", handler);
  }
  if (options.captureExceptions) {
    app.observer.attachContextCallback(patchContext);
    patchContext(window);
  }
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/img.js
function resolveURL(url, location2 = document.location) {
  url = url.trim();
  if (url.startsWith("//") || url.startsWith("http://") || url.startsWith("https://") || url.startsWith("data:")) {
    return url;
  } else if (url.startsWith("/")) {
    return location2.origin + url;
  } else {
    return location2.origin + location2.pathname + url;
  }
}
function isSVGInFireFox(url) {
  return IS_FIREFOX && (url.startsWith("data:image/svg+xml") || url.match(/.svg$|/i));
}
var PLACEHOLDER_SRC = "https://static.openreplay.com/tracker/placeholder.jpeg";
function img_default(app) {
  function sendPlaceholder(id2, node) {
    app.attributeSender.sendSetAttribute(id2, "src", PLACEHOLDER_SRC);
    const { width, height } = node.getBoundingClientRect();
    if (!node.hasAttribute("width")) {
      app.attributeSender.sendSetAttribute(id2, "width", String(width));
    }
    if (!node.hasAttribute("height")) {
      app.attributeSender.sendSetAttribute(id2, "height", String(height));
    }
  }
  const sendSrcset = function(id2, img) {
    const { srcset } = img;
    if (!srcset) {
      return;
    }
    const resolvedSrcset = srcset.split(srcset.match(/,\s+/) ? /,\s+/ : ",").map((str) => resolveURL(str)).join(", ");
    app.attributeSender.sendSetAttribute(id2, "srcset", resolvedSrcset);
  };
  const sendSrc = function(id2, img) {
    if (img.src.length > MAX_STR_LEN) {
      sendPlaceholder(id2, img);
    }
    app.send(SetNodeAttributeURLBased(id2, "src", img.src, app.getBaseHref()));
  };
  const sendImgError = app.safe(function(img) {
    const resolvedSrc = resolveURL(img.src || "");
    if (isURL(resolvedSrc)) {
      app.send(ResourceTiming(app.timestamp(), 0, 0, 0, 0, 0, resolvedSrc, "img", 0, false));
    }
  });
  const sendImgAttrs = app.safe(function(img) {
    const id2 = app.nodes.getID(img);
    if (id2 === void 0) {
      return;
    }
    if (!img.complete) {
      return;
    }
    if (img.naturalHeight === 0 && img.naturalWidth === 0 && !isSVGInFireFox(img.src)) {
      sendImgError(img);
    } else if (app.sanitizer.isHidden(id2) || app.sanitizer.isObscured(id2)) {
      sendPlaceholder(id2, img);
    } else {
      sendSrc(id2, img);
      sendSrcset(id2, img);
    }
  });
  const observer = createMutationObserver(app.safe((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === "attributes") {
        const target = mutation.target;
        const id2 = app.nodes.getID(target);
        if (id2 === void 0) {
          return;
        }
        if (mutation.attributeName === "src") {
          sendSrc(id2, target);
        }
        if (mutation.attributeName === "srcset") {
          sendSrcset(id2, target);
        }
      }
    }
  }));
  app.attachStopCallback(() => {
    observer.disconnect();
  });
  app.nodes.attachNodeCallback((node) => {
    if (!hasTag(node, "img")) {
      return;
    }
    app.nodes.attachNodeListener(node, "error", () => sendImgError(node));
    app.nodes.attachNodeListener(node, "load", () => sendImgAttrs(node));
    sendImgAttrs(node);
    observer.observe(node, { attributes: true, attributeFilter: ["src", "srcset"] });
  });
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/input.js
var INPUT_TYPES = [
  "text",
  "password",
  "email",
  "search",
  "number",
  "range",
  "date",
  "tel",
  "time"
];
function isTextFieldElement(node) {
  if (hasTag(node, "textarea")) {
    return true;
  }
  if (!hasTag(node, "input")) {
    return false;
  }
  return INPUT_TYPES.includes(node.type);
}
function isCheckbox(node) {
  if (!hasTag(node, "input")) {
    return false;
  }
  const type = node.type;
  return type === "checkbox" || type === "radio";
}
var labelElementFor = IN_BROWSER && "labels" in HTMLInputElement.prototype ? (node) => {
  let p = node;
  while ((p = p.parentNode) !== null) {
    if (hasTag(p, "label")) {
      return p;
    }
  }
  const labels = node.labels;
  if (labels !== null && labels.length === 1) {
    return labels[0];
  }
} : (node) => {
  let p = node;
  while ((p = p.parentNode) !== null) {
    if (hasTag(p, "label")) {
      return p;
    }
  }
  const id2 = node.id;
  if (id2) {
    const labels = node.ownerDocument.querySelectorAll('label[for="' + id2 + '"]');
    if (labels !== null && labels.length === 1) {
      return labels[0];
    }
  }
};
function getInputLabel(node) {
  let label = getLabelAttribute(node);
  if (label === null) {
    const labelElement = labelElementFor(node);
    label = labelElement && labelElement.innerText || node.placeholder || node.name || node.id || node.className || node.type;
  }
  return normSpaces(label).slice(0, 100);
}
var InputMode = {
  Plain: 0,
  Obscured: 1,
  Hidden: 2
};
function input_default(app, opts) {
  const options = Object.assign({
    obscureInputNumbers: true,
    obscureInputEmails: true,
    defaultInputMode: InputMode.Obscured,
    obscureInputDates: false
  }, opts);
  function getInputValue(id2, node) {
    let value = node.value;
    let inputMode = options.defaultInputMode;
    if (node.type === "password" || app.sanitizer.isHidden(id2)) {
      inputMode = InputMode.Hidden;
    } else if (app.sanitizer.isObscured(id2) || inputMode === InputMode.Plain && (options.obscureInputNumbers && node.type !== "date" && /\d\d\d\d/.test(value) || options.obscureInputDates && node.type === "date" || options.obscureInputEmails && (node.type === "email" || !!~value.indexOf("@")))) {
      inputMode = InputMode.Obscured;
    }
    let mask = 0;
    switch (inputMode) {
      case InputMode.Hidden:
        mask = -1;
        value = "";
        break;
      case InputMode.Obscured:
        mask = value.length;
        value = "";
        break;
    }
    return { value, mask };
  }
  function sendInputValue(id2, node) {
    const { value, mask } = getInputValue(id2, node);
    app.send(SetInputValue(id2, value, mask));
  }
  const inputValues = /* @__PURE__ */ new Map();
  const checkboxValues = /* @__PURE__ */ new Map();
  app.attachStopCallback(() => {
    inputValues.clear();
    checkboxValues.clear();
  });
  function trackInputValue(id2, node) {
    if (inputValues.get(id2) === node.value) {
      return;
    }
    inputValues.set(id2, node.value);
    sendInputValue(id2, node);
  }
  function trackCheckboxValue(id2, value) {
    if (checkboxValues.get(id2) === value) {
      return;
    }
    checkboxValues.set(id2, value);
    app.send(SetInputChecked(id2, value));
  }
  app.ticker.attach(() => {
    inputValues.forEach((value, id2) => {
      const node = app.nodes.getNode(id2);
      if (!node)
        return inputValues.delete(id2);
      trackInputValue(id2, node);
    });
    checkboxValues.forEach((checked, id2) => {
      const node = app.nodes.getNode(id2);
      if (!node)
        return checkboxValues.delete(id2);
      trackCheckboxValue(id2, node.checked);
    });
  }, 3);
  function sendInputChange(id2, node, hesitationTime, inputTime) {
    const { value, mask } = getInputValue(id2, node);
    const label = getInputLabel(node);
    app.send(InputChange(id2, value, mask !== 0, label, hesitationTime, inputTime));
  }
  app.nodes.attachNodeCallback(app.safe((node) => {
    const id2 = app.nodes.getID(node);
    if (id2 === void 0) {
      return;
    }
    if (hasTag(node, "select")) {
      sendInputValue(id2, node);
      app.nodes.attachNodeListener(node, "change", () => sendInputValue(id2, node));
    }
    if (isTextFieldElement(node)) {
      trackInputValue(id2, node);
      let nodeFocusTime = 0;
      let nodeHesitationTime = 0;
      let inputTime = 0;
      const onFocus = () => {
        nodeFocusTime = now();
      };
      const onInput = () => {
        if (nodeHesitationTime === 0 && nodeFocusTime !== 0) {
          nodeHesitationTime = now() - nodeFocusTime;
        }
      };
      const onChange = () => {
        if (nodeFocusTime !== 0) {
          inputTime = now() - nodeFocusTime;
        }
        sendInputChange(id2, node, nodeHesitationTime, inputTime);
        nodeHesitationTime = 0;
        inputTime = 0;
        nodeFocusTime = 0;
      };
      app.nodes.attachNodeListener(node, "focus", onFocus);
      app.nodes.attachNodeListener(node, "input", onInput);
      app.nodes.attachNodeListener(node, "change", onChange);
      return;
    }
    if (isCheckbox(node)) {
      trackCheckboxValue(id2, node.checked);
      app.nodes.attachNodeListener(node, "change", () => trackCheckboxValue(id2, node.checked));
      return;
    }
  }));
}

// node_modules/.pnpm/@medv+finder@3.2.0/node_modules/@medv/finder/finder.js
var config;
var rootDocument;
var start;
function finder(input, options) {
  start = /* @__PURE__ */ new Date();
  if (input.nodeType !== Node.ELEMENT_NODE) {
    throw new Error(`Can't generate CSS selector for non-element node type.`);
  }
  if ("html" === input.tagName.toLowerCase()) {
    return "html";
  }
  const defaults = {
    root: document.body,
    idName: (name) => true,
    className: (name) => true,
    tagName: (name) => true,
    attr: (name, value) => false,
    seedMinLength: 1,
    optimizedMinLength: 2,
    threshold: 1e3,
    maxNumberOfTries: 1e4,
    timeoutMs: void 0
  };
  config = { ...defaults, ...options };
  rootDocument = findRootDocument(config.root, defaults);
  let path = bottomUpSearch(input, "all", () => bottomUpSearch(input, "two", () => bottomUpSearch(input, "one", () => bottomUpSearch(input, "none"))));
  if (path) {
    const optimized = sort(optimize(path, input));
    if (optimized.length > 0) {
      path = optimized[0];
    }
    return selector(path);
  } else {
    throw new Error(`Selector was not found.`);
  }
}
function findRootDocument(rootNode, defaults) {
  if (rootNode.nodeType === Node.DOCUMENT_NODE) {
    return rootNode;
  }
  if (rootNode === defaults.root) {
    return rootNode.ownerDocument;
  }
  return rootNode;
}
function bottomUpSearch(input, limit, fallback) {
  let path = null;
  let stack = [];
  let current = input;
  let i = 0;
  while (current) {
    const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - start.getTime();
    if (config.timeoutMs !== void 0 && elapsedTime > config.timeoutMs) {
      throw new Error(`Timeout: Can't find a unique selector after ${elapsedTime}ms`);
    }
    let level = maybe(id(current)) || maybe(...attr(current)) || maybe(...classNames(current)) || maybe(tagName(current)) || [any()];
    const nth = index(current);
    if (limit == "all") {
      if (nth) {
        level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));
      }
    } else if (limit == "two") {
      level = level.slice(0, 1);
      if (nth) {
        level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));
      }
    } else if (limit == "one") {
      const [node] = level = level.slice(0, 1);
      if (nth && dispensableNth(node)) {
        level = [nthChild(node, nth)];
      }
    } else if (limit == "none") {
      level = [any()];
      if (nth) {
        level = [nthChild(level[0], nth)];
      }
    }
    for (let node of level) {
      node.level = i;
    }
    stack.push(level);
    if (stack.length >= config.seedMinLength) {
      path = findUniquePath(stack, fallback);
      if (path) {
        break;
      }
    }
    current = current.parentElement;
    i++;
  }
  if (!path) {
    path = findUniquePath(stack, fallback);
  }
  if (!path && fallback) {
    return fallback();
  }
  return path;
}
function findUniquePath(stack, fallback) {
  const paths = sort(combinations(stack));
  if (paths.length > config.threshold) {
    return fallback ? fallback() : null;
  }
  for (let candidate of paths) {
    if (unique(candidate)) {
      return candidate;
    }
  }
  return null;
}
function selector(path) {
  let node = path[0];
  let query = node.name;
  for (let i = 1; i < path.length; i++) {
    const level = path[i].level || 0;
    if (node.level === level - 1) {
      query = `${path[i].name} > ${query}`;
    } else {
      query = `${path[i].name} ${query}`;
    }
    node = path[i];
  }
  return query;
}
function penalty(path) {
  return path.map((node) => node.penalty).reduce((acc, i) => acc + i, 0);
}
function unique(path) {
  const css = selector(path);
  switch (rootDocument.querySelectorAll(css).length) {
    case 0:
      throw new Error(`Can't select any node with this selector: ${css}`);
    case 1:
      return true;
    default:
      return false;
  }
}
function id(input) {
  const elementId = input.getAttribute("id");
  if (elementId && config.idName(elementId)) {
    return {
      name: "#" + CSS.escape(elementId),
      penalty: 0
    };
  }
  return null;
}
function attr(input) {
  const attrs = Array.from(input.attributes).filter((attr2) => config.attr(attr2.name, attr2.value));
  return attrs.map((attr2) => ({
    name: `[${CSS.escape(attr2.name)}="${CSS.escape(attr2.value)}"]`,
    penalty: 0.5
  }));
}
function classNames(input) {
  const names = Array.from(input.classList).filter(config.className);
  return names.map((name) => ({
    name: "." + CSS.escape(name),
    penalty: 1
  }));
}
function tagName(input) {
  const name = input.tagName.toLowerCase();
  if (config.tagName(name)) {
    return {
      name,
      penalty: 2
    };
  }
  return null;
}
function any() {
  return {
    name: "*",
    penalty: 3
  };
}
function index(input) {
  const parent = input.parentNode;
  if (!parent) {
    return null;
  }
  let child = parent.firstChild;
  if (!child) {
    return null;
  }
  let i = 0;
  while (child) {
    if (child.nodeType === Node.ELEMENT_NODE) {
      i++;
    }
    if (child === input) {
      break;
    }
    child = child.nextSibling;
  }
  return i;
}
function nthChild(node, i) {
  return {
    name: node.name + `:nth-child(${i})`,
    penalty: node.penalty + 1
  };
}
function dispensableNth(node) {
  return node.name !== "html" && !node.name.startsWith("#");
}
function maybe(...level) {
  const list = level.filter(notEmpty);
  if (list.length > 0) {
    return list;
  }
  return null;
}
function notEmpty(value) {
  return value !== null && value !== void 0;
}
function* combinations(stack, path = []) {
  if (stack.length > 0) {
    for (let node of stack[0]) {
      yield* combinations(stack.slice(1, stack.length), path.concat(node));
    }
  } else {
    yield path;
  }
}
function sort(paths) {
  return [...paths].sort((a, b) => penalty(a) - penalty(b));
}
function* optimize(path, input, scope = {
  counter: 0,
  visited: /* @__PURE__ */ new Map()
}) {
  if (path.length > 2 && path.length > config.optimizedMinLength) {
    for (let i = 1; i < path.length - 1; i++) {
      if (scope.counter > config.maxNumberOfTries) {
        return;
      }
      scope.counter += 1;
      const newPath = [...path];
      newPath.splice(i, 1);
      const newPathKey = selector(newPath);
      if (scope.visited.has(newPathKey)) {
        return;
      }
      if (unique(newPath) && same(newPath, input)) {
        yield newPath;
        scope.visited.set(newPathKey, true);
        yield* optimize(newPath, input, scope);
      }
    }
  }
}
function same(path, input) {
  return rootDocument.querySelector(selector(path)) === input;
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/mouse.js
function _getSelector(target, document2, options) {
  const selector2 = finder(target, {
    root: document2.body,
    seedMinLength: 3,
    optimizedMinLength: (options == null ? void 0 : options.minSelectorDepth) || 2,
    threshold: (options == null ? void 0 : options.nthThreshold) || 1e3,
    maxNumberOfTries: (options == null ? void 0 : options.maxOptimiseTries) || 1e4
  });
  return selector2;
}
function isClickable(element) {
  const tag = element.tagName.toUpperCase();
  return tag === "BUTTON" || tag === "A" || tag === "LI" || tag === "SELECT" || tag === "TR" || tag === "TH" || element.onclick != null || element.getAttribute("role") === "button";
}
function getTarget(target, document2) {
  if (target instanceof Element) {
    return _getTarget(target, document2);
  }
  return null;
}
function _getTarget(target, document2) {
  let element = target;
  while (element !== null && element !== document2.documentElement) {
    if (hasOpenreplayAttribute(element, "masked")) {
      return null;
    }
    element = element.parentElement;
  }
  if (isSVGElement(target)) {
    let owner = target.ownerSVGElement;
    while (owner !== null) {
      target = owner;
      owner = owner.ownerSVGElement;
    }
  }
  element = target;
  while (element !== null && element !== document2.documentElement) {
    const tag = element.tagName.toUpperCase();
    if (tag === "LABEL") {
      return null;
    }
    if (tag === "INPUT") {
      return element;
    }
    if (isClickable(element) || getLabelAttribute(element) !== null) {
      return element;
    }
    element = element.parentElement;
  }
  return target === document2.documentElement ? null : target;
}
function mouse_default(app, options) {
  const { disableClickmaps = false } = options || {};
  function getTargetLabel(target) {
    const dl = getLabelAttribute(target);
    if (dl !== null) {
      return dl;
    }
    if (hasTag(target, "input")) {
      return getInputLabel(target);
    }
    if (isClickable(target)) {
      let label = "";
      if (target instanceof HTMLElement) {
        label = app.sanitizer.getInnerTextSecure(target);
      }
      label = label || target.id || target.className;
      return normSpaces(label).slice(0, 100);
    }
    return "";
  }
  let mousePositionX = -1;
  let mousePositionY = -1;
  let mousePositionChanged = false;
  let mouseTarget = null;
  let mouseTargetTime = 0;
  let selectorMap = {};
  let velocity = 0;
  let direction = 0;
  let directionChangeCount = 0;
  let distance = 0;
  let checkIntervalId;
  const shakeThreshold = 8e-3;
  const shakeCheckInterval = 225;
  function checkMouseShaking() {
    const nextVelocity = distance / shakeCheckInterval;
    if (!velocity) {
      velocity = nextVelocity;
      return;
    }
    const acceleration = (nextVelocity - velocity) / shakeCheckInterval;
    if (directionChangeCount > 4 && acceleration > shakeThreshold) {
      app.send(MouseThrashing(now()));
    }
    distance = 0;
    directionChangeCount = 0;
    velocity = nextVelocity;
  }
  app.attachStartCallback(() => {
    checkIntervalId = setInterval(() => checkMouseShaking(), shakeCheckInterval);
  });
  app.attachStopCallback(() => {
    mousePositionX = -1;
    mousePositionY = -1;
    mousePositionChanged = false;
    mouseTarget = null;
    selectorMap = {};
    if (checkIntervalId) {
      clearInterval(checkIntervalId);
    }
  });
  const sendMouseMove = () => {
    if (mousePositionChanged) {
      app.send(MouseMove(mousePositionX, mousePositionY));
      mousePositionChanged = false;
    }
  };
  const patchDocument = (document2, topframe = false) => {
    function getSelector(id2, target, options2) {
      return selectorMap[id2] = selectorMap[id2] || _getSelector(target, document2, options2);
    }
    const attachListener = topframe ? app.attachEventListener.bind(app) : app.nodes.attachNodeListener.bind(app.nodes);
    attachListener(document2.documentElement, "mouseover", (e) => {
      const target = getTarget(e.target, document2);
      if (target !== mouseTarget) {
        mouseTarget = target;
        mouseTargetTime = performance.now();
      }
    });
    attachListener(document2, "mousemove", (e) => {
      const [left, top] = app.observer.getDocumentOffset(document2);
      mousePositionX = e.clientX + left;
      mousePositionY = e.clientY + top;
      mousePositionChanged = true;
      const nextDirection = Math.sign(e.movementX);
      distance += Math.abs(e.movementX) + Math.abs(e.movementY);
      if (nextDirection !== direction) {
        direction = nextDirection;
        directionChangeCount++;
      }
    }, false);
    attachListener(document2, "click", (e) => {
      const target = getTarget(e.target, document2);
      if (!e.clientX && !e.clientY || target === null) {
        return;
      }
      const id2 = app.nodes.getID(target);
      if (id2 !== void 0) {
        const clickX = e.pageX;
        const clickY = e.pageY;
        const contentWidth = document2.documentElement.scrollWidth;
        const contentHeight = document2.documentElement.scrollHeight;
        const normalizedX = roundNumber(clickX / contentWidth);
        const normalizedY = roundNumber(clickY / contentHeight);
        sendMouseMove();
        app.send(MouseClick(id2, mouseTarget === target ? Math.round(performance.now() - mouseTargetTime) : 0, getTargetLabel(target), isClickable(target) && !disableClickmaps ? getSelector(id2, target, options) : "", normalizedX, normalizedY), true);
      }
      mouseTarget = null;
    });
  };
  app.nodes.attachNodeCallback((node) => {
    if (isDocument(node)) {
      patchDocument(node);
    }
  });
  patchDocument(document, true);
  app.ticker.attach(sendMouseMove, (options == null ? void 0 : options.trackingOffset) || 7);
}
function roundNumber(num) {
  return Math.round(num * 1e4);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/timing.js
function getPaintBlocks(resources) {
  const paintBlocks = [];
  const elements = document.getElementsByTagName("*");
  const styleURL = /url\(("[^"]*"|'[^']*'|[^)]*)\)/i;
  for (let i = 0; i < elements.length; i++) {
    const element = elements[i];
    let src = "";
    if (hasTag(element, "img")) {
      src = element.currentSrc || element.src;
    }
    if (!src) {
      const backgroundImage = getComputedStyle(element).getPropertyValue("background-image");
      if (backgroundImage) {
        const matches = styleURL.exec(backgroundImage);
        if (matches !== null) {
          src = matches[1];
          if (src.startsWith('"') || src.startsWith("'")) {
            src = src.substr(1, src.length - 2);
          }
        }
      }
    }
    if (!src)
      continue;
    const time = src.substr(0, 10) === "data:image" ? 0 : resources[src];
    if (time === void 0)
      continue;
    const rect = element.getBoundingClientRect();
    const top = Math.max(rect.top, 0);
    const left = Math.max(rect.left, 0);
    const bottom = Math.min(rect.bottom, window.innerHeight || document.documentElement && document.documentElement.clientHeight || 0);
    const right = Math.min(rect.right, window.innerWidth || document.documentElement && document.documentElement.clientWidth || 0);
    if (bottom <= top || right <= left)
      continue;
    const area = (bottom - top) * (right - left);
    paintBlocks.push({ time, area });
  }
  return paintBlocks;
}
function calculateSpeedIndex(firstContentfulPaint, paintBlocks) {
  let a = Math.max(document.documentElement && document.documentElement.clientWidth || 0, window.innerWidth || 0) * Math.max(document.documentElement && document.documentElement.clientHeight || 0, window.innerHeight || 0) / 10;
  let s = a * firstContentfulPaint;
  for (let i = 0; i < paintBlocks.length; i++) {
    const { time, area } = paintBlocks[i];
    a += area;
    s += area * (time > firstContentfulPaint ? time : firstContentfulPaint);
  }
  return a === 0 ? 0 : s / a;
}
function timing_default(app, opts) {
  const options = Object.assign({
    captureResourceTimings: true,
    capturePageLoadTimings: true,
    capturePageRenderTimings: true,
    excludedResourceUrls: []
  }, opts);
  if (!("PerformanceObserver" in window)) {
    options.captureResourceTimings = false;
  }
  if (!options.captureResourceTimings) {
    return;
  }
  let resources = {};
  function resourceTiming(entry) {
    var _a3;
    if (entry.duration < 0 || !isURL(entry.name) || app.isServiceURL(entry.name))
      return;
    if (resources !== null) {
      resources[entry.name] = entry.startTime + entry.duration;
    }
    let shouldSkip = false;
    (_a3 = options.excludedResourceUrls) == null ? void 0 : _a3.forEach((url) => {
      if (entry.name.startsWith(url)) {
        shouldSkip = true;
        return;
      }
    });
    if (shouldSkip) {
      return;
    }
    app.send(ResourceTiming(
      entry.startTime + getTimeOrigin(),
      entry.duration,
      entry.responseStart && entry.startTime ? entry.responseStart - entry.startTime : 0,
      entry.transferSize > entry.encodedBodySize ? entry.transferSize - entry.encodedBodySize : 0,
      entry.encodedBodySize || 0,
      entry.decodedBodySize || 0,
      entry.name,
      entry.initiatorType,
      entry.transferSize,
      // @ts-ignore
      entry.responseStatus && entry.responseStatus === 304 || entry.transferSize === 0
    ));
  }
  const observer = new PerformanceObserver((list) => list.getEntries().forEach(resourceTiming));
  let prevSessionID;
  app.attachStartCallback(function({ sessionID }) {
    if (sessionID !== prevSessionID) {
      performance.getEntriesByType("resource").forEach(resourceTiming);
      prevSessionID = sessionID;
    }
    observer.observe({ entryTypes: ["resource"] });
  });
  app.attachStopCallback(function() {
    observer.disconnect();
  });
  let firstPaint = 0, firstContentfulPaint = 0;
  if (options.capturePageLoadTimings) {
    let pageLoadTimingSent = false;
    app.ticker.attach(() => {
      if (pageLoadTimingSent) {
        return;
      }
      if (firstPaint === 0 || firstContentfulPaint === 0) {
        performance.getEntriesByType("paint").forEach((entry) => {
          const { name, startTime } = entry;
          switch (name) {
            case "first-paint":
              firstPaint = startTime;
              break;
            case "first-contentful-paint":
              firstContentfulPaint = startTime;
              break;
          }
        });
      }
      if (performance.timing.loadEventEnd || performance.now() > 3e4) {
        pageLoadTimingSent = true;
        const {
          // should be ok to use here, (https://github.com/mdn/content/issues/4713)
          // since it is compared with the values obtained on the page load (before any possible sleep state)
          // deprecated though
          navigationStart,
          requestStart,
          responseStart,
          responseEnd,
          domContentLoadedEventStart,
          domContentLoadedEventEnd,
          loadEventStart,
          loadEventEnd
        } = performance.timing;
        app.send(PageLoadTiming(requestStart - navigationStart || 0, responseStart - navigationStart || 0, responseEnd - navigationStart || 0, domContentLoadedEventStart - navigationStart || 0, domContentLoadedEventEnd - navigationStart || 0, loadEventStart - navigationStart || 0, loadEventEnd - navigationStart || 0, firstPaint, firstContentfulPaint));
      }
    }, 30);
  }
  if (options.capturePageRenderTimings) {
    let visuallyComplete = 0, interactiveWindowStartTime = 0, interactiveWindowTickTime = 0, paintBlocks = null;
    let pageRenderTimingSent = false;
    app.ticker.attach(() => {
      if (pageRenderTimingSent) {
        return;
      }
      const time = performance.now();
      if (resources !== null) {
        visuallyComplete = Math.max.apply(null, Object.keys(resources).map((k) => resources[k]));
        if (time - visuallyComplete > 1e3) {
          paintBlocks = getPaintBlocks(resources);
          resources = null;
        }
      }
      if (interactiveWindowTickTime !== null) {
        if (time - interactiveWindowTickTime > 50) {
          interactiveWindowStartTime = time;
        }
        interactiveWindowTickTime = time - interactiveWindowStartTime > 5e3 ? null : time;
      }
      if (paintBlocks !== null && interactiveWindowTickTime === null || time > 3e4) {
        pageRenderTimingSent = true;
        resources = null;
        const speedIndex = paintBlocks === null ? 0 : calculateSpeedIndex(firstContentfulPaint || firstPaint, paintBlocks);
        const { domContentLoadedEventEnd, navigationStart } = performance.timing;
        const timeToInteractive = interactiveWindowTickTime === null ? Math.max(interactiveWindowStartTime, firstContentfulPaint, domContentLoadedEventEnd - navigationStart || 0) : 0;
        app.send(PageRenderTiming(speedIndex, firstContentfulPaint > visuallyComplete ? firstContentfulPaint : visuallyComplete, timeToInteractive));
      }
    });
  }
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/scroll.js
function getDocumentScroll(doc) {
  const win = doc.defaultView;
  return [
    win && win.scrollX || doc.documentElement && doc.documentElement.scrollLeft || doc.body && doc.body.scrollLeft || 0,
    win && win.scrollY || doc.documentElement && doc.documentElement.scrollTop || doc.body && doc.body.scrollTop || 0
  ];
}
function scroll_default(app, insideIframe) {
  let documentScroll = false;
  const nodeScroll = /* @__PURE__ */ new Map();
  function setNodeScroll(target) {
    if (!isNode(target)) {
      return;
    }
    if (isElementNode(target)) {
      nodeScroll.set(target, [target.scrollLeft, target.scrollTop]);
    }
    if (isDocument(target)) {
      nodeScroll.set(target, getDocumentScroll(target));
    }
  }
  const sendSetViewportScroll = app.safe(() => {
    if (insideIframe) {
      return;
    }
    app.send(SetViewportScroll(...getDocumentScroll(document)));
  });
  const sendSetNodeScroll = app.safe((s, node) => {
    const id2 = app.nodes.getID(node);
    if (id2 !== void 0) {
      app.send(SetNodeScroll(id2, s[0], s[1]));
    }
  });
  app.attachStartCallback(sendSetViewportScroll);
  app.attachStopCallback(() => {
    documentScroll = false;
    nodeScroll.clear();
  });
  app.nodes.attachNodeCallback((node, isStart) => {
    if (isStart) {
      if (isElementNode(node) && node.scrollLeft + node.scrollTop > 0) {
        nodeScroll.set(node, [node.scrollLeft, node.scrollTop]);
      } else if (isDocument(node)) {
        nodeScroll.set(node, getDocumentScroll(node));
      }
    }
    if (isRootNode(node)) {
      app.nodes.attachNodeListener(node, "scroll", (e) => {
        setNodeScroll(e.target);
      });
    }
  });
  app.attachEventListener(document, "scroll", (e) => {
    const target = e.target;
    if (target === document) {
      documentScroll = true;
      return;
    }
    setNodeScroll(target);
  });
  app.ticker.attach(() => {
    if (documentScroll) {
      sendSetViewportScroll();
      documentScroll = false;
    }
    nodeScroll.forEach(sendSetNodeScroll);
    nodeScroll.clear();
  }, 5, false);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/viewport.js
function viewport_default(app) {
  let url, width, height;
  let navigationStart;
  let referrer = document.referrer;
  const sendSetPageLocation = app.safe(() => {
    const { URL: URL2 } = document;
    if (URL2 !== url) {
      url = URL2;
      app.send(SetPageLocation(url, referrer, navigationStart, document.title));
      navigationStart = 0;
      referrer = url;
    }
  });
  const sendSetViewportSize = app.safe(() => {
    const { innerWidth, innerHeight } = window;
    if (innerWidth !== width || innerHeight !== height) {
      width = innerWidth;
      height = innerHeight;
      app.send(SetViewportSize(width, height));
    }
  });
  const sendSetPageVisibility = document.hidden === void 0 ? Function.prototype : app.safe(() => app.send(SetPageVisibility(document.hidden)));
  app.attachStartCallback(() => {
    url = null;
    navigationStart = getTimeOrigin();
    width = height = -1;
    sendSetPageLocation();
    sendSetViewportSize();
    sendSetPageVisibility();
  });
  if (document.hidden !== void 0) {
    app.attachEventListener(document, "visibilitychange", sendSetPageVisibility, false, false);
  }
  app.ticker.attach(sendSetPageLocation, 1, false);
  app.ticker.attach(sendSetViewportSize, 5, false);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/constructedStyleSheets.js
function hasAdoptedSS(node) {
  return isRootNode(node) && // @ts-ignore
  !!node.adoptedStyleSheets;
}
var _id = 15;
function nextID() {
  return _id++;
}
var styleSheetIDMap = /* @__PURE__ */ new Map();
function constructedStyleSheets_default(app) {
  if (app === null) {
    return;
  }
  if (!hasAdoptedSS(document)) {
    return;
  }
  const styleSheetIDMap2 = /* @__PURE__ */ new Map();
  const adoptedStyleSheetsOwnings = /* @__PURE__ */ new Map();
  const sendAdoptedStyleSheetsUpdate = (root) => setTimeout(() => {
    let nodeID = app.nodes.getID(root);
    if (root === document) {
      nodeID = 0;
    }
    if (nodeID === void 0) {
      return;
    }
    let pastOwning = adoptedStyleSheetsOwnings.get(nodeID);
    if (!pastOwning) {
      pastOwning = [];
    }
    const nowOwning = [];
    const styleSheets = root.adoptedStyleSheets;
    if (styleSheets && Symbol.iterator in styleSheets) {
      for (const s of styleSheets) {
        let sheetID = styleSheetIDMap2.get(s);
        const init = !sheetID;
        if (!sheetID) {
          sheetID = nextID();
          styleSheetIDMap2.set(s, sheetID);
        }
        if (!pastOwning.includes(sheetID)) {
          app.send(AdoptedSSAddOwner(sheetID, nodeID));
        }
        if (init) {
          const rules = s.cssRules;
          for (let i = 0; i < rules.length; i++) {
            app.send(AdoptedSSInsertRuleURLBased(sheetID, rules[i].cssText, i, app.getBaseHref()));
          }
        }
        nowOwning.push(sheetID);
      }
    }
    if (Symbol.iterator in pastOwning) {
      for (const sheetID of pastOwning) {
        if (!nowOwning.includes(sheetID)) {
          app.send(AdoptedSSRemoveOwner(sheetID, nodeID));
        }
      }
    }
    adoptedStyleSheetsOwnings.set(nodeID, nowOwning);
  }, 20);
  function patchAdoptedStyleSheets(prototype) {
    const nativeAdoptedStyleSheetsDescriptor = Object.getOwnPropertyDescriptor(prototype, "adoptedStyleSheets");
    if (nativeAdoptedStyleSheetsDescriptor) {
      Object.defineProperty(prototype, "adoptedStyleSheets", {
        ...nativeAdoptedStyleSheetsDescriptor,
        set: function(value) {
          const retVal = nativeAdoptedStyleSheetsDescriptor.set.call(this, value);
          sendAdoptedStyleSheetsUpdate(this);
          return retVal;
        }
      });
    }
  }
  const patchContext = (context) => {
    if (context.__openreplay_adpss_patched__) {
      return;
    } else {
      context.__openreplay_adpss_patched__ = true;
    }
    patchAdoptedStyleSheets(context.Document.prototype);
    patchAdoptedStyleSheets(context.ShadowRoot.prototype);
    const { replace, replaceSync } = context.CSSStyleSheet.prototype;
    context.CSSStyleSheet.prototype.replace = function(text) {
      return replace.call(this, text).then((sheet) => {
        const sheetID = styleSheetIDMap2.get(this);
        if (sheetID) {
          app.send(AdoptedSSReplaceURLBased(sheetID, text, app.getBaseHref()));
        }
        return sheet;
      });
    };
    context.CSSStyleSheet.prototype.replaceSync = function(text) {
      const sheetID = styleSheetIDMap2.get(this);
      if (sheetID) {
        app.send(AdoptedSSReplaceURLBased(sheetID, text, app.getBaseHref()));
      }
      return replaceSync.call(this, text);
    };
  };
  patchContext(window);
  app.observer.attachContextCallback(app.safe(patchContext));
  app.attachStopCallback(() => {
    styleSheetIDMap2.clear();
    adoptedStyleSheetsOwnings.clear();
  });
  app.attachStartCallback(() => {
    sendAdoptedStyleSheetsUpdate(document);
  });
  app.nodes.attachNodeCallback((node) => {
    if (hasAdoptedSS(node)) {
      sendAdoptedStyleSheetsUpdate(node);
    }
  });
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/cssrules.js
function cssrules_default(app) {
  if (app === null) {
    return;
  }
  if (!window.CSSStyleSheet) {
    app.send(TechnicalInfo("no_stylesheet_prototype_in_window", ""));
    return;
  }
  const sendInsertDeleteRule = app.safe((sheet, index2, rule) => {
    const sheetID = styleSheetIDMap.get(sheet);
    if (!sheetID) {
      return;
    }
    if (typeof rule === "string") {
      app.send(AdoptedSSInsertRuleURLBased(sheetID, rule, index2, app.getBaseHref()));
    } else {
      app.send(AdoptedSSDeleteRule(sheetID, index2));
    }
  });
  const sendReplaceGroupingRule = app.safe((rule) => {
    let topmostRule = rule;
    while (topmostRule.parentRule) {
      topmostRule = topmostRule.parentRule;
    }
    const sheet = topmostRule.parentStyleSheet;
    if (!sheet) {
      app.debug.warn("No parent StyleSheet found for", topmostRule, rule);
      return;
    }
    const sheetID = styleSheetIDMap.get(sheet);
    if (!sheetID) {
      app.debug.warn("No sheedID found for", sheet, styleSheetIDMap);
      return;
    }
    const cssText = topmostRule.cssText;
    const ruleList = sheet.cssRules;
    const idx = Array.from(ruleList).indexOf(topmostRule);
    if (idx >= 0) {
      app.send(AdoptedSSInsertRuleURLBased(sheetID, cssText, idx, app.getBaseHref()));
      app.send(AdoptedSSDeleteRule(sheetID, idx + 1));
    } else {
      app.debug.warn("Rule index not found in", sheet, topmostRule);
    }
  });
  const patchContext = app.safe((context) => {
    const { insertRule, deleteRule } = context.CSSStyleSheet.prototype;
    const { insertRule: groupInsertRule, deleteRule: groupDeleteRule } = context.CSSGroupingRule.prototype;
    context.CSSStyleSheet.prototype.insertRule = function(rule, index2 = 0) {
      sendInsertDeleteRule(this, index2, rule);
      return insertRule.call(this, rule, index2);
    };
    context.CSSStyleSheet.prototype.deleteRule = function(index2) {
      sendInsertDeleteRule(this, index2);
      return deleteRule.call(this, index2);
    };
    context.CSSGroupingRule.prototype.insertRule = function(rule, index2 = 0) {
      const result = groupInsertRule.call(this, rule, index2);
      sendReplaceGroupingRule(this);
      return result;
    };
    context.CSSGroupingRule.prototype.deleteRule = function(index2 = 0) {
      const result = groupDeleteRule.call(this, index2);
      sendReplaceGroupingRule(this);
      return result;
    };
  });
  patchContext(window);
  app.observer.attachContextCallback(patchContext);
  app.nodes.attachNodeCallback((node) => {
    if (!hasTag(node, "style") || !node.sheet) {
      return;
    }
    if (node.textContent !== null && node.textContent.trim().length > 0) {
      return;
    }
    const nodeID = app.nodes.getID(node);
    if (!nodeID) {
      return;
    }
    const sheet = node.sheet;
    const sheetID = nextID();
    styleSheetIDMap.set(sheet, sheetID);
    app.send(AdoptedSSAddOwner(sheetID, nodeID));
    const rules = sheet.cssRules;
    for (let i = 0; i < rules.length; i++) {
      sendInsertDeleteRule(sheet, i, rules[i].cssText);
    }
  });
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/focus.js
function focus_default(app) {
  function sendSetNodeFocus(n) {
    const id2 = app.nodes.getID(n);
    if (id2 !== void 0) {
      app.send(SetNodeFocus(id2));
    }
  }
  let blurred = false;
  app.nodes.attachNodeCallback((node) => {
    if (!hasTag(node, "body")) {
      return;
    }
    app.nodes.attachNodeListener(node, "focus", (e) => {
      if (!isNode(e.target)) {
        return;
      }
      sendSetNodeFocus(e.target);
      blurred = false;
    });
    app.nodes.attachNodeListener(node, "blur", (e) => {
      if (e.relatedTarget === null) {
        blurred = true;
        setTimeout(() => {
          if (blurred) {
            app.send(SetNodeFocus(-1));
          }
        }, 0);
      }
    });
  });
  app.attachStartCallback(() => {
    let elem = document.activeElement;
    while (elem && hasTag(elem, "iframe") && elem.contentDocument) {
      elem = elem.contentDocument.activeElement;
    }
    if (elem && elem !== elem.ownerDocument.body) {
      sendSetNodeFocus(elem);
    }
  }, true);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/fonts.js
function fonts_default(app) {
  if (!window.FontFace) {
    return;
  }
  const docFonts = /* @__PURE__ */ new Map();
  const patchWindow = (wnd) => {
    class FontFaceInterceptor extends wnd.FontFace {
      constructor(...args) {
        if (typeof args[1] === "string") {
          let desc = "";
          if (args[2]) {
            app.safe(() => {
              desc = JSON.stringify(args[2]);
            });
          }
          const ffData = [args[0], args[1], desc];
          const ffDataArr = docFonts.get(wnd.document) || [];
          ffDataArr.push(ffData);
          docFonts.set(wnd.document, ffDataArr);
          const parentID = wnd === window ? 0 : app.nodes.getID(wnd.document);
          if (parentID === void 0) {
            return;
          }
          if (app.active()) {
            app.send(LoadFontFace(parentID, ...ffData));
          }
        }
        super(...args);
      }
    }
    wnd.FontFace = FontFaceInterceptor;
  };
  app.observer.attachContextCallback(patchWindow);
  patchWindow(window);
  app.nodes.attachNodeCallback(app.safe((node) => {
    if (!isDocument(node)) {
      return;
    }
    const ffDataArr = docFonts.get(node);
    if (!ffDataArr) {
      return;
    }
    const parentID = node.defaultView === window ? 0 : app.nodes.getID(node);
    if (parentID === void 0) {
      return;
    }
    ffDataArr.forEach((ffData) => {
      app.send(LoadFontFace(parentID, ...ffData));
    });
  }));
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/axiosSpy.js
function axiosSpy_default(app, instance, opts, sanitize, stringify) {
  app.debug.log("Openreplay: attaching axios spy to instance", instance);
  function captureResponseData(axiosResponseObj) {
    app.debug.log("Openreplay: capturing axios response data", axiosResponseObj);
    const { headers: reqHs, data: reqData, method, url, baseURL } = axiosResponseObj.config;
    const { data: rData, headers: rHs, status: globStatus, response } = axiosResponseObj;
    const { data: resData, headers: resHs, status: resStatus } = response || {};
    const ihOpt = opts.ignoreHeaders;
    const isHIgnoring = Array.isArray(ihOpt) ? (name) => ihOpt.includes(name) : () => ihOpt;
    function writeHeader(hsObj, header) {
      if (!isHIgnoring(header[0])) {
        hsObj[header[0]] = header[1];
      }
    }
    let requestHs = {};
    let responseHs = {};
    if (reqHs.toJSON) {
      requestHs = reqHs.toJSON();
    } else if (reqHs instanceof Headers) {
      reqHs.forEach((v, n) => writeHeader(requestHs, [n, v]));
    } else if (Array.isArray(reqHs)) {
      reqHs.forEach((h) => writeHeader(requestHs, h));
    } else if (typeof reqHs === "object") {
      Object.entries(reqHs).forEach((h) => writeHeader(requestHs, h));
    }
    const usedResHeader = resHs ? resHs : rHs;
    if (usedResHeader.toJSON) {
      responseHs = usedResHeader.toJSON();
    } else if (usedResHeader instanceof Headers) {
      usedResHeader.forEach((v, n) => writeHeader(responseHs, [n, v]));
    } else if (Array.isArray(usedResHeader)) {
      usedResHeader.forEach((h) => writeHeader(responseHs, h));
    } else if (typeof usedResHeader === "object") {
      Object.entries(usedResHeader).forEach(([n, v]) => {
        if (!isHIgnoring(n))
          responseHs[n] = v;
      });
    }
    const reqResInfo = sanitize({
      url,
      method: method || "",
      status: globStatus || resStatus || 0,
      request: {
        headers: requestHs,
        body: reqData
      },
      response: {
        headers: responseHs,
        body: resData || rData
      }
    });
    if (!reqResInfo) {
      app.debug.log("Openreplay: empty request/response info, skipping");
      return;
    }
    const requestStart = axiosResponseObj.config.__openreplay_timing;
    const duration = performance.now() - requestStart;
    app.debug.log("Openreplay: final req object", reqResInfo);
    app.send(NetworkRequest("xhr", String(method), String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), reqResInfo.status, requestStart + getTimeOrigin(), duration, 0));
  }
  function getStartTime(config2) {
    app.debug.log("Openreplay: capturing API request", config2);
    config2.__openreplay_timing = performance.now();
    if (opts.sessionTokenHeader) {
      const header = typeof opts.sessionTokenHeader === "string" ? opts.sessionTokenHeader : "X-OpenReplay-Session-Token";
      const headerValue = app.getSessionToken();
      if (headerValue) {
        config2.headers.set(header, headerValue);
      }
    }
    return config2;
  }
  function captureNetworkRequest(response) {
    if (opts.failuresOnly)
      return response;
    captureResponseData(response);
    return response;
  }
  function captureNetworkError(error) {
    app.debug.log("Openreplay: capturing API request error", error);
    if (isAxiosError(error) && Boolean(error.response)) {
      captureResponseData(error.response);
    } else if (error instanceof Error) {
      app.send(getExceptionMessage(error, []));
    }
    return Promise.reject(error);
  }
  function logRequestError(ev) {
    app.debug.log("Openreplay: failed API request, skipping", ev);
  }
  const reqInt = instance.interceptors.request.use(getStartTime, logRequestError, {
    synchronous: true
  });
  const resInt = instance.interceptors.response.use(captureNetworkRequest, captureNetworkError, {
    synchronous: true
  });
  app.attachStopCallback(() => {
    var _a3, _b2, _c, _d;
    (_b2 = (_a3 = instance.interceptors.request).eject) == null ? void 0 : _b2.call(_a3, reqInt);
    (_d = (_c = instance.interceptors.response).eject) == null ? void 0 : _d.call(_c, resInt);
  });
}
function isAxiosError(payload) {
  return isObject(payload) && payload.isAxiosError === true;
}
function isObject(thing) {
  return thing !== null && typeof thing === "object";
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/networkMessage.js
var RequestState;
(function(RequestState2) {
  RequestState2[RequestState2["UNSENT"] = 0] = "UNSENT";
  RequestState2[RequestState2["OPENED"] = 1] = "OPENED";
  RequestState2[RequestState2["HEADERS_RECEIVED"] = 2] = "HEADERS_RECEIVED";
  RequestState2[RequestState2["LOADING"] = 3] = "LOADING";
  RequestState2[RequestState2["DONE"] = 4] = "DONE";
})(RequestState || (RequestState = {}));
var NetworkMessage = class {
  constructor(ignoredHeaders = [], setSessionTokenHeader, sanitize) {
    this.ignoredHeaders = ignoredHeaders;
    this.setSessionTokenHeader = setSessionTokenHeader;
    this.sanitize = sanitize;
    this.id = "";
    this.name = "";
    this.method = "";
    this.url = "";
    this.status = 0;
    this.statusText = "";
    this.cancelState = 0;
    this.readyState = 0;
    this.header = {};
    this.responseType = "";
    this.requestHeader = {};
    this.responseSize = 0;
    this.responseSizeText = "";
    this.startTime = 0;
    this.endTime = 0;
    this.duration = 0;
    this.getData = {};
    this.requestData = null;
  }
  getMessage() {
    const { reqHs, resHs } = this.writeHeaders();
    const request = {
      headers: reqHs,
      body: this.method === "GET" ? JSON.stringify(this.getData) : this.requestData
    };
    const response = { headers: resHs, body: this.response };
    const messageInfo = this.sanitize({
      url: this.url,
      method: this.method,
      status: this.status,
      request,
      response
    });
    if (!messageInfo)
      return;
    return NetworkRequest(this.requestType, messageInfo.method, messageInfo.url, JSON.stringify(messageInfo.request), JSON.stringify(messageInfo.response), messageInfo.status, this.startTime + getTimeOrigin(), this.duration, this.responseSize);
  }
  writeHeaders() {
    const reqHs = {};
    Object.entries(this.requestHeader).forEach(([key, value]) => {
      if (this.isHeaderIgnored(key))
        return;
      reqHs[key] = value;
    });
    this.setSessionTokenHeader((name, value) => {
      reqHs[name] = value;
    });
    const resHs = {};
    Object.entries(this.header).forEach(([key, value]) => {
      if (this.isHeaderIgnored(key))
        return;
      resHs[key] = value;
    });
    return { reqHs, resHs };
  }
  isHeaderIgnored(key) {
    if (Array.isArray(this.ignoredHeaders)) {
      return this.ignoredHeaders.map((k) => k.toLowerCase()).includes(key.toLowerCase());
    } else {
      return this.ignoredHeaders;
    }
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/utils.js
var getStringResponseByType = (responseType, response) => {
  let result = "";
  switch (responseType) {
    case "":
    case "text":
    case "json":
      if (typeof response == "string") {
        result = response;
      } else if (isPureObject(response) || Array.isArray(response)) {
        result = JSON.stringify(response);
      } else if (typeof response !== "undefined") {
        result = Object.prototype.toString.call(response);
      }
      break;
    case "blob":
    case "document":
    case "arraybuffer":
    default:
      if (typeof response !== "undefined") {
        result = Object.prototype.toString.call(response);
      }
      break;
  }
  return result;
};
var genStringBody = (body) => {
  if (!body) {
    return null;
  }
  let result;
  if (typeof body === "string") {
    if (body[0] === "{" || body[0] === "[") {
      result = body;
    }
    const arr = body.split("&");
    if (arr.length === 1) {
      result = body;
    } else {
      result = arr.join(",");
    }
  } else if (isIterable(body)) {
    const arr = [];
    for (const [key, value] of body) {
      arr.push(`${key}=${typeof value === "string" ? value : "[object Object]"}`);
    }
    result = arr.join(",");
  } else if (body instanceof Blob || body instanceof ReadableStream || body instanceof ArrayBuffer) {
    result = "byte data";
  } else if (isPureObject(body)) {
    result = body;
  } else {
    result = `can't parse body ${typeof body}`;
  }
  return result;
};
var genGetDataByUrl = (url, getData = {}) => {
  if (!isPureObject(getData)) {
    getData = {};
  }
  let query = url ? url.split("?") : [];
  query.shift();
  if (query.length > 0) {
    query = query.join("?").split("&");
    for (const q of query) {
      const kv = q.split("=");
      try {
        getData[kv[0]] = decodeURIComponent(kv[1]);
      } catch (e) {
        getData[kv[0]] = kv[1];
      }
    }
  }
  return getData;
};
function isPureObject(input) {
  return null !== input && typeof input === "object";
}
function isIterable(value) {
  if (value === null || value === void 0) {
    return false;
  }
  if (ArrayBuffer.isView(value)) {
    return false;
  }
  return typeof Symbol !== "undefined" && typeof value[Symbol.iterator] === "function";
}
function formatByteSize(bytes) {
  if (bytes <= 0) {
    return "";
  }
  if (bytes >= 1e3 * 1e3) {
    return (bytes / 1e3 / 1e3).toFixed(1) + " MB";
  }
  if (bytes >= 1e3) {
    return (bytes / 1e3).toFixed(1) + " KB";
  }
  return `${bytes}B`;
}
var getURL = (urlString) => {
  if (urlString.startsWith("//")) {
    const baseUrl = new URL(window.location.href);
    urlString = `${baseUrl.protocol}${urlString}`;
  }
  if (urlString.startsWith("http")) {
    return new URL(urlString);
  } else {
    return new URL(urlString, window.location.href);
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/fetchProxy.js
var ResponseProxyHandler = class {
  constructor(resp, item) {
    this.resp = resp;
    this.item = item;
    this.mockReader();
  }
  set(target, key, value) {
    return Reflect.set(target, key, value);
  }
  get(target, key) {
    const value = Reflect.get(target, key);
    switch (key) {
      case "arrayBuffer":
      case "blob":
      case "formData":
      case "json":
      case "text":
        return () => {
          this.item.responseType = key.toLowerCase();
          return value.apply(target).then((resp) => {
            this.item.response = getStringResponseByType(this.item.responseType, resp);
            return resp;
          });
        };
    }
    if (typeof value === "function") {
      return value.bind(target);
    } else {
      return value;
    }
  }
  mockReader() {
    let readerReceivedValue;
    if (!this.resp.body) {
      return;
    }
    if (typeof this.resp.body.getReader !== "function") {
      return;
    }
    const _getReader = this.resp.body.getReader;
    this.resp.body.getReader = () => {
      const reader = _getReader.apply(this.resp.body);
      if (this.item.readyState === RequestState.DONE) {
        return reader;
      }
      const _read = reader.read;
      const _cancel = reader.cancel;
      this.item.responseType = "arraybuffer";
      reader.read = () => {
        return _read.apply(reader).then((result) => {
          if (!readerReceivedValue) {
            readerReceivedValue = new Uint8Array(result.value);
          } else {
            const newValue = new Uint8Array(readerReceivedValue.length + result.value.length);
            newValue.set(readerReceivedValue);
            newValue.set(result.value, readerReceivedValue.length);
            readerReceivedValue = newValue;
          }
          this.item.endTime = performance.now();
          this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);
          this.item.readyState = result.done ? 4 : 3;
          this.item.statusText = result.done ? String(this.item.status) : "Loading";
          this.item.responseSize = readerReceivedValue.length;
          this.item.responseSizeText = formatByteSize(this.item.responseSize);
          if (result.done) {
            this.item.response = getStringResponseByType(this.item.responseType, readerReceivedValue);
          }
          return result;
        });
      };
      reader.cancel = (...args) => {
        this.item.cancelState = 2;
        this.item.statusText = "Cancel";
        this.item.endTime = performance.now();
        this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);
        this.item.response = getStringResponseByType(this.item.responseType, readerReceivedValue);
        return _cancel.apply(reader, args);
      };
      return reader;
    };
  }
};
var FetchProxyHandler = class {
  constructor(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
    this.ignoredHeaders = ignoredHeaders;
    this.setSessionTokenHeader = setSessionTokenHeader;
    this.sanitize = sanitize;
    this.sendMessage = sendMessage;
    this.isServiceUrl = isServiceUrl;
    this.tokenUrlMatcher = tokenUrlMatcher;
  }
  apply(target, _, argsList) {
    const input = argsList[0];
    const init = argsList[1];
    if (!input || // @ts-ignore
    typeof input !== "string" && !(input == null ? void 0 : input.url)) {
      return target.apply(window, argsList);
    }
    const isORUrl = input instanceof URL || typeof input === "string" ? this.isServiceUrl(String(input)) : this.isServiceUrl(String(input.url));
    if (isORUrl) {
      return target.apply(window, argsList);
    }
    const item = new NetworkMessage(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);
    this.beforeFetch(item, input, init);
    this.setSessionTokenHeader((name, value) => {
      if (this.tokenUrlMatcher !== void 0) {
        if (!this.tokenUrlMatcher(item.url)) {
          return;
        }
      }
      if (argsList[1] === void 0 && argsList[0] instanceof Request) {
        return argsList[0].headers.append(name, value);
      } else {
        if (!argsList[1])
          argsList[1] = {};
        if (argsList[1].headers === void 0) {
          argsList[1] = { ...argsList[1], headers: {} };
        }
        if (argsList[1].headers instanceof Headers) {
          argsList[1].headers.append(name, value);
        } else if (Array.isArray(argsList[1].headers)) {
          argsList[1].headers.push([name, value]);
        } else {
          argsList[1].headers[name] = value;
        }
      }
    });
    return target.apply(window, argsList).then(this.afterFetch(item)).catch((e) => {
      item.endTime = performance.now();
      item.duration = item.endTime - (item.startTime || item.endTime);
      throw e;
    });
  }
  beforeFetch(item, input, init) {
    let url, method = "GET", requestHeader = {};
    if (typeof input === "string") {
      method = (init == null ? void 0 : init.method) || "GET";
      url = getURL(input);
      requestHeader = (init == null ? void 0 : init.headers) || {};
    } else {
      method = input.method || "GET";
      url = getURL(input.url);
      requestHeader = input.headers;
    }
    item.method = method;
    item.requestType = "fetch";
    item.requestHeader = requestHeader;
    item.url = url.toString();
    item.name = (url.pathname.split("/").pop() || "") + url.search;
    item.status = 0;
    item.statusText = "Pending";
    item.readyState = 1;
    if (!item.startTime) {
      item.startTime = performance.now();
    }
    if (Object.prototype.toString.call(requestHeader) === "[object Headers]") {
      item.requestHeader = {};
      for (const [key, value] of requestHeader) {
        item.requestHeader[key] = value;
      }
    } else {
      item.requestHeader = requestHeader;
    }
    if (url.search && url.searchParams) {
      item.getData = {};
      for (const [key, value] of url.searchParams) {
        item.getData[key] = value;
      }
    }
    if (init == null ? void 0 : init.body) {
      item.requestData = genStringBody(init.body);
    }
  }
  afterFetch(item) {
    return (resp) => {
      item.endTime = performance.now();
      item.duration = item.endTime - (item.startTime || item.endTime);
      item.status = resp.status;
      item.statusText = String(resp.status);
      let isChunked = false;
      item.header = {};
      for (const [key, value] of resp.headers) {
        item.header[key] = value;
        isChunked = value.toLowerCase().indexOf("chunked") > -1 ? true : isChunked;
      }
      if (isChunked) {
        item.readyState = 3;
      } else {
        item.readyState = 4;
        this.handleResponseBody(resp.clone(), item).then((responseValue) => {
          item.responseSize = typeof responseValue === "string" ? responseValue.length : responseValue.byteLength;
          item.responseSizeText = formatByteSize(item.responseSize);
          item.response = getStringResponseByType(item.responseType, responseValue);
          const msg = item.getMessage();
          if (msg) {
            this.sendMessage(msg);
          }
        }).catch((e) => {
          if (e.name !== "AbortError") {
            throw e;
          } else {
          }
        });
      }
      return new Proxy(resp, new ResponseProxyHandler(resp, item));
    };
  }
  handleResponseBody(resp, item) {
    const contentType = resp.headers.get("content-type");
    if (contentType && contentType.includes("application/json")) {
      item.responseType = "json";
      return resp.text();
    } else if (contentType && (contentType.includes("text/html") || contentType.includes("text/plain"))) {
      item.responseType = "text";
      return resp.text();
    } else {
      item.responseType = "arraybuffer";
      return resp.arrayBuffer();
    }
  }
};
var FetchProxy = class {
  static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
    return new Proxy(fetch, new FetchProxyHandler(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher));
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/xhrProxy.js
var XHRProxyHandler = class {
  constructor(XMLReq, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
    this.ignoredHeaders = ignoredHeaders;
    this.setSessionTokenHeader = setSessionTokenHeader;
    this.sanitize = sanitize;
    this.sendMessage = sendMessage;
    this.isServiceUrl = isServiceUrl;
    this.tokenUrlMatcher = tokenUrlMatcher;
    this.XMLReq = XMLReq;
    this.XMLReq.onreadystatechange = () => {
      this.onReadyStateChange();
    };
    this.XMLReq.onabort = () => {
      this.onAbort();
    };
    this.XMLReq.ontimeout = () => {
      this.onTimeout();
    };
    this.item = new NetworkMessage(ignoredHeaders, setSessionTokenHeader, sanitize);
    this.item.requestType = "xhr";
  }
  get(target, key) {
    switch (key) {
      case "open":
        return this.getOpen(target);
      case "send":
        this.setSessionTokenHeader((name, value2) => {
          if (this.tokenUrlMatcher !== void 0) {
            if (!this.tokenUrlMatcher(this.item.url)) {
              return;
            }
          }
          target.setRequestHeader(name, value2);
        });
        return this.getSend(target);
      case "setRequestHeader":
        return this.getSetRequestHeader(target);
      default:
        const value = Reflect.get(target, key);
        if (typeof value === "function") {
          return value.bind(target);
        } else {
          return value;
        }
    }
  }
  set(target, key, value) {
    switch (key) {
      case "onreadystatechange":
        return this.setOnReadyStateChange(target, key, value);
      case "onabort":
        return this.setOnAbort(target, key, value);
      case "ontimeout":
        return this.setOnTimeout(target, key, value);
      default:
    }
    return Reflect.set(target, key, value);
  }
  onReadyStateChange() {
    if (this.item.url && this.isServiceUrl(this.item.url))
      return;
    this.item.readyState = this.XMLReq.readyState;
    this.item.responseType = this.XMLReq.responseType;
    this.item.endTime = performance.now();
    this.item.duration = this.item.endTime - this.item.startTime;
    this.updateItemByReadyState();
    setTimeout(() => {
      this.item.response = getStringResponseByType(this.item.responseType, this.item.response);
    }, 0);
    if (this.XMLReq.readyState === RequestState.DONE) {
      const msg = this.item.getMessage();
      if (msg) {
        this.sendMessage(msg);
      }
    }
  }
  onAbort() {
    this.item.cancelState = 1;
    this.item.statusText = "Abort";
    const msg = this.item.getMessage();
    if (msg) {
      this.sendMessage(msg);
    }
  }
  onTimeout() {
    this.item.cancelState = 3;
    this.item.statusText = "Timeout";
    const msg = this.item.getMessage();
    if (msg) {
      this.sendMessage(msg);
    }
  }
  getOpen(target) {
    const targetFunction = Reflect.get(target, "open");
    return (...args) => {
      var _a3, _b2;
      const method = args[0];
      const url = args[1];
      this.item.method = method ? method.toUpperCase() : "GET";
      this.item.url = ((_a3 = url.toString) == null ? void 0 : _a3.call(url)) || "";
      this.item.name = ((_b2 = this.item.url) == null ? void 0 : _b2.replace(new RegExp("/*$"), "").split("/").pop()) ?? "";
      this.item.getData = genGetDataByUrl(this.item.url, {});
      return targetFunction.apply(target, args);
    };
  }
  getSend(target) {
    const targetFunction = Reflect.get(target, "send");
    return (...args) => {
      const data = args[0];
      this.item.requestData = genStringBody(data);
      return targetFunction.apply(target, args);
    };
  }
  getSetRequestHeader(target) {
    const targetFunction = Reflect.get(target, "setRequestHeader");
    return (...args) => {
      if (!this.item.requestHeader) {
        this.item.requestHeader = {};
      }
      this.item.requestHeader[args[0]] = args[1];
      return targetFunction.apply(target, args);
    };
  }
  setOnReadyStateChange(target, key, orscFunction) {
    return Reflect.set(target, key, (...args) => {
      this.onReadyStateChange();
      orscFunction == null ? void 0 : orscFunction.apply(target, args);
    });
  }
  setOnAbort(target, key, oaFunction) {
    return Reflect.set(target, key, (...args) => {
      this.onAbort();
      oaFunction.apply(target, args);
    });
  }
  setOnTimeout(target, key, otFunction) {
    return Reflect.set(target, key, (...args) => {
      this.onTimeout();
      otFunction.apply(target, args);
    });
  }
  /**
   * Update item's properties according to readyState.
   */
  updateItemByReadyState() {
    switch (this.XMLReq.readyState) {
      case RequestState.UNSENT:
      case RequestState.OPENED:
        this.item.status = RequestState.UNSENT;
        this.item.statusText = "Pending";
        if (!this.item.startTime) {
          this.item.startTime = performance.now();
        }
        break;
      case RequestState.HEADERS_RECEIVED:
        this.item.status = this.XMLReq.status;
        this.item.statusText = "Loading";
        this.item.header = {};
        const header = this.XMLReq.getAllResponseHeaders() || "", headerArr = header.split("\n");
        for (let i = 0; i < headerArr.length; i++) {
          const line = headerArr[i];
          if (!line) {
            continue;
          }
          const arr = line.split(": ");
          const key = arr[0];
          this.item.header[key] = arr.slice(1).join(": ");
        }
        break;
      case RequestState.LOADING:
        this.item.status = this.XMLReq.status;
        this.item.statusText = "Loading";
        if (!!this.XMLReq.response && this.XMLReq.response.length) {
          this.item.responseSize = this.XMLReq.response.length;
          this.item.responseSizeText = formatByteSize(this.item.responseSize);
        }
        break;
      case RequestState.DONE:
        this.item.status = this.XMLReq.status || this.item.status || 0;
        this.item.statusText = String(this.item.status);
        this.item.endTime = performance.now();
        this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);
        this.item.response = this.XMLReq.response;
        if (!!this.XMLReq.response && this.XMLReq.response.length) {
          this.item.responseSize = this.XMLReq.response.length;
          this.item.responseSizeText = formatByteSize(this.item.responseSize);
        }
        break;
      default:
        this.item.status = this.XMLReq.status;
        this.item.statusText = "Unknown";
        break;
    }
  }
};
var XHRProxy = class {
  static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
    return new Proxy(XMLHttpRequest, {
      construct(original) {
        const XMLReq = new original();
        return new Proxy(XMLReq, new XHRProxyHandler(XMLReq, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher));
      }
    });
  }
};

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/beaconProxy.js
var getContentType = (data) => {
  if (data instanceof Blob) {
    return data.type;
  }
  if (data instanceof FormData) {
    return "multipart/form-data";
  }
  if (data instanceof URLSearchParams) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  return "text/plain;charset=UTF-8";
};
var BeaconProxyHandler = class {
  constructor(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl) {
    this.ignoredHeaders = ignoredHeaders;
    this.setSessionTokenHeader = setSessionTokenHeader;
    this.sanitize = sanitize;
    this.sendMessage = sendMessage;
    this.isServiceUrl = isServiceUrl;
  }
  apply(target, thisArg, argsList) {
    const urlString = argsList[0];
    const data = argsList[1];
    const item = new NetworkMessage(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);
    if (this.isServiceUrl(urlString)) {
      return target.apply(thisArg, argsList);
    }
    const url = getURL(urlString);
    item.method = "POST";
    item.url = urlString;
    item.name = (url.pathname.split("/").pop() || "") + url.search;
    item.requestType = "beacon";
    item.requestHeader = { "Content-Type": getContentType(data) };
    item.status = 0;
    item.statusText = "Pending";
    if (url.search && url.searchParams) {
      item.getData = {};
      for (const [key, value] of url.searchParams) {
        item.getData[key] = value;
      }
    }
    item.requestData = genStringBody(data);
    if (!item.startTime) {
      item.startTime = performance.now();
    }
    const isSuccess = target.apply(thisArg, argsList);
    if (isSuccess) {
      item.endTime = performance.now();
      item.duration = item.endTime - (item.startTime || item.endTime);
      item.status = 0;
      item.statusText = "Sent";
      item.readyState = 4;
    } else {
      item.status = 500;
      item.statusText = "Unknown";
    }
    const msg = item.getMessage();
    if (msg) {
      this.sendMessage(msg);
    }
    return isSuccess;
  }
};
var BeaconProxy = class _BeaconProxy {
  static hasSendBeacon() {
    return !!_BeaconProxy.origSendBeacon;
  }
  static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl) {
    if (!_BeaconProxy.hasSendBeacon()) {
      return void 0;
    }
    return new Proxy(_BeaconProxy.origSendBeacon, new BeaconProxyHandler(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl));
  }
};
var _a2;
BeaconProxy.origSendBeacon = (_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.sendBeacon;

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/Network/index.js
var getWarning = (api) => console.warn(`Openreplay: Can't find ${api} in global context. 
If you're using serverside rendering in your app, make sure that tracker is loaded dynamically, otherwise ${api} won't be tracked.`);
function setProxy(context, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
  var _a3;
  if (context.XMLHttpRequest) {
    context.XMLHttpRequest = XHRProxy.create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher);
  } else {
    getWarning("XMLHttpRequest");
  }
  if (context.fetch) {
    context.fetch = FetchProxy.create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher);
  } else {
    getWarning("fetch");
  }
  if ((_a3 = context == null ? void 0 : context.navigator) == null ? void 0 : _a3.sendBeacon) {
    context.navigator.sendBeacon = BeaconProxy.create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl);
  }
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/network.js
function getXHRRequestDataObject(xhr) {
  if (!xhr.__or_req_data__) {
    xhr.__or_req_data__ = { body: void 0, headers: {} };
  }
  return xhr.__or_req_data__;
}
function strMethod(method) {
  return typeof method === "string" ? method.toUpperCase() : "GET";
}
function network_default(app, opts = {}) {
  const options = Object.assign({
    failuresOnly: false,
    ignoreHeaders: ["cookie", "set-cookie", "authorization"],
    capturePayload: false,
    sessionTokenHeader: false,
    captureInIframes: true,
    axiosInstances: void 0,
    useProxy: true
  }, opts);
  if (options.useProxy === false) {
    app.debug.warn("Network module is migrating to proxy api, to gradually migrate and test it set useProxy to true");
  }
  const ignoreHeaders = options.ignoreHeaders;
  const isHIgnored = Array.isArray(ignoreHeaders) ? (name) => ignoreHeaders.includes(name) : () => ignoreHeaders;
  const stHeader = options.sessionTokenHeader === true ? "X-OpenReplay-SessionToken" : options.sessionTokenHeader;
  function setSessionTokenHeader(setRequestHeader) {
    if (stHeader) {
      const sessionToken = app.getSessionToken();
      if (sessionToken) {
        app.safe(setRequestHeader)(stHeader, sessionToken);
      }
    }
  }
  function sanitize(reqResInfo) {
    if (!options.capturePayload) {
      delete reqResInfo.request.body;
      delete reqResInfo.response.body;
    }
    if (options.sanitizer) {
      const resBody = reqResInfo.response.body;
      if (typeof resBody === "string") {
        try {
          reqResInfo.response.body = JSON.parse(resBody);
        } catch {
        }
      }
      return options.sanitizer(reqResInfo);
    }
    return reqResInfo;
  }
  function stringify(r) {
    if (r && typeof r.body !== "string") {
      try {
        r.body = JSON.stringify(r.body);
      } catch {
        r.body = "<unable to stringify>";
        app.notify.warn("Openreplay fetch couldn't stringify body:", r.body);
      }
    }
    return JSON.stringify(r);
  }
  const patchWindow = (context) => {
    if (options.useProxy) {
      return setProxy(context, options.ignoreHeaders, setSessionTokenHeader, sanitize, (message) => app.send(message), (url) => app.isServiceURL(url), options.tokenUrlMatcher);
    }
    const origFetch = context.fetch.bind(context);
    const trackFetch = (input, init = {}) => {
      if (!(typeof input === "string" || input instanceof URL) || app.isServiceURL(String(input))) {
        return origFetch(input, init);
      }
      setSessionTokenHeader(function(name, value) {
        if (init.headers === void 0) {
          init.headers = {};
        }
        if (init.headers instanceof Headers) {
          init.headers.append(name, value);
        } else if (Array.isArray(init.headers)) {
          init.headers.push([name, value]);
        } else {
          init.headers[name] = value;
        }
      });
      const startTime = performance.now();
      return origFetch(input, init).then((response) => {
        const duration = performance.now() - startTime;
        if (options.failuresOnly && response.status < 400) {
          return response;
        }
        const r = response.clone();
        r.text().then((text) => {
          const reqHs = {};
          const resHs = {};
          if (ignoreHeaders !== true) {
            const writeReqHeader = ([n, v]) => {
              if (!isHIgnored(n)) {
                reqHs[n] = v;
              }
            };
            if (init.headers instanceof Headers) {
              init.headers.forEach((v, n) => writeReqHeader([n, v]));
            } else if (Array.isArray(init.headers)) {
              init.headers.forEach(writeReqHeader);
            } else if (typeof init.headers === "object") {
              Object.entries(init.headers).forEach(writeReqHeader);
            }
            r.headers.forEach((v, n) => {
              if (!isHIgnored(n))
                resHs[n] = v;
            });
          }
          const method = strMethod(init.method);
          const reqResInfo = sanitize({
            url: String(input),
            method,
            status: r.status,
            request: {
              headers: reqHs,
              // @ts-ignore
              body: init.body || null
            },
            response: {
              headers: resHs,
              body: text
            }
          });
          if (!reqResInfo) {
            return;
          }
          app.send(NetworkRequest("fetch", method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), r.status, startTime + getTimeOrigin(), duration, 0));
        }).catch((e) => app.debug.error("Could not process Fetch response:", e));
        return response;
      });
    };
    context.fetch = trackFetch;
    const nativeOpen = context.XMLHttpRequest.prototype.open;
    const nativeSetRequestHeader = context.XMLHttpRequest.prototype.setRequestHeader;
    const nativeSend = context.XMLHttpRequest.prototype.send;
    function trackXMLHttpReqOpen(initMethod, url) {
      const xhr = this;
      setSessionTokenHeader((name, value) => xhr.setRequestHeader(name, value));
      let startTime = 0;
      xhr.addEventListener("loadstart", (e) => {
        startTime = e.timeStamp;
      });
      xhr.addEventListener("load", app.safe((e) => {
        const { headers: reqHs, body: reqBody } = getXHRRequestDataObject(xhr);
        const duration = startTime > 0 ? e.timeStamp - startTime : 0;
        const hString = xhr.getAllResponseHeaders() || "";
        const headersArr = hString.trim().split(/[\r\n]+/);
        const headerMap = {};
        headersArr.forEach(function(line) {
          const parts = line.split(": ");
          const header = parts.shift();
          if (!isHIgnored(header)) {
            headerMap[header] = parts.join(": ");
          }
        });
        const method = strMethod(initMethod);
        const reqResInfo = sanitize({
          url: String(url),
          method,
          status: xhr.status,
          request: {
            headers: reqHs,
            // @ts-ignore
            body: reqBody || null
          },
          response: {
            headers: headerMap,
            body: xhr.response
          }
        });
        if (!reqResInfo) {
          return;
        }
        app.send(NetworkRequest("xhr", method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), xhr.status, startTime + getTimeOrigin(), duration, 0));
      }));
      return nativeOpen.apply(this, arguments);
    }
    function trackXHRSend(body) {
      const rdo = getXHRRequestDataObject(this);
      rdo.body = body;
      return nativeSend.apply(this, arguments);
    }
    function trackSetReqHeader(name, value) {
      if (!isHIgnored(name)) {
        const rdo = getXHRRequestDataObject(this);
        rdo.headers[name] = value;
      }
      return nativeSetRequestHeader.apply(this, arguments);
    }
    if (!options.axiosInstances) {
      context.XMLHttpRequest.prototype.open = trackXMLHttpReqOpen;
      context.XMLHttpRequest.prototype.send = trackXHRSend;
      context.XMLHttpRequest.prototype.setRequestHeader = trackSetReqHeader;
    }
  };
  patchWindow(window);
  if (options.axiosInstances) {
    options.axiosInstances.forEach((axiosInstance) => {
      axiosSpy_default(app, axiosInstance, options, sanitize, stringify);
    });
  }
  if (options.captureInIframes) {
    app.observer.attachContextCallback(app.safe(patchWindow));
  }
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/selection.js
function selection(app) {
  app.attachEventListener(document, "selectionchange", () => {
    const selection2 = document.getSelection();
    if (selection2 !== null && !selection2.isCollapsed) {
      const selectionStart = app.nodes.getID(selection2.anchorNode);
      const selectionEnd = app.nodes.getID(selection2.focusNode);
      const selectedText = selection2.toString().replace(/\s+/g, " ");
      if (selectionStart && selectionEnd) {
        app.send(SelectionChange(selectionStart, selectionEnd, selectedText));
      }
    } else {
      app.send(SelectionChange(-1, -1, ""));
    }
  });
}
var selection_default = selection;

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/modules/tabs.js
function tabs_default(app) {
  function changeTab() {
    if (!document.hidden) {
      app.debug.log("Openreplay: tab change to" + app.session.getTabId());
      app.send(TabChange(app.session.getTabId()));
    }
  }
  app.attachEventListener(window, "focus", changeTab, false, false);
}

// node_modules/.pnpm/@openreplay+tracker@14.0.3/node_modules/@openreplay/tracker/lib/index.js
var Messages = messages_gen_exports;
var DOCS_SETUP = "/installation/javascript-sdk";
function processOptions(obj) {
  if (obj == null) {
    console.error(`OpenReplay: invalid options argument type. Please, check documentation on ${DOCS_HOST}${DOCS_SETUP}`);
    return false;
  }
  if (typeof obj.projectKey !== "string") {
    if (typeof obj.projectKey !== "number") {
      if (typeof obj.projectID !== "number") {
        console.error(`OpenReplay: projectKey is missing or wrong type (string is expected). Please, check ${DOCS_HOST}${DOCS_SETUP} for more information.`);
        return false;
      } else {
        obj.projectKey = obj.projectID.toString();
        deprecationWarn("`projectID` option", "`projectKey` option", DOCS_SETUP);
      }
    } else {
      console.warn("OpenReplay: projectKey is expected to have a string type.");
      obj.projectKey = obj.projectKey.toString();
    }
  }
  if (obj.sessionToken != null) {
    deprecationWarn("`sessionToken` option", "`sessionHash` start() option", "/");
  }
  return true;
}
var API = class {
  constructor(options) {
    var _a3;
    this.options = options;
    this.app = null;
    this.crossdomainMode = false;
    this.checkDoNotTrack = () => {
      return this.options.respectDoNotTrack && (navigator.doNotTrack == "1" || // @ts-ignore
      window.doNotTrack == "1");
    };
    this.signalStartIssue = (reason, missingApi) => {
      const doNotTrack2 = this.checkDoNotTrack();
      const req = new XMLHttpRequest();
      const orig = this.options.ingestPoint || DEFAULT_INGEST_POINT;
      req.open("POST", orig + "/v1/web/not-started");
      req.send(JSON.stringify({
        trackerVersion: "14.0.3",
        projectKey: this.options.projectKey,
        doNotTrack: doNotTrack2,
        reason: missingApi.length ? `missing api: ${missingApi.join(",")}` : reason
      }));
    };
    this.restartCanvasTracking = () => {
      if (this.app === null) {
        return;
      }
      this.app.restartCanvasTracking();
    };
    this.handleError = (e, metadata = {}) => {
      if (this.app === null) {
        return;
      }
      if (e instanceof Error) {
        const msg = getExceptionMessage(e, [], metadata);
        this.app.send(msg);
      } else if (e instanceof ErrorEvent || "PromiseRejectionEvent" in window && e instanceof PromiseRejectionEvent) {
        const msg = getExceptionMessageFromEvent(e, void 0, metadata);
        if (msg != null) {
          this.app.send(msg);
        }
      }
    };
    this.crossdomainMode = Boolean(inIframe() && ((_a3 = options.crossdomain) == null ? void 0 : _a3.enabled));
    if (!IN_BROWSER || !processOptions(options)) {
      return;
    }
    if (window.__OPENREPLAY__) {
      console.error("OpenReplay: one tracker instance has been initialised already");
      return;
    }
    if (!options.__DISABLE_SECURE_MODE && location.protocol !== "https:") {
      console.error("OpenReplay: Your website must be publicly accessible and running on SSL in order for OpenReplay to properly capture and replay the user session. You can disable this check by setting `__DISABLE_SECURE_MODE` option to `true` if you are testing in localhost. Keep in mind, that asset files on a local machine are not available to the outside world. This might affect tracking if you use css files.");
      return;
    }
    const doNotTrack = this.checkDoNotTrack();
    const failReason = [];
    const conditions = [
      "Map",
      "Set",
      "MutationObserver",
      "performance",
      "timing",
      "startsWith",
      "Blob",
      "Worker"
    ];
    if (doNotTrack) {
      failReason.push("doNotTrack");
    } else {
      for (const condition of conditions) {
        if (condition === "timing") {
          if ("performance" in window && !(condition in performance)) {
            failReason.push(condition);
            break;
          }
        } else if (condition === "startsWith") {
          if (!(condition in String.prototype)) {
            failReason.push(condition);
            break;
          }
        } else {
          if (!(condition in window)) {
            failReason.push(condition);
            break;
          }
        }
      }
    }
    if (failReason.length > 0) {
      const missingApi = failReason.join(",");
      console.error(`OpenReplay: browser doesn't support API required for tracking or doNotTrack is set to 1. Reason: ${missingApi}`);
      this.signalStartIssue("missing_api", failReason);
      return;
    }
    const app = new App(options.projectKey, options.sessionToken, options, this.signalStartIssue, this.crossdomainMode);
    this.app = app;
    if (!this.crossdomainMode) {
      viewport_default(app);
      connection_default(app);
      performance_default(app, options);
      tabs_default(app);
    }
    mouse_default(app, options.mouse);
    scroll_default(app, this.crossdomainMode);
    cssrules_default(app);
    constructedStyleSheets_default(app);
    console_default(app, options);
    exception_default(app, options);
    img_default(app);
    input_default(app, options);
    timing_default(app, options);
    focus_default(app);
    fonts_default(app);
    network_default(app, options.network);
    selection_default(app);
    window.__OPENREPLAY__ = this;
    if (options.flags && options.flags.onFlagsLoad) {
      this.onFlagsLoad(options.flags.onFlagsLoad);
    }
    const wOpen = window.open;
    if (options.autoResetOnWindowOpen || options.resetTabOnWindowOpen) {
      app.attachStartCallback(() => {
        const tabId = app.getTabId();
        const sessStorage = app.sessionStorage ?? window.sessionStorage;
        window.open = function(...args) {
          if (options.autoResetOnWindowOpen) {
            app.resetNextPageSession(true);
          }
          if (options.resetTabOnWindowOpen) {
            sessStorage.removeItem(options.session_tabid_key || "__openreplay_tabid");
          }
          app.resetNextPageSession(false);
          sessStorage.setItem(options.session_tabid_key || "__openreplay_tabid", tabId);
          return wOpen.call(window, ...args);
        };
      });
      app.attachStopCallback(() => {
        window.open = wOpen;
      });
    }
  }
  isFlagEnabled(flagName) {
    return this.featureFlags.isFlagEnabled(flagName);
  }
  onFlagsLoad(callback) {
    var _a3;
    (_a3 = this.app) == null ? void 0 : _a3.featureFlags.onFlagsLoad(callback);
  }
  clearPersistFlags() {
    var _a3;
    (_a3 = this.app) == null ? void 0 : _a3.featureFlags.clearPersistFlags();
  }
  reloadFlags() {
    var _a3;
    return (_a3 = this.app) == null ? void 0 : _a3.featureFlags.reloadFlags();
  }
  getFeatureFlag(flagName) {
    var _a3;
    return (_a3 = this.app) == null ? void 0 : _a3.featureFlags.getFeatureFlag(flagName);
  }
  getAllFeatureFlags() {
    var _a3;
    return (_a3 = this.app) == null ? void 0 : _a3.featureFlags.flags;
  }
  use(fn) {
    return fn(this.app, this.options);
  }
  isActive() {
    if (this.app === null) {
      return false;
    }
    return this.app.active();
  }
  /**
   * Creates a named hook that expects event name, data string and msg direction (up/down),
   * it will skip any message bigger than 5 mb or event name bigger than 255 symbols
   * msg direction is "down" (incoming) by default
   *
   * @returns {(msgType: string, data: string, dir: 'up' | 'down') => void}
   * */
  trackWs(channelName) {
    if (this.app === null) {
      return;
    }
    return this.app.trackWs(channelName);
  }
  start(startOpts) {
    if (this.browserEnvCheck()) {
      if (this.app === null) {
        return Promise.reject("Browser doesn't support required api, or doNotTrack is active.");
      }
      return this.app.start(startOpts);
    } else {
      return Promise.reject("Trying to start not in browser.");
    }
  }
  browserEnvCheck() {
    if (!IN_BROWSER) {
      console.error(`OpenReplay: you are trying to start Tracker on a node.js environment. If you want to use OpenReplay with SSR, please, use componentDidMount or useEffect API for placing the \`tracker.start()\` line. Check documentation on ${DOCS_HOST}${DOCS_SETUP}`);
      return false;
    }
    return true;
  }
  /**
   * start buffering messages without starting the actual session, which gives user 30 seconds to "activate" and record
   * session by calling start() on conditional trigger and we will then send buffered batch, so it won't get lost
   * */
  coldStart(startOpts, conditional) {
    if (this.browserEnvCheck()) {
      if (this.app === null) {
        return Promise.reject("Tracker not initialized");
      }
      void this.app.coldStart(startOpts, conditional);
    } else {
      return Promise.reject("Trying to start not in browser.");
    }
  }
  /**
   * Starts offline session recording. Keep in mind that only user device time will be used for timestamps.
   * (no backend delay sync)
   *
   * @param {Object} startOpts - options for session start, same as .start()
   * @param {Function} onSessionSent - callback that will be called once session is fully sent
   * @returns methods to manipulate buffer:
   *
   * saveBuffer - to save it in localStorage
   *
   * getBuffer - returns current buffer
   *
   * setBuffer - replaces current buffer with given
   * */
  startOfflineRecording(startOpts, onSessionSent) {
    if (this.browserEnvCheck()) {
      if (this.app === null) {
        return Promise.reject("Tracker not initialized");
      }
      return this.app.offlineRecording(startOpts, onSessionSent);
    } else {
      return Promise.reject("Trying to start not in browser.");
    }
  }
  /**
   * Uploads the stored session buffer to backend
   * @returns promise that resolves once messages are loaded, it has to be awaited
   * so the session can be uploaded properly
   * @resolve - if messages were loaded into service worker successfully
   * @reject {string} - error message
   * */
  uploadOfflineRecording() {
    if (this.app === null) {
      return;
    }
    return this.app.uploadOfflineRecording();
  }
  stop() {
    if (this.app === null) {
      return;
    }
    this.app.stop();
    return this.app.session.getSessionHash();
  }
  forceFlushBatch() {
    if (this.app === null) {
      return;
    }
    this.app.forceFlushBatch();
  }
  getSessionToken() {
    if (this.app === null) {
      return null;
    }
    return this.app.getSessionToken();
  }
  getSessionInfo() {
    if (this.app === null) {
      return null;
    }
    return this.app.session.getInfo();
  }
  getSessionID() {
    if (this.app === null) {
      return null;
    }
    return this.app.getSessionID();
  }
  getTabId() {
    if (this.app === null) {
      return null;
    }
    return this.app.getTabId();
  }
  getUxId() {
    if (this.app === null) {
      return null;
    }
    return this.app.getUxtId();
  }
  sessionID() {
    deprecationWarn("'sessionID' method", "'getSessionID' method", "/");
    return this.getSessionID();
  }
  getSessionURL(options) {
    if (this.app === null) {
      return void 0;
    }
    return this.app.getSessionURL(options);
  }
  setUserID(id2) {
    if (typeof id2 === "string" && this.app !== null) {
      this.app.session.setUserID(id2);
    }
  }
  userID(id2) {
    deprecationWarn("'userID' method", "'setUserID' method", "/");
    this.setUserID(id2);
  }
  setUserAnonymousID(id2) {
    if (typeof id2 === "string" && this.app !== null) {
      this.app.send(UserAnonymousID(id2));
    }
  }
  userAnonymousID(id2) {
    deprecationWarn("'userAnonymousID' method", "'setUserAnonymousID' method", "/");
    this.setUserAnonymousID(id2);
  }
  setMetadata(key, value) {
    if (typeof key === "string" && typeof value === "string" && this.app !== null) {
      this.app.session.setMetadata(key, value);
    }
  }
  metadata(key, value) {
    deprecationWarn("'metadata' method", "'setMetadata' method", "/");
    this.setMetadata(key, value);
  }
  event(key, payload = null, issue = false) {
    if (typeof key === "string" && this.app !== null) {
      if (issue) {
        return this.issue(key, payload);
      } else {
        try {
          payload = JSON.stringify(payload);
        } catch (e) {
          return;
        }
        this.app.send(CustomEvent(key, payload));
      }
    }
  }
  issue(key, payload = null) {
    if (typeof key === "string" && this.app !== null) {
      try {
        payload = JSON.stringify(payload);
      } catch (e) {
        return;
      }
      this.app.send(CustomIssue(key, payload));
    }
  }
};
export {
  App,
  Messages,
  SanitizeLevel,
  API as default
};
//# sourceMappingURL=@openreplay_tracker.js.map
